Proposal: Argument Parsing for Format Strings and Structured Data (Revised)

This document outlines the revised argument parsing strategy for lual.log, ensuring clarity when handling log calls that may involve printf-style format strings and/or structured data tables. This revision prioritizes an unambiguous API by determining behavior based on the type of the initial arguments.

Core Principle:
The interpretation of arguments passed to `logger.log(...)` is determined by the type of the first one or two arguments.

Defined Logging Call Patterns:

1.  Pattern 1: String Formatting Only
    *   Signature: `logger.log(message_format_string, ...format_args)`
    *   Condition: The first argument is a string.
    *   Parsing:
        *   `record.message_fmt`: The first argument (the string).
        *   `record.args`: All subsequent arguments, used to populate specifiers in `message_format_string`.
        *   `record.context`: `nil` (or an empty table).
    *   Example:
        `logger.log("User %s performed action: %s", userId, actionName)`
        `logger.log("Processing item %d of %d.", currentItem, totalItems)`
    *   Note: If a table is passed as one of the `...format_args`, it will be converted to its default string representation (e.g., "table: 0x...") by Lua's `string.format()`.

2.  Pattern 2: Structured Context with Optional String Formatting
    *   Signature: `logger.log(context_table, [message_format_string, ...format_args])`
    *   Condition: The first argument is a table.
    *   Parsing:
        *   `record.context`: The first argument (the table).
        *   Sub-case 2a: Context + Format String + Format Args
            *   If the second argument is a string:
                *   `record.message_fmt`: The second argument (the string).
                *   `record.args`: All arguments from the third onwards, used for specifiers in `message_format_string`.
            *   Example:
                `logger.log({ eventId = "XYZ789", user = "jane.doe" }, "Login attempt for user %s.", "jane.doe")`
                `logger.log({ system = "Auth", operation = "Login" }, "Processing request.")` (Here, `record.args` is empty)
        *   Sub-case 2b: Context Only (Pure Structured Logging)
            *   If there is no second argument, or the second argument is not a string:
                *   `record.message_fmt`: May be extracted from a conventional key within `context_table` (e.g., `context_table.msg`, `context_table.message`). If no such key is found, it could default to an empty string or a standard representation of the context. This detail needs to be defined by the `ingest` logic.
                *   `record.args`: An empty table.
            *   Example:
                `logger.log({ event = "SystemStart", version = "1.2.3" })`
                `logger.log({ error_code = 500, details = "Database connection failed", component = "DBConnector" })`
Implementation Notes for `ingest` Logic:

The `ingest` function in `lua/lual/core/engine.lua` will need to be updated to:
1.  Check the type of the first argument.
2.  If it's a string, proceed with Pattern 1 logic.
3.  If it's a table, assign it to `record.context` and then check the type of the second argument (if any) to differentiate between Sub-case 2a and 2b.

Implement this: 

1. First, change the current code so that mixed form (text and context) have their orders inverted. alter the code and update the tests that will break. 
2. when this is working, add files and commit. 
3. implement the formated string form, with tests.
4. when this is done and fixed, commit (no docs, no examples)
5. then alter docs at README.md, docs/api.txt (txt no md) to match