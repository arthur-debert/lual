LOGGER NAMES: HIERARCHICAL ORGANIZATION

Logger names in lual create automatic hierarchies using dot notation, similar
to Python's logging system. This allows fine-grained control over different
parts of your application while maintaining organized configuration.

When you request a logger with a dotted name like "app.database.connection",
lual automatically creates the entire hierarchy:
- "root" (the top-level logger)
- "app" (child of root)
- "app.database" (child of app)
- "app.database.connection" (child of app.database)

Each logger in the hierarchy can have its own level and dispatchers, but messages
propagate upward by default, allowing centralized handling.


AUTOMATIC LOGGER NAMING

When you call logger() without providing a name, lual automatically
generates a logger name based on the calling file's path:

    -- In file: src/database/connection.lua
    local lual = require("lual")
    local logger = lual.logger()  -- Creates logger named "src.database.connection"
    
    -- In file: app.lua  
    local logger = lual.logger()  -- Creates logger named "app"
    
    -- In file: /home/user/project/utils/parser.lua
    local logger = lual.logger()  -- Creates logger named "home.user.project.utils.parser"

The automatic naming process:
1. Uses debug.getinfo() to find the calling file
2. Removes the .lua extension
3. Converts path separators (/ and \) to dots
4. Removes leading dots from relative paths
5. Falls back to "root" if the process fails

This creates meaningful hierarchies that match your project structure without
requiring manual configuration.


BASIC USAGE

    local lual = require("lual")
    
    -- Automatic naming (uses filename)
    local logger = lual.logger()  -- Name derived from current file
    
    -- Explicit naming creates hierarchy automatically
    local app_logger = lual.logger("app")
    local db_logger = lual.logger("app.database")
    local conn_logger = lual.logger("app.database.connection")
    
    -- conn_logger's parent is db_logger
    -- db_logger's parent is app_logger  
    -- app_logger's parent is root logger
    -- lua


CONFIGURATION BY HIERARCHY LEVEL

You can configure different parts of your application independently:

    local lual = require("lual")
    
    -- Configure the entire app namespace
    local app_logger = lual.logger("app")
    app_logger:set_level(lual.levels.INFO)
    
    -- More verbose logging for database operations
    local db_logger = lual.logger("app.database")
    db_logger:set_level(lual.levels.DEBUG)
    
    -- Critical-only for authentication
    local auth_logger = lual.logger("app.auth")
    auth_logger:set_level(lual.levels.ERROR)
    -- lua

Each logger inherits behavior from its parents but can override settings.


PROPAGATION: HOW MESSAGES FLOW UPWARD

By default, log messages propagate up the hierarchy. When a child logger
processes a message, it also sends the message to its parent's dispatchers,
and so on up to the root.

    local lual = require("lual")
    local file_dispatcher = require("lual.dispatchers.file_dispatcher")
    
    -- Root logger writes everything to console (default)
    
    -- App logger also writes to a file
    local app_logger = lual.logger("app")
    app_logger:add_dispatcher(
        lualog.lib.file({ path = "app.log" }),
        lualog.lib.text
    )
    
    -- Database logger has no dispatchers of its own
    local db_logger = lual.logger("app.database")
    
    -- This message will be written to:
    -- 1. app.log (via app_logger's file dispatcher)
    -- 2. console (via root logger's console dispatcher)
    db_logger:info("Database connection established")
    -- lua


CONTROLLING PROPAGATION

You can disable propagation to stop messages from flowing upward:

    local lual = require("lual")
    
    local sensitive_logger = lual.logger("app.security.audit")
    sensitive_logger:add_dispatcher(
        lualog.lib.file({ path = "audit.log" }),
        lualog.lib.text
    )
    
    -- Prevent audit logs from appearing in general app logs
    sensitive_logger.propagate = false
    
    -- This only goes to audit.log, not to parent loggers
    sensitive_logger:critical("Security violation detected")
    -- lua


LEVEL FILTERING IN HIERARCHIES

Each logger in the hierarchy applies its own level filter. A message must
pass the level check at each step to continue propagating:

    local lual = require("lual")
    
    -- Root logger only shows warnings and above
    local root_logger = lual.logger()
    root_logger:set_level(lual.levels.WARNING)
    
    -- App logger shows info and above
    local app_logger = lual.logger("app")
    app_logger:set_level(lual.levels.INFO)
    
    -- Debug logger shows everything
    local debug_logger = lual.logger("app.debug")
    debug_logger:set_level(lual.levels.DEBUG)
    
    -- This message is processed by debug_logger and app_logger,
    -- but filtered out by root_logger (INFO < WARNING)
    debug_logger:info("Debug session started")
    -- lua


EXAMPLE: WEB APPLICATION HIERARCHY

    local lual = require("lual")
    
    -- Root: console dispatcher for all messages
    local root = lual.logger("root")  -- Explicit root
    root:set_level(lual.levels.INFO)
    
    -- App-wide file logging
    local app = lual.logger("webapp")
    app:add_dispatcher(
        lualog.lib.file({ path = "webapp.log" }),
        lualog.lib.text
    )
    
    -- HTTP requests: separate file, info level
    local http = lual.logger("webapp.http")
    http:add_dispatcher(
        lualog.lib.file({ path = "requests.log" }),
        lualog.lib.text
    )
    
    -- Database: debug level, shared with app file
    local db = lual.logger("webapp.database")
    db:set_level(lual.levels.DEBUG)
    
    -- Security: separate file, no propagation
    local security = lual.logger("webapp.security")
    security:add_dispatcher(
        lualog.lib.file({ path = "security.log" }),
        lualog.lib.text
    )
    security.propagate = false
    
    -- Usage examples:
    http:info("GET /users - 200")        -- → requests.log, webapp.log, console
    db:debug("Query executed in 15ms")   -- → webapp.log, console
    security:error("Failed login")       -- → security.log only
    -- lua


AUTOMATIC VS EXPLICIT NAMING

Automatic naming is ideal for simple cases where you want one logger per file:

    -- In file: src/models/user.lua
    local lual = require("lual")
    local logger = lual.logger()  -- Creates "src.models.user" logger
    
    logger:info("User model loaded")
    logger:debug("Validating user data")

Explicit naming gives you full control over the hierarchy:

    -- In file: src/models/user.lua  
    local lual = require("lual")
    local logger = lual.logger("models.user.validation")  -- Custom hierarchy
    local db_logger = lual.logger("models.user.database")  -- Separate concerns
    
    logger:info("Validation rules loaded")
    db_logger:debug("User table schema verified")

You can mix both approaches in the same application. Automatic naming creates
loggers that fit naturally into explicitly named hierarchies.


INTERNALS

Logger hierarchy is built using string pattern matching on the logger name.
When requesting "app.database.connection", lual:

1. **Splits the name** at dots to find the parent: "app.database"
2. **Recursively creates parents** if they don't exist
3. **Caches all loggers** for efficient repeated access
4. **Links parent references** to enable propagation

For automatic naming, lual uses `debug.getinfo()` to inspect the call stack:

1. **Finds the calling file** by walking up the stack
2. **Skips lual internal files** to find the actual caller
3. **Converts the filename** using the dot notation rules
4. **Falls back to "root"** if conversion fails or returns empty

The `get_effective_dispatchers()` method walks up the hierarchy, collecting dispatchers
from each logger where `propagate` is true. Each logger applies its own level
filter before processing dispatchers.

Propagation stops when:
- A logger has `propagate = false`
- The logger has no parent (reached root)
- A parent logger's level filters out the message

This design allows both centralized configuration (via root/parent loggers)
and fine-grained control (via specific child loggers) in the same application.
Automatic naming integrates seamlessly with explicit hierarchies, creating
logger names that reflect your project's file structure.
