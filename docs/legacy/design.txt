LUAL LOGGING: REFINED DESIGN

This document outlines the refined design for lual's logging system,
aiming for simplicity, predictability, and alignment with Python's
standard logging practices.

CORE PRINCIPLES
---------------

1.  Root Logger (_root):
    *   Internal Name: The root logger is internally named `_root`. User-created
        logger names starting with `_` are discouraged or disallowed to avoid
        collision. `lual.logger("root")` would create a child of `_root`
        named "root".
    *   Library Defaults: On first use (e.g., when `lual` is required), `_root`
        is automatically created and configured with library defaults:
        -   Level: `lual.WARN`
        -   Pipelines: A single default pipeline with console output, text presenter,
            and local time.
        -   Propagate: `true` (though propagation from `_root` has no further effect).
    *   User Configuration: The primary way to modify `_root`'s behavior is via
        `lual.config(config_table)`. This function applies the settings from
        `config_table` (level, pipelines, etc.) directly to `_root`,
        overriding the library defaults for the specified keys.

2.  User Loggers (Non-Root):
    *   Creation: Created via `lual.logger("name")` or
        `lual.logger("name", {config_table})`.
    *   Sparse Configuration: A user logger's configuration table only stores
        values explicitly set by the user.
    *   Initial Defaults:
        -   Level: `lual.NOTSET`. This special value means the logger's
            effective level will be determined by its closest ancestor (parent,
            grandparent, etc., up to `_root`) that has an explicit level set.
        -   Pipelines: An empty list (`{}`). Loggers have no pipelines by default.
        -   Propagate: `true`. This flag determines if an event, after being
            processed by this logger, should be passed to its parent logger.
            This is configurable per logger.

3.  Pipeline Processing (for any logger `L` processing an event):
    *   Effective Level Calculation:
        1. If `L.level` is not `lual.NOTSET`, its effective level is `L.level`.
        2. If `L.level` is `lual.NOTSET`, its effective level is taken from
           `L.parent.effective_level` (this is a recursive lookup until an
           explicit level is found, ultimately resolving to `_root.level`).
    *   Level Match: An event is processed by `L` if `event_level >= L.effective_level`.
    *   Pipeline Processing: If the level matches, `L` processes the event through
        each of its *own* pipelines. Each pipeline:
        - Checks its own level threshold against the event level
        - If the pipeline threshold is met, processes the event through:
          * Transformers (optional, sequential)
          * Presenter (formats the record)
          * Outputs (sends to all configured destinations)
        Pipelines are NOT inherited or merged from ancestors.
    *   Propagation: If `L.propagate` is `true` and `L` is not `_root`, the
        original event is then passed to `L.parent` for processing.

4.  Configuration Keys & Properties:
    *   `name`: An identifier, not a configurable property within a logger's
        settings table.
    *   `level`: The threshold for this logger. Can be `lual.NOTSET`.
    *   `pipelines`: A list of pipeline configurations specific to this logger.
        Each pipeline contains:
        - `level`: Optional threshold for this specific pipeline
        - `outputs`: List of output functions (console, file, syslog, etc.)
        - `presenter`: Formatting function (text, JSON, color)
        - `transformers`: Optional list of data transformation functions
    *   `propagate`: Boolean, defaults to `true` for user loggers.
    *   `time`: Time-related settings (e.g., UTC/local, format string) are
        properties of a *presenter*, which is part of a *pipeline's*
        configuration. Loggers themselves do not have a top-level `time` property.

HOW IT WORKS: EVENT FLOW
------------------------

When `some_logger.info("message")` is called:

1.  The `info` call creates a log event with level `lual.INFO` and "message".
2.  The event is passed to `some_logger` for processing.
3.  `some_logger` determines its effective level:
    *   If `some_logger.level` is `lual.DEBUG`, its effective level is `DEBUG`.
    *   If `some_logger.level` is `lual.NOTSET` and its parent `app_logger` has
        effective level `lual.INFO`, then `some_logger`'s effective level
        becomes `lual.INFO`. This continues up to `_root`.
4.  Level Check: `lual.INFO` (event) >= `some_logger.effective_level`?
5.  If true (level matches):
    *   `some_logger` iterates through its *own* `pipelines` list.
    *   For each pipeline:
        - Check if `event_level >= pipeline.level` (if pipeline level is set)
        - If pipeline level matches, process through transformers (if any)
        - Format the event with the pipeline's presenter
        - Send to all outputs in the pipeline
    *   If `some_logger` has no pipelines, it performs no processing itself.
6.  If `some_logger.propagate` is `true` (and `some_logger` is not `_root`):
    *   The original event is passed to `some_logger.parent`.
    *   The parent logger repeats steps 3-6.
7.  This continues until propagation is stopped (`propagate = false`) or the
    event reaches `_root` and is processed by it.

