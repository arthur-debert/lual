LUAL LOGGING: REFINED DESIGN

This document outlines the refined design for lual's logging system,
aiming for simplicity, predictability, and alignment with Python's
standard logging practices.

CORE PRINCIPLES
---------------

1.  Root Logger (_root):
    *   Internal Name: The root logger is internally named `_root`. User-created
        logger names starting with `_` are discouraged or disallowed to avoid
        collision. `lual.logger("root")` would create a child of `_root`
        named "root".
    *   Library Defaults: On first use (e.g., when `lual` is required), `_root`
        is automatically created and configured with library defaults:
        -   Level: `lual.WARN`
        -   Dispatchers: A single console dispatcher (e.g., to stdout).
        -   Presenter: A default presenter (e.g., text-based, colorized, using
            local time).
        -   Propagate: `true` (though propagation from `_root` has no further effect).
    *   User Configuration: The primary way to modify `_root`'s behavior is via
        `lual.config(config_table)`. This function applies the settings from
        `config_table` (level, dispatchers, etc.) directly to `_root`,
        overriding the library defaults for the specified keys.

2.  User Loggers (Non-Root):
    *   Creation: Created via `lual.logger("name")` or
        `lual.logger("name", {config_table})`.
    *   Sparse Configuration: A user logger's configuration table only stores
        values explicitly set by the user.
    *   Initial Defaults:
        -   Level: `lual.NOTSET`. This special value means the logger's
            effective level will be determined by its closest ancestor (parent,
            grandparent, etc., up to `_root`) that has an explicit level set.
        -   Dispatchers: An empty list (`{}`). Loggers do not have dispatchers
            by default.
        -   Propagate: `true`. This flag determines if an event, after being
            processed by this logger, should be passed to its parent logger.
            This is configurable per logger.

3.  Dispatch Decision (for any logger `L` processing an event):
    *   Effective Level Calculation:
        1. If `L.level` is not `lual.NOTSET`, its effective level is `L.level`.
        2. If `L.level` is `lual.NOTSET`, its effective level is taken from
           `L.parent.effective_level` (this is a recursive lookup until an
           explicit level is found, ultimately resolving to `_root.level`).
    *   Level Match: An event is processed by `L` if `event_level >= L.effective_level`.
    *   Dispatching: If the level matches, `L` passes the event to each of its
        *own* dispatchers (those in `L.dispatchers`). Each dispatcher uses its
        own associated presenter and configuration (e.g., file path, time format).
        Dispatchers are NOT inherited or merged from ancestors.
    *   Propagation: If `L.propagate` is `true` and `L` is not `_root`, the
        original event is then passed to `L.parent` for processing.

4.  Configuration Keys & Properties:
    *   `name`: An identifier, not a configurable property within a logger's
        settings table.
    *   `level`: The threshold for this logger. Can be `lual.NOTSET`.
    *   `dispatchers`: A list of dispatcher tables specific to this logger.
    *   `propagate`: Boolean, defaults to `true` for user loggers.
    *   `time`: Time-related settings (e.g., UTC/local, format string) are
        properties of a *presenter*, which is, in turn, part of a
        *dispatcher's* configuration. Loggers themselves do not have a
        top-level `time` property.

HOW IT WORKS: EVENT FLOW
------------------------

When `some_logger.info("message")` is called:

1.  The `info` call creates a log event with level `lual.INFO` and "message".
2.  The event is passed to `some_logger` for processing.
3.  `some_logger` determines its effective level:
    *   If `some_logger.level` is `lual.DEBUG`, its effective level is `DEBUG`.
    *   If `some_logger.level` is `lual.NOTSET` and its parent `app_logger` has
        effective level `lual.INFO`, then `some_logger`'s effective level
        becomes `lual.INFO`. This continues up to `_root`.
4.  Level Check: `lual.INFO` (event) >= `some_logger.effective_level`?
5.  If true (level matches):
    *   `some_logger` iterates through its *own* `dispatchers` list.
    *   For each dispatcher, the event is formatted by the dispatcher's
        presenter and sent to the dispatcher's target (console, file, etc.).
    *   If `some_logger` has no dispatchers, it outputs nothing itself.
6.  If `some_logger.propagate` is `true` (and `some_logger` is not `_root`):
    *   The original event is passed to `some_logger.parent`.
    *   The parent logger repeats steps 3-6.
7.  This continues until propagation is stopped (`propagate = false`) or the
    event reaches `_root` and is processed by it.

