LUAL LOGGING: REFINED DESIGN

This document outlines the refined design for lual's logging system,
aiming for simplicity, predictability, and alignment with Python's
standard logging practices.

CORE PRINCIPLES
---------------

1.  Root Logger (_root):
    *   Internal Name: The root logger is internally named `_root`. User-created
        logger names starting with `_` are discouraged or disallowed to avoid
        collision. `lual.logger("root")` would create a child of `_root`
        named "root".
    *   Library Defaults: On first use (e.g., when `lual` is required), `_root`
        is automatically created and configured with library defaults:
        -   Level: `lual.WARN`
        -   Dispatchers: A single console dispatcher (e.g., to stdout).
        -   Presenter: A default presenter (e.g., text-based, colorized, using
            local time).
        -   Propagate: `true` (though propagation from `_root` has no further effect).
    *   User Configuration: The primary way to modify `_root`'s behavior is via
        `lual.config(config_table)`. This function applies the settings from
        `config_table` (level, dispatchers, etc.) directly to `_root`,
        overriding the library defaults for the specified keys.

2.  User Loggers (Non-Root):
    *   Creation: Created via `lual.logger("name")` or
        `lual.logger("name", {config_table})`.
    *   Sparse Configuration: A user logger's configuration table only stores
        values explicitly set by the user.
    *   Initial Defaults:
        -   Level: `lual.NOTSET`. This special value means the logger's
            effective level will be determined by its closest ancestor (parent,
            grandparent, etc., up to `_root`) that has an explicit level set.
        -   Dispatchers: An empty list (`{}`). Loggers do not have dispatchers
            by default.
        -   Propagate: `true`. This flag determines if an event, after being
            processed by this logger, should be passed to its parent logger.
            This is configurable per logger.

3.  Dispatch Decision (for any logger `L` processing an event):
    *   Effective Level Calculation:
        1. If `L.level` is not `lual.NOTSET`, its effective level is `L.level`.
        2. If `L.level` is `lual.NOTSET`, its effective level is taken from
           `L.parent.effective_level` (this is a recursive lookup until an
           explicit level is found, ultimately resolving to `_root.level`).
    *   Level Match: An event is processed by `L` if `event_level >= L.effective_level`.
    *   Dispatching: If the level matches, `L` passes the event to each of its
        *own* dispatchers (those in `L.dispatchers`). Each dispatcher uses its
        own associated presenter and configuration (e.g., file path, time format).
        Dispatchers are NOT inherited or merged from ancestors.
    *   Propagation: If `L.propagate` is `true` and `L` is not `_root`, the
        original event is then passed to `L.parent` for processing.

4.  Configuration Keys & Properties:
    *   `name`: An identifier, not a configurable property within a logger's
        settings table.
    *   `level`: The threshold for this logger. Can be `lual.NOTSET`.
    *   `dispatchers`: A list of dispatcher tables specific to this logger.
    *   `propagate`: Boolean, defaults to `true` for user loggers.
    *   `time`: Time-related settings (e.g., UTC/local, format string) are
        properties of a *presenter*, which is, in turn, part of a
        *dispatcher's* configuration. Loggers themselves do not have a
        top-level `time` property.

HOW IT WORKS: EVENT FLOW
------------------------

When `some_logger.info("message")` is called:

1.  The `info` call creates a log event with level `lual.INFO` and "message".
2.  The event is passed to `some_logger` for processing.
3.  `some_logger` determines its effective level:
    *   If `some_logger.level` is `lual.DEBUG`, its effective level is `DEBUG`.
    *   If `some_logger.level` is `lual.NOTSET` and its parent `app_logger` has
        effective level `lual.INFO`, then `some_logger`'s effective level
        becomes `lual.INFO`. This continues up to `_root`.
4.  Level Check: `lual.INFO` (event) >= `some_logger.effective_level`?
5.  If true (level matches):
    *   `some_logger` iterates through its *own* `dispatchers` list.
    *   For each dispatcher, the event is formatted by the dispatcher's
        presenter and sent to the dispatcher's target (console, file, etc.).
    *   If `some_logger` has no dispatchers, it outputs nothing itself.
6.  If `some_logger.propagate` is `true` (and `some_logger` is not `_root`):
    *   The original event is passed to `some_logger.parent`.
    *   The parent logger repeats steps 3-6.
7.  This continues until propagation is stopped (`propagate = false`) or the
    event reaches `_root` and is processed by it.

EXAMPLES
--------

1.  Simplest Case (Out-of-the-box, no user config):

    ```lua
    -- in main.lua
    local lual = require("lual")
    local logger = lual.logger("myApp") -- Gets auto-name if no arg

    logger.debug("This is a debug message.") -- Not logged
    logger.warn("This is a warning.")       -- Logged to console
    logger.error("This is an error!")       -- Logged to console
    ```

    *   `_root` exists with level `lual.WARN` and a console dispatcher.
    *   `logger` ("myApp") has `level = lual.NOTSET`, no dispatchers, `propagate = true`.
    *   `logger.debug`:
        - Effective level for "myApp" is `WARN` (from `_root`).
        - `DEBUG < WARN`. No match. "myApp" does not dispatch.
        - Propagates to `_root`. `DEBUG < _root.level (WARN)`. No match. `_root` does not dispatch.
    *   `logger.warn`:
        - Effective level for "myApp" is `WARN`.
        - `WARN >= WARN`. Match! "myApp" has no dispatchers, so it logs nothing itself.
        - Propagates to `_root`. `WARN >= _root.level (WARN)`. Match! `_root` uses its
          console dispatcher. Output: "This is a warning." (formatted by
          `_root`'s default presenter).

2.  User Configures Root Logger:

    ```lua
    -- in init.lua (early in application)
    local lual = require("lual")
    lual.config({
        level = lual.DEBUG,
        dispatchers = {
            {
                type = lual.file,
                path = "/var/log/my_app.log",
                presenter = { type = lual.json } -- Example: JSON presenter
            }
        }
    })

    -- in some_module.lua
    local mod_logger = lual.logger("myApp.moduleA")
    mod_logger.debug("Module A is starting up.") -- Logged to file as JSON
    mod_logger.info("Module A info.")           -- Logged to file as JSON
    ```

    *   `lual.config` reconfigures `_root`:
        - `_root.level` is now `lual.DEBUG`.
        - `_root.dispatchers` now contains only the file dispatcher writing JSON.
    *   `mod_logger` ("myApp.moduleA"): `level = lual.NOTSET`, no dispatchers, `propagate = true`.
    *   `mod_logger.debug`:
        - Effective level for "myApp.moduleA" is `DEBUG` (from `_root`).
        - `DEBUG >= DEBUG`. Match! "myApp.moduleA" has no dispatchers.
        - Propagates to "myApp" (if it exists, otherwise directly to `_root`).
          Assume "myApp" also has `level = lual.NOTSET` and no dispatchers.
        - Propagates to `_root`. `DEBUG >= _root.level (DEBUG)`. Match! `_root` uses
          its file/JSON dispatcher. Output to `/var/log/my_app.log`.

3.  Logger-Specific Configuration with Root Config:

    ```lua
    -- in init.lua
    local lual = require("lual")
    lual.config({
        level = lual.INFO, -- Root level is INFO
        dispatchers = {
            { type = lual.file, path = "app.log", presenter = { type = lual.text } }
        }
    })

    -- in feature_x.lua
    local feature_logger = lual.logger("app.featureX", {
        level = lual.DEBUG, -- This logger is more verbose
        dispatchers = {
            { type = lual.console, presenter = { type = lual.color } }
        },
        propagate = true -- Explicitly true, could be false
    })

    feature_logger.debug("A detailed debug message from Feature X.")
    -- Output: To console (colorized) by feature_logger.
    --         NOT to app.log (root is INFO, event is DEBUG).

    feature_logger.warn("A warning from Feature X.")
    -- Output: To console (colorized) by feature_logger.
    -- Output: To app.log (text) by _root logger.
    ```

    *   `_root` level: `lual.INFO`, file dispatcher.
    *   `feature_logger` ("app.featureX"):
        - Level: `lual.DEBUG` (explicitly set).
        - Dispatchers: Its own console/color dispatcher.
        - Propagate: `true`.
    *   `feature_logger.debug("A detailed debug message...")`:
        - `feature_logger` effective level is `DEBUG`. `DEBUG >= DEBUG`. Match!
        - `feature_logger` dispatches to its console/color dispatcher.
        - Propagates to `_root`. `_root` level is `INFO`. `DEBUG < INFO`. No match.
          `_root` does not dispatch.
    *   `feature_logger.warn("A warning from Feature X.")`:
        - `feature_logger` effective level is `DEBUG`. `WARN >= DEBUG`. Match!
        - `feature_logger` dispatches to its console/color dispatcher.
        - Propagates to `_root`. `_root` level is `INFO`. `WARN >= INFO`. Match!
        - `_root` dispatches to its file/text dispatcher.

This design ensures that loggers only act based on their own configurations
(or inherited level if `NOTSET`) and explicitly defined dispatchers.
Propagation allows higher-level loggers to also process the event if desired,
without complex merging of dispatcher behaviors.
