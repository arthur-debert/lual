API 

lual gives various ways to construct your logger:

1. Imperative: 

    A series of functional calls to the logger object, each setting part of the config. 

        -- example

            local lual = require("lual")
            local logger = lualog.logger("app.database")
            logger:set_level("debug")

            logger:add_dispatcher(
                lualog.lib.console,
                lualog.lib.text,
                { stream = io.stdout }  -- optional config
            )
            
            -- Add file dispatcher
            logger:add_dispatcher(
                lualog.lib.file({ path = "app.log" }),
                lualog.lib.text
            )
            
            -- Add colored console dispatcher
            logger:add_dispatcher(
                lualog.lib.console,
                lualog.lib.color,
                { stream = io.stderr }
            )


2. Config API:

    A single call to the logger object with a config table. The config API supports two syntax options:

    a) Full syntax - Complete control with explicit dispatchers array:

            -- example: 

                local logger = require("lualog").logger({
                    name = "app.database",
                    level = "debug",
                    dispatchers = {
                        {type = "console", presenter = "color"},
                        {type = "file", path = "app.log", presenter = "text"}
                    }
                })

    b) Convenience syntax - Convenient syntax for single dispatcher cases:

        For the very common case where there is one dispatcher and one presenter, 
        you can use this convenience syntax:

            local lualog = require("lualog")
            -- Convenience syntax for single dispatcher + presenter
            local logger = lualog.logger({
                dispatcher = "console", 
                level = "debug", 
                presenter = "color"
            })

        The convenience syntax is automatically transformed to the full syntax internally.
        Both approaches create identical logger instances.


IMPLEMENTATION DESIGN:

Single Config Table Architecture:

All loggers are internally created from a canonical config table. This provides:
- Single source of truth for logger configuration
- Consistency between imperative and config APIs  
- Easier testing and maintenance

Core approach:
1. Define canonical config schema
2. All logger creation goes through create_logger_from_config(config)
3. Imperative methods become config transformations:
   - Get current config -> clone -> modify -> recreate logger
4. Config API normalizes input to canonical config (convenience -> full -> canonical)
5. Performance cost negligible (config changes are rare)

Benefits:
- No configuration logic duplication
- New config options work across all APIs automatically
- Immutable config state (safer, more predictable)
- Clean separation of concerns


CONFIG API IMPLEMENTATION:

The config API processes input through a unified pipeline:

1. Input Detection: Automatically detect convenience vs full syntax
2. Normalization: Transform convenience syntax to full syntax if needed
3. Validation: Validate the normalized config
4. Canonicalization: Convert to internal canonical format
5. Logger Creation: Create logger from canonical config

Key considerations:

1. Partial configs are supported - merge with defaults:
   User config takes precedence over default values.

2. Validation ensures correctness:
   - Unknown keys: Rejected to prevent silent configuration errors
   - Type validation: levels, names, dispatcher types, etc.
   - Required fields: dispatcher type, presenter type for each dispatcher
   - Conditional validation: file dispatcher requires path field

3. Error messages are context-aware:
   - "Invalid config:" for full syntax errors

The unified approach eliminates API confusion while maintaining convenience.