EXAMPLES
--------

1.  Simplest Case (Out-of-the-box, no user config):

    ```lua
    -- in main.lua
    local lual = require("lual")
    local logger = lual.logger("myApp") -- Gets auto-name if no arg

    logger.debug("This is a debug message.") -- Not logged
    logger.warn("This is a warning.")       -- Logged to console
    logger.error("This is an error!")       -- Logged to console
    ```

    *   `_root` exists with level `lual.WARN` and a console output.
    *   `logger` ("myApp") has `level = lual.NOTSET`, no outputs, `propagate = true`.
    *   `logger.debug`:
        - Effective level for "myApp" is `WARN` (from `_root`).
        - `DEBUG < WARN`. No match. "myApp" does not output.
        - Propagates to `_root`. `DEBUG < _root.level (WARN)`. No match. `_root` does not output.
    *   `logger.warn`:
        - Effective level for "myApp" is `WARN`.
        - `WARN >= WARN`. Match! "myApp" has no outputs, so it logs nothing itself.
        - Propagates to `_root`. `WARN >= _root.level (WARN)`. Match! `_root` uses its
          console output. Output: "This is a warning." (formatted by
          `_root`'s default presenter).

2.  User Configures Root Logger:

    ```lua
    -- in init.lua (early in application)
    local lual = require("lual")
    lual.config({
        level = lual.DEBUG,
        outputs = {
            {
                type = lual.file,
                path = "/var/log/my_app.log",
                presenter = { type = lual.json } -- Example: JSON presenter
            }
        }
    })

    -- in some_module.lua
    local mod_logger = lual.logger("myApp.moduleA")
    mod_logger.debug("Module A is starting up.") -- Logged to file as JSON
    mod_logger.info("Module A info.")           -- Logged to file as JSON
    ```

    *   `lual.config` reconfigures `_root`:
        - `_root.level` is now `lual.DEBUG`.
        - `_root.outputs` now contains only the file output writing JSON.
    *   `mod_logger` ("myApp.moduleA"): `level = lual.NOTSET`, no outputs, `propagate = true`.
    *   `mod_logger.debug`:
        - Effective level for "myApp.moduleA" is `DEBUG` (from `_root`).
        - `DEBUG >= DEBUG`. Match! "myApp.moduleA" has no outputs.
        - Propagates to "myApp" (if it exists, otherwise directly to `_root`).
          Assume "myApp" also has `level = lual.NOTSET` and no outputs.
        - Propagates to `_root`. `DEBUG >= _root.level (DEBUG)`. Match! `_root` uses
          its file/JSON output. Output to `/var/log/my_app.log`.

3.  Logger-Specific Configuration with Root Config:

    ```lua
    -- in init.lua
    local lual = require("lual")
    lual.config({
        level = lual.INFO, -- Root level is INFO
        outputs = {
            { type = lual.file, path = "app.log", presenter = { type = lual.text } }
        }
    })

    -- in feature_x.lua
    local feature_logger = lual.logger("app.featureX", {
        level = lual.DEBUG, -- This logger is more verbose
        outputs = {
            { type = lual.console, presenter = { type = lual.color } }
        },
        propagate = true -- Explicitly true, could be false
    })

    feature_logger.debug("A detailed debug message from Feature X.")
    -- Output: To console (colorized) by feature_logger.
    --         NOT to app.log (root is INFO, event is DEBUG).

    feature_logger.warn("A warning from Feature X.")
    -- Output: To console (colorized) by feature_logger.
    -- Output: To app.log (text) by _root logger.
    ```

    *   `_root` level: `lual.INFO`, file output.
    *   `feature_logger` ("app.featureX"):
        - Level: `lual.DEBUG` (explicitly set).
        - outputs: Its own console/color output.
        - Propagate: `true`.
    *   `feature_logger.debug("A detailed debug message...")`:
        - `feature_logger` effective level is `DEBUG`. `DEBUG >= DEBUG`. Match!
        - `feature_logger` outputes to its console/color output.
        - Propagates to `_root`. `_root` level is `INFO`. `DEBUG < INFO`. No match.
          `_root` does not output.
    *   `feature_logger.warn("A warning from Feature X.")`:
        - `feature_logger` effective level is `DEBUG`. `WARN >= DEBUG`. Match!
        - `feature_logger` outputes to its console/color output.
        - Propagates to `_root`. `_root` level is `INFO`. `WARN >= INFO`. Match!
        - `_root` outputes to its file/text output.

This design ensures that loggers only act based on their own configurations
(or inherited level if `NOTSET`) and explicitly defined outputs.
Propagation allows higher-level loggers to also process the event if desired,
without complex merging of output behaviors.


4. output-Specific Levels: 


    outputs can be (optionally) be configured with their own levels. During
    the output loop, once a logger iterates over it's outputs, it does a
    level check against the outputs. Note that this ocurs after the logger's
    own , hence a output's level set to lower (more verbose) then the loggers 
    will never output.

    By default, outputs levels are `NOTSET`, meaning they will be evaluated
    to the logger's effective level. 

    This allows for more granular control over which events are sent to each
    output, for example: 

    ``lua

        local lual = require("lual")

        lual.config({
            level = lual.DEBUG, -- Root level is INFO
            outputs = {
                { level = lual.DEBUG, type = lual.file, path = "app.log", presenter = { type = lual.json } }
                { level = lual.WARN, type = lual.console, presenter = { type = lual.text } }
            }
        })

    ````


