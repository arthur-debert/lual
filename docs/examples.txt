EXAMPLES
--------

1.  Simplest Case (Out-of-the-box, no user config):

    ```lua
    -- in main.lua
    local lual = require("lual")
    local logger = lual.logger("myApp") -- Gets auto-name if no arg

    logger.debug("This is a debug message.") -- Not logged
    logger.warn("This is a warning.")       -- Logged to console
    logger.error("This is an error!")       -- Logged to console
    ```

    *   `_root` exists with level `lual.WARN` and a console dispatcher.
    *   `logger` ("myApp") has `level = lual.NOTSET`, no dispatchers, `propagate = true`.
    *   `logger.debug`:
        - Effective level for "myApp" is `WARN` (from `_root`).
        - `DEBUG < WARN`. No match. "myApp" does not dispatch.
        - Propagates to `_root`. `DEBUG < _root.level (WARN)`. No match. `_root` does not dispatch.
    *   `logger.warn`:
        - Effective level for "myApp" is `WARN`.
        - `WARN >= WARN`. Match! "myApp" has no dispatchers, so it logs nothing itself.
        - Propagates to `_root`. `WARN >= _root.level (WARN)`. Match! `_root` uses its
          console dispatcher. Output: "This is a warning." (formatted by
          `_root`'s default presenter).

2.  User Configures Root Logger:

    ```lua
    -- in init.lua (early in application)
    local lual = require("lual")
    lual.config({
        level = lual.DEBUG,
        dispatchers = {
            {
                type = lual.file,
                path = "/var/log/my_app.log",
                presenter = { type = lual.json } -- Example: JSON presenter
            }
        }
    })

    -- in some_module.lua
    local mod_logger = lual.logger("myApp.moduleA")
    mod_logger.debug("Module A is starting up.") -- Logged to file as JSON
    mod_logger.info("Module A info.")           -- Logged to file as JSON
    ```

    *   `lual.config` reconfigures `_root`:
        - `_root.level` is now `lual.DEBUG`.
        - `_root.dispatchers` now contains only the file dispatcher writing JSON.
    *   `mod_logger` ("myApp.moduleA"): `level = lual.NOTSET`, no dispatchers, `propagate = true`.
    *   `mod_logger.debug`:
        - Effective level for "myApp.moduleA" is `DEBUG` (from `_root`).
        - `DEBUG >= DEBUG`. Match! "myApp.moduleA" has no dispatchers.
        - Propagates to "myApp" (if it exists, otherwise directly to `_root`).
          Assume "myApp" also has `level = lual.NOTSET` and no dispatchers.
        - Propagates to `_root`. `DEBUG >= _root.level (DEBUG)`. Match! `_root` uses
          its file/JSON dispatcher. Output to `/var/log/my_app.log`.

3.  Logger-Specific Configuration with Root Config:

    ```lua
    -- in init.lua
    local lual = require("lual")
    lual.config({
        level = lual.INFO, -- Root level is INFO
        dispatchers = {
            { type = lual.file, path = "app.log", presenter = { type = lual.text } }
        }
    })

    -- in feature_x.lua
    local feature_logger = lual.logger("app.featureX", {
        level = lual.DEBUG, -- This logger is more verbose
        dispatchers = {
            { type = lual.console, presenter = { type = lual.color } }
        },
        propagate = true -- Explicitly true, could be false
    })

    feature_logger.debug("A detailed debug message from Feature X.")
    -- Output: To console (colorized) by feature_logger.
    --         NOT to app.log (root is INFO, event is DEBUG).

    feature_logger.warn("A warning from Feature X.")
    -- Output: To console (colorized) by feature_logger.
    -- Output: To app.log (text) by _root logger.
    ```

    *   `_root` level: `lual.INFO`, file dispatcher.
    *   `feature_logger` ("app.featureX"):
        - Level: `lual.DEBUG` (explicitly set).
        - Dispatchers: Its own console/color dispatcher.
        - Propagate: `true`.
    *   `feature_logger.debug("A detailed debug message...")`:
        - `feature_logger` effective level is `DEBUG`. `DEBUG >= DEBUG`. Match!
        - `feature_logger` dispatches to its console/color dispatcher.
        - Propagates to `_root`. `_root` level is `INFO`. `DEBUG < INFO`. No match.
          `_root` does not dispatch.
    *   `feature_logger.warn("A warning from Feature X.")`:
        - `feature_logger` effective level is `DEBUG`. `WARN >= DEBUG`. Match!
        - `feature_logger` dispatches to its console/color dispatcher.
        - Propagates to `_root`. `_root` level is `INFO`. `WARN >= INFO`. Match!
        - `_root` dispatches to its file/text dispatcher.

This design ensures that loggers only act based on their own configurations
(or inherited level if `NOTSET`) and explicitly defined dispatchers.
Propagation allows higher-level loggers to also process the event if desired,
without complex merging of dispatcher behaviors.


4. Dispatcher-Specific Levels: 


    Dispatchers can be (optionally) be configured with their own levels. During
    the dispatch loop, once a logger iterates over it's dispatchers, it does a
    level check against the dispatchers. Note that this ocurs after the logger's
    own , hence a dispatcher's level set to lower (more verbose) then the loggers 
    will never dispatch.

    By default, dispatchers levels are `NOTSET`, meaning they will be evaluated
    to the logger's effective level. 

    This allows for more granular control over which events are sent to each
    output, for example: 

    ``lua

        local lual = require("lual")

        lual.config({
            level = lual.DEBUG, -- Root level is INFO
            dispatchers = {
                { level = lual.DEBUG, type = lual.file, path = "app.log", presenter = { type = lual.json } }
                { level = lual.WARN, type = lual.console, presenter = { type = lual.text } }
            }
        })

    ````


