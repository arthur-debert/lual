lual Logging Components: Transformers, Presenters & outputs

1.  Overview: The Log Record Flow

    In lual, when you call `logger:info("message")`, your log event flows through a precise pipeline:

    ```
    Logger Emit → Log Record Creation → Transformers → Presenter → output → Output
    ```

    Each component has a specific role:
    - **Transformers**: Modify log record data (add/change fields)
    - **Presenters**: Format the record into a string (text, JSON, colors)
    - **outputs**: Send the formatted string to an output destination (console, file, syslog)


2. Transformers: Data Modification

    2.1 What They Do

        Transformers are functions that receive a log record and return a modified version. They sit between the logger and presenter, allowing you to:

        - Add metadata fields
        - Modify existing data
        - Enrich records with contextual information
        - Filter or transform field values

    2.2 Structure & Factory Pattern
        Transformers follow a factory pattern that returns callable tables with schemas:

        ```lua
        local function custom_transformer_factory(config)
            config = config or {}
            
            local function transformer_func(record)
                -- Create a copy to avoid mutating the original
                local transformed_record = {}
                for k, v in pairs(record) do
                    transformed_record[k] = v
                end
                
                -- Your modifications here
                transformed_record.custom_field = "added_value"
                
                return transformed_record
            end
            
            local transformer_with_schema = {
                schema = { /* config validation schema */ }
            }
            
            setmetatable(transformer_with_schema, {
                __call = function(_, record)
                    return transformer_func(record)
                end
            })
            
            return transformer_with_schema
        end
        ```

        ### Configuration
        ```lua
        local logger = lual.logger({
            outputs = {
                {
                    type = lual.console,
                    presenter = lual.text,
                    transformers = {
                        { type = lual.noop },
                        { type = lual.custom, prefix = "[APP] " }
                    }
                }
            }
        })
        ```

        Transformers are applied sequentially - each transformer receives the output of the previous one.

3.  Presenters: Data Formatting

    3.1  What They Do
    Presenters convert log records into formatted strings ready for output. They handle:

    - Message formatting with arguments
    - Timestamp formatting (with timezone support)
    - Output format (plain text, JSON, colored terminal output)
    - Field arrangement and styling

    3.2 Built-in Presenters

    
        3.2.1 Text Presenter
                
                -- Creates: "2023-03-15 10:00:00 INFO [app.module] User john logged in"
                    local text_presenter = lual.presenters.text({ timezone = lual.utc })
                -- lua


        3.2.2 JSON Presenter
            
            -- Creates structured JSON output: 
                local json_presenter = lual.presenters.json({ 
                    pretty = true,
                    timezone = lual.local_time 
                })
            --- lua

        
        3.2.3 Color Presenter
                
                -- Creates colorized terminal output
                    local color_presenter = lual.presenters.color({
                        level_colors = {
                            ERROR = "red",
                            WARNING = "yellow"
                        }
                    })
                --- lua

    3.3 Log Record Structure
    
        Presenters receive log records with this structure:

                {
                    level_name = "INFO",           -- String level name
                    level_no = 20,                 -- Numeric level
                    logger_name = "app.module",    -- Logger name
                    message_fmt = "User %s logged in", -- Message format string
                    args = {"john"},               -- Format arguments
                    context = {...},               -- Optional context data
                    timestamp = 1678886400,        -- Unix timestamp
                    filename = "app.lua",          -- Source filename
                    lineno = 42,                   -- Source line number
                }
            
            --- lua

    3.4 Factory Pattern
        
        Like transformers, presenters use factories:

            local function custom_presenter_factory(config)
                config = config or {}
                
                local function presenter_func(record)
                    -- Format the record into a string
                    return string.format("[%s] %s: %s",
                        record.level_name,
                        record.logger_name,
                        record.message_fmt
                    )
                end
                
                local presenter_with_schema = {
                    schema = {
                        custom_option = { type = "string", required = false }
                    }
                }
                
                setmetatable(presenter_with_schema, {
                    __call = function(_, record)
                        return presenter_func(record)
                    end
                })
                
                return presenter_with_schema
            end
        
        --- lua

4. outputs: Output Delivery

    4.1 What They Do
        
        outputs are the final step - they take formatted messages from presenters and send them to output destinations. They're simpler than transformers/presenters and handle:

        - Writing to streams (stdout, stderr, files)
        - Network delivery (syslog)
        - Error handling for output failures
        - Buffering and flushing

    4.2 Built-in outputs

        4.2.1 Console output
            
            -- Writes to stdout by default
                local function console_output(record, config)
                    local stream = config.stream or io.stdout
                    stream:write(record.message)
                    stream:write("\n")
                    stream:flush()
                end
            
            --- lua

        4.2.2 File output
            
            -- Writes to rotating log files
                local file_disp = lual.outputs.file_output({ 
                    path = "/var/log/app.log" 
                })
            
            --- lua

        4.2.3 Syslog output
            
            -- Sends to system log
                local syslog_disp = lual.outputs.syslog_output({
                    facility = "local0",
                    hostname = "myserver"
                })
            
            --- lua

    4.3 Simple Function Pattern
        
        Unlike transformers/presenters, outputs are simpler functions:

            local function custom_output(record, config)
                config = config or {}
                
                -- Your output logic here
                local file = io.open(config.path, "a")
                if file then
                    file:write(record.message .. "\n")
                    file:close()
                else
                    io.stderr:write("Failed to open log file\n")
                end
            end
        
        --- lua

5. Configuration & Integration

    5.1 Single output Setup
        
            local logger = lual.logger({
                name = "app",
                level = lual.info,
                output = lual.console,    -- output constant
                presenter = lual.text,        -- Presenter constant
                timezone = lual.utc          -- Time constant
            })
        
        --- lua

    5.2 Multiple outputs with Full Configuration
        
            local logger = lual.logger({
                name = "app",
                level = lual.debug,
                outputs = {
                    {
                        type = lual.console,
                        presenter = lual.color,
                        timezone = lual.local_time,
                        transformers = {
                            { type = lual.noop }
                        }
                    },
                    {
                        type = lual.file,
                        path = "app.log",
                        presenter = lual.json,
                        timezone = lual.utc,
                        transformers = {
                            { type = lual.audit, include_source = true }
                        }
                    }
                }
            })
        
        --- lua

    5.3 Imperative API
        
            local logger = lual.logger("app")
            logger:add_output(
                lual.outputs.console_output(),
                lual.presenters.text({ timezone = lual.utc })
            )
        
        --- lua

6. Key Relationships

    6.1 Component Dependencies
        
        - Transformers are output-specific: Each output can have its own transformer chain
        - Presenters are output-specific: Each output uses exactly one presenter
        - Configuration flows down: Timezone and other settings can be configured at the output level
        - Error isolation: If a transformer fails, logging continues with the original record
        - Sequential processing: Transformers run in order, but outputs run independently

7. Best Practices

    7.1 Development Guidelines
        
        - Keep transformers simple: Each should do one thing well
        - Always copy records: Don't mutate the original in transformers
        - Handle missing fields: Check for field existence before using
        - Use appropriate presenters: JSON for structured logs, text for human reading, color for development
        - Configure timezone consistently: Especially important for multi-output setups
        - Test error conditions: Ensure components handle edge cases gracefully

    This architecture provides flexibility while maintaining clear separation of concerns - transformers handle data, presenters handle formatting, and outputs handle delivery.