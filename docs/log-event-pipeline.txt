lual Logging Components: Pipelines, Transformers, Presenters & Outputs

1.  Overview: The Log Record Flow

    In lual, when you call `logger:info("message")`, your log event flows through pipelines:

    ```
    Logger Emit → Log Record Creation → Pipeline Processing → Transformers → Presenter → Outputs → Destinations
    ```

    Each component has a specific role:
    - **Pipelines**: Define complete processing chains with level thresholds, transformers, presenters, and outputs
    - **Transformers**: Modify log record data (add/change fields)
    - **Presenters**: Format the record into a string (text, JSON, colors)
    - **Outputs**: Send the formatted string to destinations (console, file, syslog)

2. Pipelines: The Foundation

    2.1 What They Are

        Pipelines are the core configuration unit in lual. Each pipeline combines:
        - A level threshold (when to activate the pipeline)
        - One or more outputs (where to send the log)
        - A presenter (how to format the log)
        - Optional transformers (how to modify the log data)

        Pipelines replace the previous dispatcher/output system, providing cleaner separation of concerns.

    2.2 Configuration Structure

        lual.config({
            level = lual.DEBUG, -- Root level is DEBUG
            pipelines = {
                {
                    level = lual.DEBUG,  -- Pipeline processes DEBUG and above
                    outputs = {
                        lual.file
                    },
                    presenter = lual.json(),
                    transformers = {
                        lual.noop
                    }
                },
                {
                    level = lual.WARNING,  -- Pipeline processes WARNING and above
                    outputs = {
                        lual.console
                    },
                    presenter = lual.text()
                }
            }
        })

    2.3 Pipeline Processing

        When a log event occurs:
        1. Each pipeline checks its level threshold against the event level
        2. If the threshold is met, the pipeline processes the event through:
           - Transformers (sequentially, if any)
           - Presenter (formats the record)
           - Outputs (sends to all configured destinations)
        3. Each pipeline operates independently - one pipeline failure doesn't affect others

3. Transformers: Data Modification

    3.1 What They Do

        Transformers are functions that receive a log record and return a modified version. They sit at the beginning of pipeline processing, allowing you to:

        - Add metadata fields
        - Modify existing data
        - Enrich records with contextual information
        - Filter or transform field values

    3.2 Structure & Factory Pattern
        
        Transformers follow a factory pattern that returns callable tables with schemas:

            local function custom_transformer_factory(config)
                config = config or {}
                
                local function transformer_func(record)
                    -- Create a copy to avoid mutating the original
                    local transformed_record = {}
                    for k, v in pairs(record) do
                        transformed_record[k] = v
                    end
                    
                    -- Your modifications here
                    transformed_record.custom_field = "added_value"
                    
                    return transformed_record
                end
                
                local transformer_with_schema = {
                    schema = { /* config validation schema */ }
                }
                
                setmetatable(transformer_with_schema, {
                    __call = function(_, record)
                        return transformer_func(record)
                    end
                })
                
                return transformer_with_schema
            end

    3.3 Pipeline Configuration

            lual.config({
                pipelines = {
                    {
                        level = lual.DEBUG,
                        outputs = { lual.console },
                        presenter = lual.text(),
                        transformers = {
                            lual.noop,
                            { func = custom_transformer_factory, config = { prefix = "[APP] " } }
                        }
                    }
                }
            })

        Transformers are applied sequentially - each transformer receives the output of the previous one.

4.  Presenters: Data Formatting

    4.1  What They Do
    
        Presenters convert log records into formatted strings ready for output. They handle:

        - Message formatting with arguments
        - Timestamp formatting (with timezone support)
        - Output format (plain text, JSON, colored terminal output)
        - Field arrangement and styling

    4.2 Built-in Presenters

        4.2.1 Text Presenter
                
                -- Creates: "2023-03-15 10:00:00 INFO [app.module] User john logged in"
                local text_presenter = lual.text({ timezone = lual.utc })

        4.2.2 JSON Presenter
            
            -- Creates structured JSON output: 
                local json_presenter = lual.json({ 
                    pretty = true,
                    timezone = lual.local_time 
                })

        4.2.3 Color Presenter
                
                -- Creates colorized terminal output
                local color_presenter = lual.color({
                    level_colors = {
                        ERROR = "red",
                        WARNING = "yellow"
                    }
                })

    4.3 Log Record Structure
    
        Presenters receive log records with this structure:

                {
                    level_name = "INFO",           -- String level name
                    level_no = 20,                 -- Numeric level
                    logger_name = "app.module",    -- Logger name
                    message_fmt = "User %s logged in", -- Message format string
                    args = {"john"},               -- Format arguments
                    context = {...},               -- Optional context data
                    timestamp = 1678886400,        -- Unix timestamp
                    filename = "app.lua",          -- Source filename
                    lineno = 42,                   -- Source line number
                }

    4.4 Factory Pattern
        
        Like transformers, presenters use factories:

            local function custom_presenter_factory(config)
                config = config or {}
                
                local function presenter_func(record)
                    -- Format the record into a string
                    return string.format("[%s] %s: %s",
                        record.level_name,
                        record.logger_name,
                        record.message_fmt
                    )
                end
                
                local presenter_with_schema = {
                    schema = {
                        custom_option = { type = "string", required = false }
                    }
                }
                
                setmetatable(presenter_with_schema, {
                    __call = function(_, record)
                        return presenter_func(record)
                    end
                })
                
                return presenter_with_schema
            end

5. Outputs: Destination Delivery

    5.1 What They Do
        
        Outputs are the final step in pipelines - they take formatted messages from presenters and send them to destinations. They handle:

        - Writing to streams (stdout, stderr, files)
        - Network delivery (syslog)
        - Error handling for output failures
        - Buffering and flushing

    5.2 Built-in Outputs

        5.2.1 Console Output
            
            -- Writes to stdout by default
                local function console_output(record, config)
                    local stream = config.stream or io.stdout
                    stream:write(record.message)
                    stream:write("\n")
                    stream:flush()
                end

        5.2.2 File Output
            
            -- Writes to rotating log files
                local file_output = lual.file({ 
                    path = "/var/log/app.log" 
                })

        5.2.3 Syslog Output
            
            -- Sends to system log
                local syslog_output = lual.outputs.syslog_output({
                    facility = "local0",
                    hostname = "myserver"
                })

    5.3 Simple Function Pattern
        
        Unlike transformers/presenters, outputs are simpler functions:

            local function custom_output(record, config)
                config = config or {}
                
                -- Your output logic here
                local file = io.open(config.path, "a")
                if file then
                    file:write(record.message .. "\n")
                    file:close()
                else
                    io.stderr:write("Failed to open log file\n")
                end
            end

6. Configuration & Integration

    6.1 Root Logger Configuration
        
            lual.config({
                level = lual.info,
                pipelines = {
                    {
                        outputs = { lual.console },
                        presenter = lual.text()
                    }
                }
            })

    6.2 Logger-Specific Pipelines
        
            local logger = lual.logger("app", {
                level = lual.debug,
                pipelines = {
                    {
                        level = lual.debug,
                        outputs = { lual.console },
                        presenter = lual.color(),
                        transformers = { lual.noop }
                    },
                    {
                        level = lual.info,
                        outputs = { lual.file },
                        presenter = lual.json(),
                        transformers = {
                            { func = audit_transformer, config = { include_source = true } }
                        }
                    }
                }
            })

    6.3 Imperative API
        
            local logger = lual.logger("app")
            logger:add_pipeline({
                outputs = { lual.console },
                presenter = lual.text({ timezone = lual.utc })
            })

7. Key Relationships

    7.1 Component Dependencies
        
        - Pipelines are independent: Each pipeline processes events separately
        - Components are pipeline-specific: Each pipeline has its own transformer chain, presenter, and outputs
        - Level checking is dual: Logger level and pipeline level both matter
        - Error isolation: If a component fails, the pipeline continues with original record or stops gracefully
        - Sequential transformers: Transformers run in order within a pipeline

8. Best Practices

    8.1 Development Guidelines
        
        - Design specific pipelines: Create pipelines for different purposes (debug to console, errors to file)
        - Keep transformers simple: Each should do one thing well
        - Always copy records: Don't mutate the original in transformers
        - Handle missing fields: Check for field existence before using
        - Use appropriate presenters: JSON for structured logs, text for human reading, color for development
        - Configure levels thoughtfully: Use pipeline levels for granular control
        - Test error conditions: Ensure components handle edge cases gracefully

    This pipeline architecture provides flexibility while maintaining clear separation of concerns - pipelines organize processing, transformers handle data modification, presenters handle formatting, and outputs handle delivery.