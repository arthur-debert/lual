API 

This document overseas the construction of the final api. 

Status




Preparation: 
    - [x] rename : remove lual.output.file_output (should just become file) for
        outputs and formatters too
    - [x] remove the facades, .add_output should not receive names or levels
Implementation: 
    - [ ] Phase I alter the current implementation to generate a dict and use that, both on
        new loggers and in updates to existing loggers with the the add* , set*
        functions
    - [ ] Phase II add support for the declarative api, creating a logger from a table with
        out config format (just add checking / validation)
    - [ ] Phase III add support for the smart api 

1. Imperative: 

    a series of functional calls to the logger object, each setting part of the config. 

        -- example

            local lual = require("lual")
            local logger = lualog.get_logger("app.database")
            logger:set_level("debug")

            logger:add_output(
                lualog.outputs.console,
                lualog.formatters.plain,
                { stream = io.stdout }  -- optional config
            )
            
            -- Add file output
            local file_output = require("lual.outputs.file")
            logger:add_output(
                file_output({ path = "app.log" }),
                lualog.formatters.plain
            )
            
            -- Add colored console output
            logger:add_output(
                lualog.outputs.console,
                lualog.formatters.color,
                { stream = io.stderr }
            )


2. Declarative:  - FUTURE REALEASE

    A single call to the logger object, with a config table. 

            -- example: 

                local  logger = require("lualog").logger({
                    name = "app.database",
                     level = "debug",
                    outputs = {
                        {type = "console", formatter = "color"},
                        {type = "file", path = "app.log", formatter = "plain"}
                    }
                })

            -- lua

3. Smart Api:  FUTURE RELEASE


    -- the initial get logger can customize the logger.
        It also offers a flexible and terse api for setting these up: 

        local lualog = require("lualog")
        # this  is a simple case, where there is a 101 releatioship between outputs and formatters, and only one output
        local logger = lualog.logger({output: "stream", level:"debug", formatter: "color"})
        # for a more complex case, one could do 
        local logger = lualog.logger({
            name = "app.db",
            level = "debug",
            outputs = {
                {type = "console", formatter = "color"},
                {type = "file", path = "app.log", formatter = "plain"}
            }
        })

    -- lua

API SUGGESTIONS:



IMPLEMENTATION DESIGN:

Single Config Table Architecture:

All loggers are internally created from a canonical config table. This provides:
- Single source of truth for logger configuration
- Consistency between imperative and declarative APIs  
- Easier testing and maintenance

Core approach:
1. Define canonical config schema
2. All logger creation goes through create_logger_from_config(config)
3. Imperative methods become config transformations:
   - Get current config -> clone -> modify -> recreate logger
4. Declarative APIs normalize input to canonical config
5. Performance cost negligible (config changes are rare)

Benefits:
- No configuration logic duplication
- New config options work across all APIs automatically
- Immutable config state (safer, more predictable)
- Clean separation of concerns