SCHEMA VALIDATION SYSTEM

The schema validation system provides declarative validation for lual 
configurations. Instead of manual validation code, schemas define rules 
that are automatically enforced.

    -- Note:
        This replaces the old manual validation functions but maintains
        backward compatibility. All existing code continues to work.
    --

The system validates three types of configurations:
1. Declarative configs (standard format with dispatchers array)
2. Shortcut configs (simplified single-dispatcher format)  
3. dispatcher configs (individual dispatcher definitions)

Validation returns a result table with two keys:
- `data`: The validated configuration data
- `_errors`: Error messages for invalid fields (empty if valid)


BASIC USAGE

    local schema = require("lual.schema")
    
    -- Validate a configuration
    local config = { name = "app", level = "info" }
    local result = schema.validate_config(config)
    
    if next(result._errors) then
        -- Handle validation errors
        for field, error_msg in pairs(result._errors) do
            print("Error:", field, error_msg)
        end
    else
        -- Use validated data
        local validated_config = result.data
    end
    -- lua


VALIDATION FUNCTIONS

    schema.validate_config(data)    -- Declarative config validation
    schema.validate_dispatcher(data)    -- Single dispatcher validation  
    schema.validate_shortcut(data)  -- Shortcut config validation
    -- lua

Each function returns the same result format with `data` and `_errors` keys.


TESTING WITH SCHEMAS

Tests should check the `_errors` table structure instead of hardcoded 
error messages:

    -- Old approach (brittle):
    assert.matches("Invalid level", error_message)
    
    -- New approach (robust):
    assert.is_not_nil(result._errors.level)
    assert.matches("Invalid level", result._errors.level)
    
    -- Even better - check error structure:
    assert.is_true(next(result._errors) == nil)  -- No errors
    assert.are.equal(2, count_keys(result._errors))  -- Specific count
    -- lua

For expected error messages, use the schema helper:

    local config_schema = require("lual.schema.config_schema")
    local expected = config_schema.generate_expected_error(
        "ConfigSchema", "name", "type"
    )
    assert.are.equal(expected, result._errors.name)
    -- lua


SCHEMA DEFINITIONS

Schemas are defined as tables with field validation rules:

    field_name = {
        type = "string",           -- Expected type(s)
        required = true,           -- Whether field is required
        values = {...},            -- Valid enum values (optional)
        conditional = {...},       -- Conditional requirements (optional)
        multiple = false,          -- Whether this is an array field
        schema = "NestedSchema"    -- Reference to nested schema (optional)
    }
    -- lua

Available schemas:
- `ConfigSchema`: Main configuration validation
- `dispatcherschema`: dispatcher configuration validation  
- `ShortcutSchema`: Shortcut configuration validation


VALIDATION FEATURES

Type validation: Checks field types (string, number, boolean, table, userdata)
Enum validation: Validates against predefined values (case-insensitive)
Required fields: Marks fields as mandatory or optional
Conditional validation: Fields required based on other field values
Nested validation: Validates arrays and nested objects
Unknown fields: Rejects unrecognized configuration keys

The system automatically handles:
- Case-insensitive enum matching ("INFO" matches "info")
- Type coercion validation (level can be string or number)
- Conditional requirements (path required when type="file")
- Nested error reporting (dispatchers[1].presenter errors)


INTERNALS

The validation system uses three main components:

1. **Schema Definitions** (`config_schema.lua`): Declarative field rules
   extracted from constants with metadata for validation logic

2. **Validator Engine** (`validator.lua`): Core validation logic that 
   processes schemas and generates structured error reports

3. **Schema Registry** (`init.lua`): Central registry that manages schemas
   and provides validation functions for different config types

Error messages are context-aware, generating specific messages for different
field types and validation contexts. The system maintains compatibility with
existing validation functions by converting schema validation results to the
expected error format.

Schema validation integrates with the configuration processing pipeline,
replacing manual validation in transformation and validation modules while
preserving all existing behavior and error message formats.
