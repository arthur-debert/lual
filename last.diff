diff --git a/.github/workflows/README.txt b/.github/workflows/README.txt
index da94727..5c5a9d7 100644
--- a/.github/workflows/README.txt
+++ b/.github/workflows/README.txt
@@ -57,7 +57,7 @@
    - Cache compression happens automatically
 
 5. Validate cache effectiveness
-   - Check cache-hit output: `${{ steps.cache-step-id.outputs.cache-hit }}`
+   - Check cache-hit dispatcher: `${{ steps.cache-step-id.dispatchers.cache-hit }}`
    - Monitor workflow execution time with and without cache
 
 2. Common Pitfalls
@@ -72,7 +72,7 @@
 
 3. Not handling cache misses
    - Always implement proper workflow logic for when cache misses occur
-   - Example: `if: steps.cache-step.outputs.cache-hit != 'true'`
+   - Example: `if: steps.cache-step.dispatchers.cache-hit != 'true'`
 
 4. Overly-specific cache keys
    - If keys are too specific, you'll rarely get cache hits
diff --git a/.github/workflows/tests.yml b/.github/workflows/tests.yml
index 64021f8..0c8153c 100644
--- a/.github/workflows/tests.yml
+++ b/.github/workflows/tests.yml
@@ -47,7 +47,7 @@ jobs:
         run: |
           pwd ; ls -lah
       - name: Install Lua dependencies
-        if: steps.cache-lua-deps.outputs.cache-hit != 'true'
+        if: steps.cache-lua-deps.dispatchers.cache-hit != 'true'
         run: |
           luarocks install --local --only-deps lual-0.1.0-1.rockspec
       # on maocs, bustes comes with luarocks, but not on ubuntu:
diff --git a/README.md b/README.md
index ff15756..609ce06 100644
--- a/README.md
+++ b/README.md
@@ -20,7 +20,7 @@ logger:set_level("debug")
 
 -- Configure a more involved logger with UTC timestamps:
 local logger = lual.logger({
-    output = lual.lib.console,
+    dispatcher = lual.lib.console,
     level = lual.levels.DEBUG,
     formatter = lual.lib.color,
     timezone = "utc"
@@ -30,14 +30,14 @@ local bigLogging = require("lual").logger({
     name = "app.database",
     level = "debug",
     timezone = "utc",
-    outputs = {
+    dispatchers = {
         {type = "console", formatter = "color"},
         {type = "file", path = "app.log", formatter = "text"}
     }
 })
 
--- Of course you can imperatively add outputs and formatters:
-logger:add_output(lual.lib.console, lual.lib.text)
+-- Of course you can imperatively add dispatchers and formatters:
+logger:add_dispatcher(lual.lib.console, lual.lib.text)
 
 -- Supports structured logging:
 logger:info({destination = "home"}, "Time to leave") -- Context table first
@@ -49,9 +49,9 @@ logger:info({user_id = 123, action = "update"}, "User %s performed action: %s",
 
 ## Built-in Components
 
-It has a small but useful set of outputs and formatters:
+It has a small but useful set of dispatchers and formatters:
 
-**Outputs:**
+**dispatchers:**
 
 - `console`: prints to the console
 - `file`: writes to a file
@@ -62,7 +62,7 @@ It has a small but useful set of outputs and formatters:
 - `color`: terminal colored
 - `json`: as JSON
 
-But formatters and outputs are just functions, pass your own.
+But formatters and dispatchers are just functions, pass your own.
 
 Names can be either introspected or set manually. There is hierarchical logging
 with propagation, see docs/propagation.txt.
@@ -90,7 +90,7 @@ local logger = lual.logger("myapp")    -- Named logger
 local logger = lual.logger({
     name = "app.database",
     level = "debug",
-    outputs = {
+    dispatchers = {
         {type = "console", formatter = "color"},
         {type = "file", path = "app.log", formatter = "text"}
     }
@@ -106,10 +106,10 @@ local logger = lual.logger({
   `myapp.module.submodule`), allowing for targeted configuration.
 - **Log Levels:** Standard severity levels: `DEBUG`, `INFO`, `WARNING`, `ERROR`,
   `CRITICAL`, plus `NONE` to disable logging for a logger.
-- **Console Output:** `lualog.lib.console` writes log messages to `io.stdout`
-  (default), `io.stderr`, or any custom stream object that provides `write()`
-  and `flush()` methods.
-- **File Output:** `lualog.lib.file` writes log messages to files with
+- **Console dispatcher:** `lualog.lib.console` writes log messages to
+  `io.stdout` (default), `io.stderr`, or any custom stream object that provides
+  `write()` and `flush()` methods.
+- **File dispatcher:** `lualog.lib.file` writes log messages to files with
   configurable paths and rotation options.
 - **Text Formatter:** `lualog.lib.text` formats messages by default as:
   `YYYY-MM-DD HH:MM:S LEVEL [LoggerName] Message`.
@@ -125,37 +125,38 @@ local logger = lual.logger({
     - Pure structured: `logger:info({event = "UserLogin", userId = 123})`
     - Mixed: `logger:info({eventId = "XYZ"}, "Processing event: %s", eventName)`
       (context table first)
-  - **Per-Logger Configuration:** Log levels and outputs (with their formatters)
-    can be configured for each logger instance using methods like `:set_level()`
-    and `:add_output()`.
+  - **Per-Logger Configuration:** Log levels and dispatchers (with their
+    formatters) can be configured for each logger instance using methods like
+    `:set_level()` and `:add_dispatcher()`.
 - **Message Propagation:** Log messages processed by a logger are passed to its
-  parent's outputs by default. Propagation can be disabled per logger
+  parent's dispatchers by default. Propagation can be disabled per logger
   (`logger.propagate = false`).
 - **Contextual Information:** Log records automatically include a UTC timestamp,
   logger name, and the source filename/line number where the log message was
   emitted.
-- **Error Handling:** Errors within outputs or formatters are caught and
+- **Error Handling:** Errors within dispatchers or formatters are caught and
   reported to `io.stderr`, preventing the logging system from crashing the
   application.
 - **Default Setup:** On require, a root logger is configured with:
   - Level: `lualog.levels.INFO`.
-  - One output: `lualog.lib.console` writing to `io.stdout`.
-  - Formatter for this output: `lualog.lib.text`.
+  - One dispatcher: `lualog.lib.console` writing to `io.stdout`.
+  - Formatter for this dispatcher: `lualog.lib.text`.
 
-You can create custom outputs and formatters:
+You can create custom dispatchers and formatters:
 
-- **Custom Output:** A function with the signature `my_output(record, config)`
+- **Custom dispatcher:** A function with the signature
+  `my_dispatcher(record, config)`
   - `record`: A table containing the log details. Key fields include:
     - `message`: The fully formatted log message string (from the formatter).
     - `level_name`, `level_no`: Severity level.
-    - `logger_name`: Name of the logger that owns the output processing the
+    - `logger_name`: Name of the logger that owns the dispatcher processing the
       record.
     - `timestamp`, `filename`, `lineno`, `source_logger_name` (original
       emitter).
     - `raw_message_fmt`, `raw_args`: Original format string and variadic
       arguments.
     - `context`: The context table, if provided in the log call.
-  - `config`: The `output_config` table passed when adding the output.
+  - `config`: The `dispatcher_config` table passed when adding the dispatcher.
 - **Custom Formatter:** A function with the signature `my_formatter(record)`
   - `record`: A table with raw log details. Key fields include:
     - `message_fmt`: The raw message format string (e.g., "User %s logged in").
diff --git a/bin/gh-workflow-latest-id b/bin/gh-workflow-latest-id
index 13e7a65..7714c23 100755
--- a/bin/gh-workflow-latest-id
+++ b/bin/gh-workflow-latest-id
@@ -14,14 +14,14 @@
 set -e
 
 # Check if gh command is available
-if ! command -v gh &> /dev/null; then
+if ! command -v gh &>/dev/null; then
     echo "Error: GitHub CLI (gh) is not installed or not in PATH" >&2
     echo "Please install it from https://cli.github.com/" >&2
     exit 1
 fi
 
 # Check if jq command is available
-if ! command -v jq &> /dev/null; then
+if ! command -v jq &>/dev/null; then
     echo "Error: jq is not installed or not in PATH" >&2
     echo "Please install it using your package manager" >&2
     exit 1
@@ -37,7 +37,7 @@ if [ $? -ne 0 ] || [ -z "$result" ]; then
     exit 1
 fi
 
-# Extract and output just the ID
+# Extract and dispatcher just the ID
 workflow_id=$(echo "$result" | jq -r '.[0].databaseId // empty')
 
 if [ -z "$workflow_id" ]; then
@@ -46,4 +46,3 @@ if [ -z "$workflow_id" ]; then
 fi
 
 echo "$workflow_id"
-
diff --git a/bin/publish.sh b/bin/publish.sh
index 39f084e..bf29aa0 100755
--- a/bin/publish.sh
+++ b/bin/publish.sh
@@ -9,14 +9,14 @@ SCRIPT_DIR=$(dirname "$(readlink -f "$0")")
 PROJECT_ROOT="$SCRIPT_DIR/.."
 cd "$PROJECT_ROOT"
 
-# Colors for output
+# Colors for dispatcher
 RED='\033[0;31m'
 GREEN='\033[0;32m'
 YELLOW='\033[1;33m'
 BLUE='\033[0;34m'
 NC='\033[0m' # No Color
 
-# Function to print colored output
+# Function to print colored dispatcher
 print_status() {
     echo -e "${BLUE}[INFO]${NC} $1"
 }
diff --git a/bin/release.sh b/bin/release.sh
index e00de3d..80c99f2 100755
--- a/bin/release.sh
+++ b/bin/release.sh
@@ -9,14 +9,14 @@ SCRIPT_DIR=$(dirname "$(readlink -f "$0")")
 PROJECT_ROOT="$SCRIPT_DIR/.."
 cd "$PROJECT_ROOT"
 
-# Colors for output
+# Colors for dispatcher
 RED='\033[0;31m'
 GREEN='\033[0;32m'
 YELLOW='\033[1;33m'
 BLUE='\033[0;34m'
 NC='\033[0m' # No Color
 
-# Function to print colored output
+# Function to print colored dispatcher
 print_status() {
     echo -e "${BLUE}[INFO]${NC} $1"
 }
diff --git a/docs/api.txt b/docs/api.txt
index 1877d7f..0ec7a74 100644
--- a/docs/api.txt
+++ b/docs/api.txt
@@ -11,20 +11,20 @@ lual gives various ways to construct your logger:
             local logger = lualog.logger("app.database")
             logger:set_level("debug")
 
-            logger:add_output(
+            logger:add_dispatcher(
                 lualog.lib.console,
                 lualog.lib.text,
                 { stream = io.stdout }  -- optional config
             )
             
-            -- Add file output
-            logger:add_output(
+            -- Add file dispatcher
+            logger:add_dispatcher(
                 lualog.lib.file({ path = "app.log" }),
                 lualog.lib.text
             )
             
-            -- Add colored console output
-            logger:add_output(
+            -- Add colored console dispatcher
+            logger:add_dispatcher(
                 lualog.lib.console,
                 lualog.lib.color,
                 { stream = io.stderr }
@@ -40,7 +40,7 @@ lual gives various ways to construct your logger:
                 local  logger = require("lualog").logger({
                     name = "app.database",
                      level = "debug",
-                    outputs = {
+                    dispatchers = {
                         {type = "console", formatter = "color"},
                         {type = "file", path = "app.log", formatter = "text"}
                     }
@@ -50,18 +50,18 @@ lual gives various ways to construct your logger:
 
 3. Shortcut Declarative
 
-For the very common case where where there is one output and one formatter, we can allow this other form of the declarative api:
+For the very common case where where there is one dispatcher and one formatter, we can allow this other form of the declarative api:
 
     -- the initial get logger can customize the logger.
 
         local lualog = require("lualog")
-        # this  is a simple case, where there is a 101 releatioship between outputs and formatters, and only one output
-        local logger = lualog.logger({output: "console", level:"debug", formatter: "color"})
+        # this  is a simple case, where there is a 101 releatioship between dispatchers and formatters, and only one dispatcher
+        local logger = lualog.logger({dispatcher: "console", level:"debug", formatter: "color"})
     -- lua
 
 In this case, the code should verify if the table has such format. The general form is : 
- .   * as long as output and format are either a single item or a table of one item 
-     * we transform to the general form (the formatter is part of the output, which is a table)
+ .   * as long as dispatcher and format are either a single item or a table of one item 
+     * we transform to the general form (the formatter is part of the dispatcher, which is a table)
 So we do a to_canonical_config transformation, then run the regular validation and api.
 
 
@@ -105,5 +105,5 @@ After the work on the single config table architecture, we can add a declarative
 
    - Wrong values/types: 
        levels must be from a predefined set of values
-       outputers, formatters must be functions, names must be strings, propagate must be a boolean. 
-       it would be great to validate that output and formatters have the right signature, but that is a bit more complex, so we can let errors blow up at runtime.
\ No newline at end of file
+       dispatcherers, formatters must be functions, names must be strings, propagate must be a boolean. 
+       it would be great to validate that dispatcher and formatters have the right signature, but that is a bit more complex, so we can let errors blow up at runtime.
\ No newline at end of file
diff --git a/docs/file-output.txt b/docs/file-output.txt
index d33e3fa..2a19fc2 100644
--- a/docs/file-output.txt
+++ b/docs/file-output.txt
@@ -1,6 +1,6 @@
-FILE OUTPUT: ROTATING LOG FILES
+FILE dispatcher: ROTATING LOG FILES
 
-The file output handler writes log messages to files with automatic rotation
+The file dispatcher handler writes log messages to files with automatic rotation
 on startup. This prevents log files from growing indefinitely. This is not a 
 robust rotation solution, though. 
 
@@ -9,7 +9,7 @@ robust rotation solution, though.
         logrotate.
     --
 
-When initialized, the file output:
+When initialized, the file dispatcher:
 1. Rotates existing log files, keeping up to 5 backups
    - app.log → app.log.1, app.log.1 → app.log.2, ..., app.log.4 → app.log.5
    - app.log.5 is deleted if it exists
@@ -22,10 +22,10 @@ single-threaded Lua applications and providing session-specific logs.
 BASIC USAGE
 
     local lual = require("lual")
-    local file_output = require("lual.outputs.file_output")
+    local file_dispatcher = require("lual.dispatchers.file_dispatcher")
 
     local logger = lual.logger("app")
-    logger:add_output(file_output({ path = "app.log" }))
+    logger:add_dispatcher(file_dispatcher({ path = "app.log" }))
     
     logger:info("Application started")  -- Written to fresh app.log
     -- lua
@@ -33,9 +33,9 @@ BASIC USAGE
 
 CONFIGURATION
 
-The file output factory accepts a single configuration parameter:
+The file dispatcher factory accepts a single configuration parameter:
 
-    file_output({ path = "path/to/logfile.log" })
+    file_dispatcher({ path = "path/to/logfile.log" })
 
 - `path` (string, required): Path to the main log file
 
@@ -43,13 +43,13 @@ The file output factory accepts a single configuration parameter:
 EXAMPLE: APPLICATION LOGGING WITH ROTATION
 
     local lual = require("lual")
-    local file_output = require("lual.outputs.file_output")
+    local file_dispatcher = require("lual.dispatchers.file_dispatcher")
 
-    -- Set up logger with file output
+    -- Set up logger with file dispatcher
     local app_logger = lual.logger("myapp")
     app_logger:set_level(lual.levels.INFO)
-    app_logger:add_output(
-        file_output({ path = "/var/log/myapp.log" }),
+    app_logger:add_dispatcher(
+        file_dispatcher({ path = "/var/log/myapp.log" }),
         lual.formatters.text
     )
 
@@ -67,7 +67,7 @@ After several application restarts, you'll have:
 
 INTERNALS
 
-The file output implementation uses a three-phase approach for safe rotation:
+The file dispatcher implementation uses a three-phase approach for safe rotation:
 
 1. **Command Generation**: Creates a list of file operations (remove/rename)
    without executing them, allowing validation and testing
diff --git a/docs/intro.txt b/docs/intro.txt
index 7a7b041..0ace5eb 100644
--- a/docs/intro.txt
+++ b/docs/intro.txt
@@ -17,20 +17,20 @@ design is done over functions and tables, look ma, no classes.
 
         # configure a more involved logger:
         local logger = lualog.logger({
-            output: lual.lib.console
+            dispatcher: lual.lib.console
             level:lual.levels.DEBUG
             formatter: lual.lib.color
         })
         local  bigLogging = require("lualog").logger({
             name = "app.database",
              level = "debug",
-            outputs = {
+            dispatchers = {
                 {type = "console", formatter = "color"},
                 {type = "file", path = "app.log", formatter = "text"}
             }
         })
-        # of course you can imperatively add outputs and formatters:
-        logger:add_output(lual.lib.console, lual.lib.text)
+        # of course you can imperatively add dispatchers and formatters:
+        logger:add_dispatcher(lual.lib.console, lual.lib.text)
 
         # supports structured logging:
         logger:info("Time to leave", {destination="home"}
@@ -40,15 +40,15 @@ design is done over functions and tables, look ma, no classes.
         
     -- lua
 
-It has a small but useful set of outputs and formatters:
-    outputs:
+It has a small but useful set of dispatchers and formatters:
+    dispatchers:
         console: prints to the console
         file: writes to a file
     formatters:
         text: plain text
         color: terminal colored 
         json: as json
-But formatters and outputs are just functions, pass your own.
+But formatters and dispatchers are just functions, pass your own.
 
 Names can be either introspected or set manually. There is hierarchical logging, with propagation, see docs/propagation.txt . 
 
diff --git a/docs/propagation.txt b/docs/propagation.txt
index 4fd34ff..fb4f353 100644
--- a/docs/propagation.txt
+++ b/docs/propagation.txt
@@ -11,7 +11,7 @@ lual automatically creates the entire hierarchy:
 - "app.database" (child of app)
 - "app.database.connection" (child of app.database)
 
-Each logger in the hierarchy can have its own level and outputs, but messages
+Each logger in the hierarchy can have its own level and dispatchers, but messages
 propagate upward by default, allowing centralized handling.
 
 
@@ -84,27 +84,27 @@ Each logger inherits behavior from its parents but can override settings.
 PROPAGATION: HOW MESSAGES FLOW UPWARD
 
 By default, log messages propagate up the hierarchy. When a child logger
-processes a message, it also sends the message to its parent's outputs,
+processes a message, it also sends the message to its parent's dispatchers,
 and so on up to the root.
 
     local lual = require("lual")
-    local file_output = require("lual.outputs.file_output")
+    local file_dispatcher = require("lual.dispatchers.file_dispatcher")
     
     -- Root logger writes everything to console (default)
     
     -- App logger also writes to a file
     local app_logger = lual.logger("app")
-    app_logger:add_output(
+    app_logger:add_dispatcher(
         lualog.lib.file({ path = "app.log" }),
         lualog.lib.text
     )
     
-    -- Database logger has no outputs of its own
+    -- Database logger has no dispatchers of its own
     local db_logger = lual.logger("app.database")
     
     -- This message will be written to:
-    -- 1. app.log (via app_logger's file output)
-    -- 2. console (via root logger's console output)
+    -- 1. app.log (via app_logger's file dispatcher)
+    -- 2. console (via root logger's console dispatcher)
     db_logger:info("Database connection established")
     -- lua
 
@@ -116,7 +116,7 @@ You can disable propagation to stop messages from flowing upward:
     local lual = require("lual")
     
     local sensitive_logger = lual.logger("app.security.audit")
-    sensitive_logger:add_output(
+    sensitive_logger:add_dispatcher(
         lualog.lib.file({ path = "audit.log" }),
         lualog.lib.text
     )
@@ -158,20 +158,20 @@ EXAMPLE: WEB APPLICATION HIERARCHY
 
     local lual = require("lual")
     
-    -- Root: console output for all messages
+    -- Root: console dispatcher for all messages
     local root = lual.logger("root")  -- Explicit root
     root:set_level(lual.levels.INFO)
     
     -- App-wide file logging
     local app = lual.logger("webapp")
-    app:add_output(
+    app:add_dispatcher(
         lualog.lib.file({ path = "webapp.log" }),
         lualog.lib.text
     )
     
     -- HTTP requests: separate file, info level
     local http = lual.logger("webapp.http")
-    http:add_output(
+    http:add_dispatcher(
         lualog.lib.file({ path = "requests.log" }),
         lualog.lib.text
     )
@@ -182,7 +182,7 @@ EXAMPLE: WEB APPLICATION HIERARCHY
     
     -- Security: separate file, no propagation
     local security = lual.logger("webapp.security")
-    security:add_output(
+    security:add_dispatcher(
         lualog.lib.file({ path = "security.log" }),
         lualog.lib.text
     )
@@ -237,9 +237,9 @@ For automatic naming, lual uses `debug.getinfo()` to inspect the call stack:
 3. **Converts the filename** using the dot notation rules
 4. **Falls back to "root"** if conversion fails or returns empty
 
-The `get_effective_outputs()` method walks up the hierarchy, collecting outputs
+The `get_effective_dispatchers()` method walks up the hierarchy, collecting dispatchers
 from each logger where `propagate` is true. Each logger applies its own level
-filter before processing outputs.
+filter before processing dispatchers.
 
 Propagation stops when:
 - A logger has `propagate = false`
diff --git a/docs/schemas.txt b/docs/schemas.txt
index 6195bca..0b94a86 100644
--- a/docs/schemas.txt
+++ b/docs/schemas.txt
@@ -10,9 +10,9 @@ that are automatically enforced.
     --
 
 The system validates three types of configurations:
-1. Declarative configs (standard format with outputs array)
-2. Shortcut configs (simplified single-output format)  
-3. Output configs (individual output definitions)
+1. Declarative configs (standard format with dispatchers array)
+2. Shortcut configs (simplified single-dispatcher format)  
+3. dispatcher configs (individual dispatcher definitions)
 
 Validation returns a result table with two keys:
 - `data`: The validated configuration data
@@ -42,7 +42,7 @@ BASIC USAGE
 VALIDATION FUNCTIONS
 
     schema.validate_config(data)    -- Declarative config validation
-    schema.validate_output(data)    -- Single output validation  
+    schema.validate_dispatcher(data)    -- Single dispatcher validation  
     schema.validate_shortcut(data)  -- Shortcut config validation
     -- lua
 
@@ -92,7 +92,7 @@ Schemas are defined as tables with field validation rules:
 
 Available schemas:
 - `ConfigSchema`: Main configuration validation
-- `OutputSchema`: Output configuration validation  
+- `dispatcherschema`: dispatcher configuration validation  
 - `ShortcutSchema`: Shortcut configuration validation
 
 
@@ -109,7 +109,7 @@ The system automatically handles:
 - Case-insensitive enum matching ("INFO" matches "info")
 - Type coercion validation (level can be string or number)
 - Conditional requirements (path required when type="file")
-- Nested error reporting (outputs[1].formatter errors)
+- Nested error reporting (dispatchers[1].formatter errors)
 
 
 INTERNALS
diff --git a/lua/lual/config.lua b/lua/lual/config.lua
new file mode 100644
index 0000000..79db1dc
--- /dev/null
+++ b/lua/lual/config.lua
@@ -0,0 +1,636 @@
+local core_levels = require("lual.core.levels")
+local constants = require("lual.config.constants")
+
+local M = {}
+
+-- =============================================================================
+-- CANONICAL CONFIG SCHEMA
+-- =============================================================================
+
+--- Creates a canonical config table with default values
+-- @param config (table, optional) Initial config values
+-- @return table The canonical config
+local function create_canonical_config(config)
+    config = config or {}
+
+    return {
+        name = config.name or "root",
+        level = config.level or core_levels.definition.INFO,
+        dispatchers = config.dispatchers or {},
+        propagate = config.propagate ~= false, -- Default to true unless explicitly false
+        parent = config.parent or nil,
+        timezone = config.timezone or "local"  -- Default to local time
+    }
+end
+
+--- Deep clones a config table
+-- @param config (table) The config to clone
+-- @return table The cloned config
+local function clone_config(config)
+    local cloned = {}
+    for k, v in pairs(config) do
+        if type(v) == "table" and k == "dispatchers" then
+            -- Deep clone dispatchers array
+            cloned[k] = {}
+            for i, dispatcher in ipairs(v) do
+                cloned[k][i] = {
+                    dispatcher_func = dispatcher.dispatcher_func,
+                    formatter_func = dispatcher.formatter_func,
+                    dispatcher_config = dispatcher.dispatcher_config or {}
+                }
+            end
+        else
+            cloned[k] = v
+        end
+    end
+    return cloned
+end
+
+--- Merges user config with default config, with user config taking precedence
+-- @param user_config (table) The user's partial config
+-- @param default_config (table) The default config
+-- @return table The merged config
+local function merge_configs(user_config, default_config)
+    local merged = {}
+
+    -- Start with default config
+    for k, v in pairs(default_config) do
+        merged[k] = v
+    end
+
+    -- Override with user config
+    for k, v in pairs(user_config) do
+        merged[k] = v
+    end
+
+    return merged
+end
+
+-- =============================================================================
+-- VALIDATION FUNCTIONS
+-- =============================================================================
+
+--- Validates a level value (string or number)
+-- @param level The level to validate
+-- @return boolean, string True if valid, or false with error message
+local function validate_level(level)
+    if level == nil then
+        return true -- Level is optional
+    end
+
+    if type(level) == "string" then
+        local valid, err = constants.validate_against_constants(level, constants.VALID_LEVEL_STRINGS, true, "string")
+        if not valid then
+            return false, err
+        end
+    elseif type(level) == "number" then
+        -- Allow numeric levels
+    else
+        return false, "Level must be a string or number"
+    end
+
+    return true
+end
+
+--- Validates a timezone value
+-- @param timezone The timezone to validate
+-- @return boolean, string True if valid, or false with error message
+local function validate_timezone(timezone)
+    if timezone == nil then
+        return true -- Timezone is optional
+    end
+
+    local valid, err = constants.validate_against_constants(timezone, constants.VALID_TIMEZONES, true, "string")
+    if not valid then
+        return false, err
+    end
+
+    return true
+end
+
+--- Validates a canonical config table
+-- @param config (table) The config to validate
+-- @return boolean, string True if valid, or false with error message
+local function validate_canonical_config(config)
+    if type(config) ~= "table" then
+        return false, "Config must be a table"
+    end
+
+    if config.name and type(config.name) ~= "string" then
+        return false, "Config.name must be a string"
+    end
+
+    if config.level and type(config.level) ~= "number" then
+        return false, "Config.level must be a number"
+    end
+
+    if config.dispatchers and type(config.dispatchers) ~= "table" then
+        return false, "Config.dispatchers must be a table"
+    end
+
+    if config.propagate ~= nil and type(config.propagate) ~= "boolean" then
+        return false, "Config.propagate must be a boolean"
+    end
+
+    -- Validate timezone
+    local valid, err = validate_timezone(config.timezone)
+    if not valid then
+        return false, err
+    end
+
+    -- Validate dispatchers structure
+    if config.dispatchers then
+        for i, dispatcher in ipairs(config.dispatchers) do
+            if type(dispatcher) ~= "table" then
+                return false, "Each dispatcher must be a table"
+            end
+            if not dispatcher.dispatcher_func or type(dispatcher.dispatcher_func) ~= "function" then
+                return false, "Each dispatcher must have an dispatcher_func function"
+            end
+            if not dispatcher.formatter_func or (type(dispatcher.formatter_func) ~= "function" and not (type(dispatcher.formatter_func) == "table" and getmetatable(dispatcher.formatter_func) and getmetatable(dispatcher.formatter_func).__call)) then
+                return false, "Each dispatcher must have a formatter_func function"
+            end
+        end
+    end
+
+    return true
+end
+
+--- Validates basic config fields (name, propagate, timezone)
+-- @param config table The config to validate
+-- @return boolean, string True if valid, or false with error message
+local function validate_basic_fields(config)
+    if config.name and type(config.name) ~= "string" then
+        return false, "Config.name must be a string"
+    end
+
+    if config.propagate ~= nil and type(config.propagate) ~= "boolean" then
+        return false, "Config.propagate must be a boolean"
+    end
+
+    -- Validate timezone
+    local valid, err = validate_timezone(config.timezone)
+    if not valid then
+        return false, err
+    end
+
+    return true
+end
+
+-- =============================================================================
+-- SHORTCUT API FUNCTIONS
+-- =============================================================================
+
+--- Detects if a config uses the shortcut declarative format
+-- @param config table The config to check
+-- @return boolean True if it's a shortcut format
+local function is_shortcut_config(config)
+    return config.dispatcher ~= nil or config.formatter ~= nil
+end
+
+--- Validates shortcut config fields
+-- @param config table The shortcut config to validate
+-- @return boolean, string True if valid, or false with error message
+local function validate_shortcut_fields(config)
+    -- Check for required fields in shortcut format
+    if not config.dispatcher then
+        return false, "Shortcut config must have an 'dispatcher' field"
+    end
+
+    if not config.formatter then
+        return false, "Shortcut config must have a 'formatter' field"
+    end
+
+    -- Validate dispatcher type
+    local valid, err = constants.validate_against_constants(config.dispatcher, constants.VALID_dispatcher_TYPES, false,
+        "string")
+    if not valid then
+        return false, err
+    end
+
+    -- Validate formatter type
+    valid, err = constants.validate_against_constants(config.formatter, constants.VALID_FORMATTER_TYPES, false, "string")
+    if not valid then
+        return false, err
+    end
+
+    -- Validate file-specific requirements
+    if config.dispatcher == "file" then
+        if not config.path or type(config.path) ~= "string" then
+            return false, "File dispatcher must have a 'path' string field"
+        end
+    end
+
+    -- Validate console-specific fields
+    if config.dispatcher == "console" and config.stream then
+        if type(config.stream) == "string" or type(config.stream) == "number" or type(config.stream) == "boolean" then
+            return false, "Console dispatcher 'stream' field must be a file handle"
+        end
+    end
+
+    return true
+end
+
+--- Validates that shortcut config doesn't contain unknown keys
+-- @param config table The config to validate
+-- @return boolean, string True if valid, or false with error message
+local function validate_shortcut_known_keys(config)
+    local valid_keys = {
+        name = true,
+        level = true,
+        dispatcher = true,
+        formatter = true,
+        propagate = true,
+        timezone = true,
+        -- File-specific fields
+        path = true,
+        -- Console-specific fields
+        stream = true
+    }
+
+    for key, _ in pairs(config) do
+        if not valid_keys[key] then
+            return false, "Unknown shortcut config key: " .. tostring(key)
+        end
+    end
+
+    return true
+end
+
+--- Validates a shortcut declarative config table
+-- @param config table The shortcut config to validate
+-- @return boolean, string True if valid, or false with error message
+local function validate_shortcut_config(config)
+    if type(config) ~= "table" then
+        return false, "Config must be a table"
+    end
+
+    -- Validate unknown keys
+    local valid, err = validate_shortcut_known_keys(config)
+    if not valid then
+        return false, err
+    end
+
+    -- Validate basic fields (name, propagate)
+    valid, err = validate_basic_fields(config)
+    if not valid then
+        return false, err
+    end
+
+    -- Validate level
+    valid, err = validate_level(config.level)
+    if not valid then
+        return false, err
+    end
+
+    -- Validate shortcut-specific fields
+    valid, err = validate_shortcut_fields(config)
+    if not valid then
+        return false, err
+    end
+
+    return true
+end
+
+--- Transforms shortcut config to standard declarative config format
+-- @param shortcut_config table The shortcut config
+-- @return table The standard declarative config
+local function shortcut_to_declarative_config(shortcut_config)
+    local declarative_config = {
+        name = shortcut_config.name,
+        level = shortcut_config.level,
+        propagate = shortcut_config.propagate,
+        timezone = shortcut_config.timezone,
+        dispatchers = {}
+    }
+
+    -- Create the single dispatcher entry
+    local dispatcher_entry = {
+        type = shortcut_config.dispatcher,
+        formatter = shortcut_config.formatter
+    }
+
+    -- Add type-specific fields
+    if shortcut_config.dispatcher == "file" then
+        dispatcher_entry.path = shortcut_config.path
+    elseif shortcut_config.dispatcher == "console" and shortcut_config.stream then
+        dispatcher_entry.stream = shortcut_config.stream
+    end
+
+    table.insert(declarative_config.dispatchers, dispatcher_entry)
+
+    return declarative_config
+end
+
+-- =============================================================================
+-- DECLARATIVE API FUNCTIONS
+-- =============================================================================
+
+--- Validates a single dispatcher configuration
+-- @param dispatcher table The dispatcher config to validate
+-- @param index number The index of the dispatcher (for error messages)
+-- @return boolean, string True if valid, or false with error message
+local function validate_single_dispatcher(dispatcher, index)
+    if type(dispatcher) ~= "table" then
+        return false, "Each dispatcher must be a table"
+    end
+
+    if not dispatcher.type or type(dispatcher.type) ~= "string" then
+        return false, "Each dispatcher must have a 'type' string field"
+    end
+
+    if not dispatcher.formatter or type(dispatcher.formatter) ~= "string" then
+        return false, "Each dispatcher must have a 'formatter' string field"
+    end
+
+    -- Validate known dispatcher types
+    local valid, err = constants.validate_against_constants(dispatcher.type, constants.VALID_dispatcher_TYPES, false,
+        "string")
+    if not valid then
+        return false, err
+    end
+
+    -- Validate known formatter types
+    valid, err = constants.validate_against_constants(dispatcher.formatter, constants.VALID_FORMATTER_TYPES, false,
+        "string")
+    if not valid then
+        return false, err
+    end
+
+    -- Validate type-specific fields
+    if dispatcher.type == "file" then
+        if not dispatcher.path or type(dispatcher.path) ~= "string" then
+            return false, "File dispatcher must have a 'path' string field"
+        end
+    end
+
+    if dispatcher.type == "console" and dispatcher.stream then
+        -- stream should be a file handle, but we can't easily validate that
+        -- so we'll just check it's not a string/number/boolean
+        if type(dispatcher.stream) == "string" or type(dispatcher.stream) == "number" or type(dispatcher.stream) == "boolean" then
+            return false, "Console dispatcher 'stream' field must be a file handle"
+        end
+    end
+
+    return true
+end
+
+--- Validates dispatchers array for declarative format
+-- @param dispatchers table The dispatchers array to validate
+-- @return boolean, string True if valid, or false with error message
+local function validate_dispatchers(dispatchers)
+    if dispatchers == nil then
+        return true -- dispatchers is optional
+    end
+
+    if type(dispatchers) ~= "table" then
+        return false, "Config.dispatchers must be a table"
+    end
+
+    for i, dispatcher in ipairs(dispatchers) do
+        local valid, err = validate_single_dispatcher(dispatcher, i)
+        if not valid then
+            return false, err
+        end
+    end
+
+    return true
+end
+
+--- Validates that declarative config doesn't contain unknown keys
+-- @param config table The config to validate
+-- @return boolean, string True if valid, or false with error message
+local function validate_declarative_known_keys(config)
+    local valid_keys = {
+        name = true,
+        level = true,
+        dispatchers = true,
+        propagate = true,
+        timezone = true
+    }
+
+    for key, _ in pairs(config) do
+        if not valid_keys[key] then
+            return false, "Unknown config key: " .. tostring(key)
+        end
+    end
+
+    return true
+end
+
+--- Validates a declarative config table (with string-based types)
+-- @param config (table) The declarative config to validate
+-- @return boolean, string True if valid, or false with error message
+local function validate_declarative_config(config)
+    if type(config) ~= "table" then
+        return false, "Config must be a table"
+    end
+
+    -- Validate unknown keys
+    local valid, err = validate_declarative_known_keys(config)
+    if not valid then
+        return false, err
+    end
+
+    -- Validate basic fields
+    valid, err = validate_basic_fields(config)
+    if not valid then
+        return false, err
+    end
+
+    -- Validate level
+    valid, err = validate_level(config.level)
+    if not valid then
+        return false, err
+    end
+
+    -- Validate dispatchers
+    valid, err = validate_dispatchers(config.dispatchers)
+    if not valid then
+        return false, err
+    end
+
+    return true
+end
+
+--- Converts a declarative config to canonical config format
+-- @param declarative_config (table) The declarative config
+-- @return table The canonical config
+local function declarative_to_canonical_config(declarative_config)
+    local all_dispatchers = require("lual.dispatchers.init")
+    local all_formatters = require("lual.formatters.init")
+
+    local canonical = {
+        name = declarative_config.name,
+        propagate = declarative_config.propagate,
+        timezone = declarative_config.timezone,
+        dispatchers = {}
+    }
+
+    -- Convert level string to number if needed
+    if declarative_config.level then
+        if type(declarative_config.level) == "string" then
+            local level_map = {
+                debug = core_levels.definition.DEBUG,
+                info = core_levels.definition.INFO,
+                warning = core_levels.definition.WARNING,
+                error = core_levels.definition.ERROR,
+                critical = core_levels.definition.CRITICAL,
+                none = core_levels.definition.NONE
+            }
+            canonical.level = level_map[string.lower(declarative_config.level)]
+        else
+            canonical.level = declarative_config.level
+        end
+    end
+
+    -- Convert dispatchers from declarative to canonical format
+    if declarative_config.dispatchers then
+        for _, dispatcher_config in ipairs(declarative_config.dispatchers) do
+            local dispatcher_func
+            local formatter_func
+            local config = {}
+
+            -- Get dispatcher function
+            if dispatcher_config.type == "console" then
+                dispatcher_func = all_dispatchers.console_dispatcher
+                if dispatcher_config.stream then
+                    config.stream = dispatcher_config.stream
+                end
+            elseif dispatcher_config.type == "file" then
+                -- File dispatcher is a factory, so we need to call it with config to get the actual function
+                local file_factory = all_dispatchers.file_dispatcher
+                config.path = dispatcher_config.path
+                -- Copy other file-specific config
+                for k, v in pairs(dispatcher_config) do
+                    if k ~= "type" and k ~= "formatter" and k ~= "path" then
+                        config[k] = v
+                    end
+                end
+                dispatcher_func = file_factory(config)
+            end
+
+            -- Get formatter function
+            if dispatcher_config.formatter == "text" then
+                formatter_func = all_formatters.text
+            elseif dispatcher_config.formatter == "color" then
+                formatter_func = all_formatters.color
+            elseif dispatcher_config.formatter == "json" then
+                formatter_func = all_formatters.json
+            end
+
+            table.insert(canonical.dispatchers, {
+                dispatcher_func = dispatcher_func,
+                formatter_func = formatter_func,
+                dispatcher_config = config
+            })
+        end
+    end
+
+    return canonical
+end
+
+-- =============================================================================
+-- PUBLIC API
+-- =============================================================================
+
+--- Main function to process any config format and return a validated canonical config
+-- @param input_config table The input config (can be shortcut, declarative, or partial canonical)
+-- @param default_config table Optional default config to merge with
+-- @return table The validated canonical config
+function M.process_config(input_config, default_config)
+    local final_declarative_config = input_config
+
+    -- Check if this is a shortcut config and transform it if needed
+    if is_shortcut_config(input_config) then
+        -- Validate the shortcut config
+        local valid, err = validate_shortcut_config(input_config)
+        if not valid then
+            error("Invalid shortcut config: " .. err)
+        end
+
+        -- Transform shortcut to standard declarative format
+        final_declarative_config = shortcut_to_declarative_config(input_config)
+    else
+        -- Validate the standard declarative config
+        local valid, err = validate_declarative_config(input_config)
+        if not valid then
+            error("Invalid declarative config: " .. err)
+        end
+    end
+
+    -- Apply defaults if provided
+    if default_config then
+        final_declarative_config = merge_configs(final_declarative_config, default_config)
+    end
+
+    -- Convert to canonical format
+    local canonical_config = declarative_to_canonical_config(final_declarative_config)
+
+    -- Validate the final canonical config
+    local valid, err = validate_canonical_config(canonical_config)
+    if not valid then
+        error("Invalid canonical config: " .. err)
+    end
+
+    return canonical_config
+end
+
+--- Creates a canonical config with defaults
+-- @param config table Optional initial config
+-- @return table The canonical config
+function M.create_canonical_config(config)
+    return create_canonical_config(config)
+end
+
+--- Clones a config table
+-- @param config table The config to clone
+-- @return table The cloned config
+function M.clone_config(config)
+    return clone_config(config)
+end
+
+--- Validates a canonical config
+-- @param config table The config to validate
+-- @return boolean, string True if valid, or false with error message
+function M.validate_canonical_config(config)
+    return validate_canonical_config(config)
+end
+
+--- Detects if a config is in shortcut format
+-- @param config table The config to check
+-- @return boolean True if shortcut format
+function M.is_shortcut_config(config)
+    return is_shortcut_config(config)
+end
+
+--- Transforms shortcut config to declarative format
+-- @param config table The shortcut config
+-- @return table The declarative config
+function M.shortcut_to_declarative_config(config)
+    return shortcut_to_declarative_config(config)
+end
+
+--- Validates a declarative config
+-- @param config table The config to validate
+-- @return boolean, string True if valid, or false with error message
+function M.validate_declarative_config(config)
+    return validate_declarative_config(config)
+end
+
+--- Converts declarative config to canonical format
+-- @param config table The declarative config
+-- @return table The canonical config
+function M.declarative_to_canonical_config(config)
+    return declarative_to_canonical_config(config)
+end
+
+--- Merges configs with user config taking precedence
+-- @param user_config table The user config
+-- @param default_config table The default config
+-- @return table The merged config
+function M.merge_configs(user_config, default_config)
+    return merge_configs(user_config, default_config)
+end
+
+return M
diff --git a/lua/lual/config/constants.lua b/lua/lual/config/constants.lua
index 9b9031d..8bd6a97 100644
--- a/lua/lual/config/constants.lua
+++ b/lua/lual/config/constants.lua
@@ -3,16 +3,16 @@
 
 local M = {}
 
--- Valid output types
-M.VALID_OUTPUT_TYPES = {
-    _meta = { name = "output type", case_sensitive = false },
+-- Valid dispatcher types
+M.VALID_dispatcher_TYPES = {
+    _meta = { name = "dispatcher type", case_sensitive = false },
     console = true,
     file = true
 }
 
 -- Valid formatter types
 M.VALID_FORMATTER_TYPES = {
-    _meta = { name = "formatter type", case_sensitive = false },
+    _meta = { name = "Formatter type", case_sensitive = false },
     text = true,
     color = true,
     json = true
@@ -40,7 +40,7 @@ M.VALID_LEVEL_STRINGS = {
 M.VALID_SHORTCUT_KEYS = {
     name = true,
     level = true,
-    output = true,
+    dispatcher = true,
     formatter = true,
     propagate = true,
     timezone = true,
@@ -54,7 +54,7 @@ M.VALID_SHORTCUT_KEYS = {
 M.VALID_DECLARATIVE_KEYS = {
     name = true,
     level = true,
-    outputs = true,
+    dispatchers = true,
     propagate = true,
     timezone = true
 }
@@ -78,7 +78,7 @@ function M.generate_expected_error_message(value, constant_table)
             table.insert(valid_values, key)
         end
     end
-    table.sort(valid_values) -- Sort for consistent output
+    table.sort(valid_values) -- Sort for consistent dispatcher
 
     return string.format("Invalid %s: %s. Valid values are: %s",
         field_name,
@@ -103,7 +103,7 @@ function M.validate_against_constants(value, constant_table, allow_nil, expected
     if expected_type and type(value) ~= expected_type then
         local meta = constant_table._meta
         local field_name = meta and meta.name or "value"
-        return false, string.format("%s must be a %s", string.gsub(field_name, "^%l", string.upper), expected_type)
+        return false, string.format("%s must be a %s", field_name, expected_type)
     end
 
     local meta = constant_table._meta
diff --git a/lua/lual/config/transformation.lua b/lua/lual/config/transformation.lua
index a719908..d44e0f3 100644
--- a/lua/lual/config/transformation.lua
+++ b/lua/lual/config/transformation.lua
@@ -16,7 +16,7 @@ function M.create_canonical_config(config)
     return {
         name = config.name or "root",
         level = config.level or core_levels.definition.INFO,
-        outputs = config.outputs or {},
+        dispatchers = config.dispatchers or {},
         propagate = config.propagate ~= false, -- Default to true unless explicitly false
         parent = config.parent or nil,
         timezone = config.timezone or "local"  -- Default to local time
@@ -29,14 +29,14 @@ end
 function M.clone_config(config)
     local cloned = {}
     for k, v in pairs(config) do
-        if type(v) == "table" and k == "outputs" then
-            -- Deep clone outputs array
+        if type(v) == "table" and k == "dispatchers" then
+            -- Deep clone dispatchers array
             cloned[k] = {}
-            for i, output in ipairs(v) do
+            for i, dispatcher in ipairs(v) do
                 cloned[k][i] = {
-                    output_func = output.output_func,
-                    formatter_func = output.formatter_func,
-                    output_config = output.output_config or {}
+                    dispatcher_func = dispatcher.dispatcher_func,
+                    formatter_func = dispatcher.formatter_func,
+                    dispatcher_config = dispatcher.dispatcher_config or {}
                 }
             end
         else
@@ -73,7 +73,7 @@ function M.is_shortcut_config(config)
     if not config or type(config) ~= "table" then
         return false
     end
-    return config.output ~= nil or config.formatter ~= nil
+    return config.dispatcher ~= nil or config.formatter ~= nil
 end
 
 --- Transforms shortcut config to standard declarative config format
@@ -104,23 +104,23 @@ function M.shortcut_to_declarative_config(shortcut_config)
         level = validated_config.level,
         propagate = validated_config.propagate,
         timezone = validated_config.timezone,
-        outputs = {}
+        dispatchers = {}
     }
 
-    -- Create the single output entry
-    local output_entry = {
-        type = validated_config.output,
+    -- Create the single dispatcher entry
+    local dispatcher_entry = {
+        type = validated_config.dispatcher,
         formatter = validated_config.formatter
     }
 
     -- Add type-specific fields
-    if validated_config.output == "file" then
-        output_entry.path = validated_config.path
-    elseif validated_config.output == "console" and validated_config.stream then
-        output_entry.stream = validated_config.stream
+    if validated_config.dispatcher == "file" then
+        dispatcher_entry.path = validated_config.path
+    elseif validated_config.dispatcher == "console" and validated_config.stream then
+        dispatcher_entry.stream = validated_config.stream
     end
 
-    table.insert(declarative_config.outputs, output_entry)
+    table.insert(declarative_config.dispatchers, dispatcher_entry)
 
     return declarative_config
 end
@@ -129,14 +129,14 @@ end
 -- @param declarative_config (table) The declarative config
 -- @return table The canonical config
 function M.declarative_to_canonical_config(declarative_config)
-    local all_outputs = require("lual.outputs.init")
+    local all_dispatchers = require("lua.lual.dispatchers.init")
     local all_formatters = require("lual.formatters.init")
 
     local canonical = {
         name = declarative_config.name,
         propagate = declarative_config.propagate,
         timezone = declarative_config.timezone,
-        outputs = {}
+        dispatchers = {}
     }
 
     -- Convert level string to number if needed
@@ -156,58 +156,58 @@ function M.declarative_to_canonical_config(declarative_config)
         end
     end
 
-    -- Convert outputs from declarative to canonical format
-    if declarative_config.outputs then
-        for _, output_config in ipairs(declarative_config.outputs) do
-            local output_func
+    -- Convert dispatchers from declarative to canonical format
+    if declarative_config.dispatchers then
+        for _, dispatcher_config in ipairs(declarative_config.dispatchers) do
+            local dispatcher_func
             local formatter_func
             local config = {}
 
-            -- Get output function
-            if output_config.type == "console" then
-                output_func = all_outputs.console_output
-                if output_config.stream then
-                    config.stream = output_config.stream
+            -- Get dispatcher function
+            if dispatcher_config.type == "console" then
+                dispatcher_func = all_dispatchers.console_dispatcher
+                if dispatcher_config.stream then
+                    config.stream = dispatcher_config.stream
                 end
-            elseif output_config.type == "file" then
-                -- File output is a factory, so we need to call it with config to get the actual function
-                local file_factory = all_outputs.file_output
-                config.path = output_config.path
+            elseif dispatcher_config.type == "file" then
+                -- File dispatcher is a factory, so we need to call it with config to get the actual function
+                local file_factory = all_dispatchers.file_dispatcher
+                config.path = dispatcher_config.path
                 -- Copy other file-specific config
-                for k, v in pairs(output_config) do
+                for k, v in pairs(dispatcher_config) do
                     if k ~= "type" and k ~= "formatter" and k ~= "path" then
                         config[k] = v
                     end
                 end
-                output_func = file_factory(config)
+                dispatcher_func = file_factory(config)
             end
 
             -- Get formatter function
-            if output_config.formatter == "text" then
+            if dispatcher_config.formatter == "text" then
                 local text_factory = all_formatters.text
                 formatter_func = text_factory()
-            elseif output_config.formatter == "color" then
+            elseif dispatcher_config.formatter == "color" then
                 local color_factory = all_formatters.color
                 -- Extract color-specific config if present
                 local formatter_config = {}
-                if output_config.level_colors then
-                    formatter_config.level_colors = output_config.level_colors
+                if dispatcher_config.level_colors then
+                    formatter_config.level_colors = dispatcher_config.level_colors
                 end
                 formatter_func = color_factory(formatter_config)
-            elseif output_config.formatter == "json" then
+            elseif dispatcher_config.formatter == "json" then
                 local json_factory = all_formatters.json
                 -- Extract json-specific config if present
                 local formatter_config = {}
-                if output_config.pretty ~= nil then
-                    formatter_config.pretty = output_config.pretty
+                if dispatcher_config.pretty ~= nil then
+                    formatter_config.pretty = dispatcher_config.pretty
                 end
                 formatter_func = json_factory(formatter_config)
             end
 
-            table.insert(canonical.outputs, {
-                output_func = output_func,
+            table.insert(canonical.dispatchers, {
+                dispatcher_func = dispatcher_func,
                 formatter_func = formatter_func,
-                output_config = config
+                dispatcher_config = config
             })
         end
     end
diff --git a/lua/lual/config/validation.lua b/lua/lual/config/validation.lua
index cbb78e5..c5d95de 100644
--- a/lua/lual/config/validation.lua
+++ b/lua/lual/config/validation.lua
@@ -24,7 +24,7 @@ function M.validate_and_merge_config(user_config, default_config)
         -- Convert first error to old format (single error string)
         for field, error_msg in pairs(result._errors) do
             if type(error_msg) == "table" then
-                -- Handle nested errors (like outputs[1].formatter)
+                -- Handle nested errors (like dispatchers[1].formatter)
                 for sub_field, sub_error in pairs(error_msg) do
                     return nil, sub_error
                 end
@@ -34,15 +34,54 @@ function M.validate_and_merge_config(user_config, default_config)
         end
     end
 
-    return result.data
+    -- 4. Convert string-based config to function-based config if needed
+    local validated_config = result.data
+    if validated_config.dispatchers then
+        local all_dispatchers = require("lual.dispatchers.init")
+        local all_formatters = require("lual.formatters.init")
+
+        for i, dispatcher in ipairs(validated_config.dispatchers) do
+            -- Convert string formatter to function if it's still a string
+            if type(dispatcher.formatter) == "string" then
+                if dispatcher.formatter == "text" then
+                    dispatcher.formatter_func = all_formatters.text
+                elseif dispatcher.formatter == "color" then
+                    dispatcher.formatter_func = all_formatters.color
+                elseif dispatcher.formatter == "json" then
+                    dispatcher.formatter_func = all_formatters.json
+                end
+                -- Keep the original string for reference but add the function
+            end
+
+            -- Convert string dispatcher type to function if needed
+            if type(dispatcher.type) == "string" then
+                if dispatcher.type == "console" then
+                    dispatcher.dispatcher_func = all_dispatchers.console_dispatcher
+                elseif dispatcher.type == "file" then
+                    -- File dispatcher is a factory, so we need to call it with config
+                    local config = { path = dispatcher.path }
+                    -- Copy other file-specific config
+                    for k, v in pairs(dispatcher) do
+                        if k ~= "type" and k ~= "formatter" and k ~= "path" and k ~= "formatter_func" and k ~= "dispatcher_func" then
+                            config[k] = v
+                        end
+                    end
+                    dispatcher.dispatcher_func = all_dispatchers.file_dispatcher(config)
+                    dispatcher.dispatcher_config = config
+                end
+            end
+        end
+    end
+
+    return validated_config
 end
 
---- Validates a single output configuration
--- @param output table The output config to validate
+--- Validates a single dispatcher configuration
+-- @param dispatcher table The dispatcher config to validate
 -- @return string|nil Error message or nil if valid
-function M.validate_single_output(output)
-    -- Use schema validation for output
-    local result = schema.validate_output(output)
+function M.validate_single_dispatcher(dispatcher)
+    -- Use schema validation for dispatcher
+    local result = schema.validate_dispatcher(dispatcher)
 
     -- Check for errors and return in the old format
     if next(result._errors) then
@@ -52,6 +91,47 @@ function M.validate_single_output(output)
         end
     end
 
+    -- Convert string-based config to function-based config if needed
+    local validated_dispatcher = result.data
+    if validated_dispatcher then
+        local all_dispatchers = require("lual.dispatchers.init")
+        local all_formatters = require("lual.formatters.init")
+
+        -- Convert string formatter to function if it's still a string
+        if type(validated_dispatcher.formatter) == "string" then
+            if validated_dispatcher.formatter == "text" then
+                validated_dispatcher.formatter_func = all_formatters.text
+            elseif validated_dispatcher.formatter == "color" then
+                validated_dispatcher.formatter_func = all_formatters.color
+            elseif validated_dispatcher.formatter == "json" then
+                validated_dispatcher.formatter_func = all_formatters.json
+            end
+        end
+
+        -- Convert string dispatcher type to function if needed
+        if type(validated_dispatcher.type) == "string" then
+            if validated_dispatcher.type == "console" then
+                validated_dispatcher.dispatcher_func = all_dispatchers.console_dispatcher
+            elseif validated_dispatcher.type == "file" then
+                -- File dispatcher is a factory, so we need to call it with config
+                local config = { path = validated_dispatcher.path }
+                -- Copy other file-specific config
+                for k, v in pairs(validated_dispatcher) do
+                    if k ~= "type" and k ~= "formatter" and k ~= "path" and k ~= "formatter_func" and k ~= "dispatcher_func" then
+                        config[k] = v
+                    end
+                end
+                validated_dispatcher.dispatcher_func = all_dispatchers.file_dispatcher(config)
+                validated_dispatcher.dispatcher_config = config
+            end
+        end
+
+        -- Copy the converted dispatcher back to the original
+        for k, v in pairs(validated_dispatcher) do
+            dispatcher[k] = v
+        end
+    end
+
     return nil
 end
 
@@ -71,8 +151,8 @@ function M.validate_canonical_config(config)
         return false, "Config.level must be a number"
     end
 
-    if config.outputs and type(config.outputs) ~= "table" then
-        return false, "Config.outputs must be a table"
+    if config.dispatchers and type(config.dispatchers) ~= "table" then
+        return false, "Config.dispatchers must be a table"
     end
 
     if config.propagate ~= nil and type(config.propagate) ~= "boolean" then
@@ -88,17 +168,17 @@ function M.validate_canonical_config(config)
         end
     end
 
-    -- Validate outputs structure (canonical format has functions)
-    if config.outputs then
-        for i, output in ipairs(config.outputs) do
-            if type(output) ~= "table" then
-                return false, "Each output must be a table"
+    -- Validate dispatchers structure (canonical format has functions)
+    if config.dispatchers then
+        for i, dispatcher in ipairs(config.dispatchers) do
+            if type(dispatcher) ~= "table" then
+                return false, "Each dispatcher must be a table"
             end
-            if not output.output_func or type(output.output_func) ~= "function" then
-                return false, "Each output must have an output_func function"
+            if not dispatcher.dispatcher_func or type(dispatcher.dispatcher_func) ~= "function" then
+                return false, "Each dispatcher must have an dispatcher_func function"
             end
-            if not output.formatter_func or (type(output.formatter_func) ~= "function" and not (type(output.formatter_func) == "table" and getmetatable(output.formatter_func) and getmetatable(output.formatter_func).__call)) then
-                return false, "Each output must have a formatter_func function"
+            if not dispatcher.formatter_func or (type(dispatcher.formatter_func) ~= "function" and not (type(dispatcher.formatter_func) == "table" and getmetatable(dispatcher.formatter_func) and getmetatable(dispatcher.formatter_func).__call)) then
+                return false, "Each dispatcher must have a formatter_func function"
             end
         end
     end
diff --git a/lua/lual/core/engine.lua.backup b/lua/lual/core/engine.lua.backup
new file mode 100644
index 0000000..6b2e95d
--- /dev/null
+++ b/lua/lual/core/engine.lua.backup
@@ -0,0 +1,377 @@
+local ingest = require("lual.ingest")
+local core_levels = require("lual.core.levels")
+local caller_info = require("lual.core.caller_info")
+local config_module = require("lual.config")
+
+local _loggers_cache = {}
+local get_logger                -- Forward-declared for ingest and M.get_logger mutual recursion
+local create_logger_from_config -- Forward-declared
+local logger = {}               -- Declare the logger prototype table
+
+-- =============================================================================
+-- LOGGER PROTOTYPE METHODS
+-- =============================================================================
+
+function logger:debug(...)
+    self:log(core_levels.definition.DEBUG, ...)
+end
+
+function logger:info(...)
+    self:log(core_levels.definition.INFO, ...)
+end
+
+function logger:warn(...)
+    self:log(core_levels.definition.WARNING, ...)
+end
+
+function logger:error(...)
+    self:log(core_levels.definition.ERROR, ...)
+end
+
+function logger:critical(...)
+    self:log(core_levels.definition.CRITICAL, ...)
+end
+
+-- =============================================================================
+-- CONFIG-BASED LOGGER CREATION
+-- =============================================================================
+
+--- Creates a logger from a canonical config table
+-- @param config (table) The canonical config
+-- @return table The logger instance
+create_logger_from_config = function(config)
+    local valid, err = config_module.validate_canonical_config(config)
+    if not valid then
+        error("Invalid logger config: " .. err)
+    end
+
+    local canonical_config = config_module.create_canonical_config(config)
+
+    -- Create new logger object based on prototype
+    local new_logger = {}
+    for k, v in pairs(logger) do -- 'logger' now refers to the local prototype
+        new_logger[k] = v
+    end
+
+    new_logger.name = canonical_config.name
+    new_logger.level = canonical_config.level
+    new_logger.dispatchers = canonical_config.dispatchers
+    new_logger.propagate = canonical_config.propagate
+    new_logger.parent = canonical_config.parent
+    new_logger.timezone = canonical_config.timezone
+
+    return new_logger
+end
+
+
+-- The rest of logger methods are defined on the 'local logger' table
+
+function logger:log(level_no, ...)
+    if not self:is_enabled_for(level_no) then
+        return
+    end
+
+    local filename, lineno = caller_info.get_caller_info()
+
+    local packed_varargs = table.pack(...)
+    local msg_fmt_val
+    local args_val
+    local context_val = nil -- Initialize context as nil
+
+    if packed_varargs.n > 0 and type(packed_varargs[1]) == "table" then
+        -- This is Pattern 2: context_table, [message_format_string, ...format_args]
+        context_val = packed_varargs[1]
+        if packed_varargs.n >= 2 and type(packed_varargs[2]) == "string" then
+            msg_fmt_val = packed_varargs[2]
+            if packed_varargs.n >= 3 then
+                args_val = table.pack(select(3, ...)) -- Args from 3rd element of original '...'
+            else
+                args_val = table.pack()               -- No further args for formatting
+            end
+        else
+            -- Context only (Pattern 2b), or context + non-string second arg.
+            -- message_fmt might be extracted from context_val.msg later if desired.
+            msg_fmt_val = nil       -- Or extract from context_val.msg
+            args_val = table.pack() -- No args for formatting
+            if msg_fmt_val == nil and context_val and context_val.msg and type(context_val.msg) == "string" then
+                -- Attempt to extract message_fmt from context.msg for Pattern 2b
+                msg_fmt_val = context_val.msg
+            end
+        end
+    else
+        -- Pattern 1: String Formatting Only, or no arguments after level_no
+        -- The first argument (packed_varargs[1]) is message_fmt, rest are args.
+        -- context_val remains nil (as initialized).
+        if packed_varargs.n > 0 and type(packed_varargs[1]) == "string" then
+            msg_fmt_val = packed_varargs[1]
+            if packed_varargs.n >= 2 then
+                args_val = table.pack(select(2, ...)) -- Args from 2nd element of original '...'
+            else
+                args_val = table.pack()               -- No further args for formatting
+            end
+        elseif packed_varargs.n == 0 then             -- No arguments after level_no
+            msg_fmt_val = ""                          -- Default to empty string if no message/context
+            args_val = table.pack()
+        else                                          -- First argument is not a table and not a string (e.g. a number or boolean)
+            -- Treat as a single message to be stringified, no further args.
+            msg_fmt_val = tostring(packed_varargs[1])
+            args_val = table.pack()
+        end
+    end
+
+    local log_record = {
+        level_no = level_no,
+        level_name = core_levels.get_level_name(level_no),
+        message_fmt = msg_fmt_val,
+        args = args_val,
+        context = context_val,               -- Add the new context field
+        timestamp = os.time(),
+        timezone = self.timezone or "local", -- Add timezone configuration
+        logger_name = self.name,
+        source_logger_name = self.name,      -- Initially the same as logger_name
+        filename = filename,
+        lineno = lineno,
+    }
+    -- Note: 'get_logger' here will refer to the local variable defined at the top
+    -- which will be assigned M.get_logger later.
+    ingest.dispatch_log_event(log_record, get_logger, core_levels.definition)
+end
+
+function logger:set_level(level)
+    -- Get current config, modify it, and recreate logger
+    local current_config = self:get_config()
+    current_config.level = level
+    local new_logger = create_logger_from_config(current_config)
+
+    -- Update the cache with the new logger
+    _loggers_cache[self.name] = new_logger
+
+    -- Copy new logger properties to self (for existing references)
+    for k, v in pairs(new_logger) do
+        if k ~= "name" then -- Don't change the name
+            self[k] = v
+        end
+    end
+end
+
+function logger:add_dispatcher(dispatcher_func, formatter_func, dispatcher_config)
+    -- Get current config, modify it, and recreate logger
+    local current_config = self:get_config()
+    table.insert(current_config.dispatchers, {
+        dispatcher_func = dispatcher_func,
+        formatter_func = formatter_func,
+        dispatcher_config = dispatcher_config or {},
+    })
+    local new_logger = create_logger_from_config(current_config)
+
+    -- Update the cache with the new logger
+    _loggers_cache[self.name] = new_logger
+
+    -- Copy new logger properties to self (for existing references)
+    for k, v in pairs(new_logger) do
+        if k ~= "name" then -- Don't change the name
+            self[k] = v
+        end
+    end
+end
+
+function logger:set_propagate(propagate)
+    -- Get current config, modify it, and recreate logger
+    local current_config = self:get_config()
+    current_config.propagate = propagate
+    local new_logger = create_logger_from_config(current_config)
+
+    -- Update the cache with the new logger
+    _loggers_cache[self.name] = new_logger
+
+    -- Copy new logger properties to self (for existing references)
+    for k, v in pairs(new_logger) do
+        if k ~= "name" then -- Don't change the name
+            self[k] = v
+        end
+    end
+end
+
+function logger:get_config()
+    -- Return the current configuration as a canonical config table
+    return config_module.create_canonical_config({
+        name = self.name,
+        level = self.level,
+        dispatchers = self.dispatchers or {},
+        propagate = self.propagate,
+        parent = self.parent,
+        timezone = self.timezone,
+    })
+end
+
+function logger:is_enabled_for(message_level_no)
+    if self.level == core_levels.definition.NONE then
+        return message_level_no == core_levels.definition.NONE
+    end
+    return message_level_no >= self.level
+end
+
+function logger:get_effective_dispatchers()
+    local effective_dispatchers = {}
+    local current_logger = self
+
+    while current_logger do
+        for _, dispatcher_item in ipairs(current_logger.dispatchers or {}) do
+            table.insert(effective_dispatchers, {
+                dispatcher_func = dispatcher_item.dispatcher_func,
+                formatter_func = dispatcher_item.formatter_func,
+                dispatcher_config = dispatcher_item.dispatcher_config,
+                owner_logger_name = current_logger.name,
+                owner_logger_level = current_logger.level,
+            })
+        end
+
+        if not current_logger.propagate or not current_logger.parent then
+            break
+        end
+        current_logger = current_logger.parent
+    end
+    return effective_dispatchers
+end
+
+-- =============================================================================
+-- PUBLIC API
+-- =============================================================================
+
+local M = {}
+
+function M._get_logger_simple(name)
+    local logger_name = name
+    if name == nil or name == "" then
+        -- Auto-generate logger name from caller's filename
+        local filename, _ = caller_info.get_caller_info(nil, true) -- Use dot notation conversion
+        if filename then
+            logger_name = filename
+        else
+            logger_name = "root"
+        end
+    end
+
+    if _loggers_cache[logger_name] then
+        return _loggers_cache[logger_name]
+    end
+
+    local parent_logger = nil
+    if logger_name ~= "root" then
+        local parent_name_end = string.match(logger_name, "(.+)%.[^%.]+$")
+        local parent_name
+        if parent_name_end then
+            parent_name = parent_name_end
+        else
+            parent_name = "root"
+        end
+        parent_logger = M._get_logger_simple(parent_name) -- Recursive call
+    end
+
+    -- Create logger using config-based approach
+    local config = {
+        name = logger_name,
+        level = core_levels.definition.INFO,
+        dispatchers = {},
+        propagate = true,
+        parent = parent_logger,
+        timezone = "local", -- Default to local time
+    }
+
+    local new_logger = create_logger_from_config(config)
+    _loggers_cache[logger_name] = new_logger
+    return new_logger
+end
+
+--- Creates a logger from a config table (new API for declarative usage)
+-- @param config (table) The logger configuration
+-- @return table The logger instance
+function M.create_logger_from_config(config)
+    return create_logger_from_config(config) -- Calls the local create_logger_from_config
+end
+
+--- Creates a logger from a declarative config table (supports both standard and shortcut formats)
+-- This is the primary API for creating loggers. Can be called with:
+-- 1. No arguments or string name: lual.logger() or lual.logger("name") - simple logger creation
+-- 2. Config table: lual.logger({name="app", level="debug", dispatchers={...}}) - declarative configuration
+-- @param input_config (string|table|nil) The logger name or declarative configuration
+-- @return table The logger instance
+function M.logger(input_config)
+    -- Handle simple cases: nil, empty string, or string name
+    if input_config == nil or input_config == "" or type(input_config) == "string" then
+        return M._get_logger_simple(input_config)
+    end
+
+    -- Handle table-based declarative configuration
+    if type(input_config) ~= "table" then
+        error("logger() expects nil, string, or table argument, got " .. type(input_config))
+    end
+
+    -- Define default config
+    local default_config = {
+        name = "root",
+        level = "info",
+        dispatchers = {},
+        propagate = true,
+        timezone = "local", -- Default to local time
+    }
+
+    -- Use the config module to process the input config (handles shortcut, declarative, validation, etc.)
+    local canonical_config = config_module.process_config(input_config, default_config)
+
+    -- Check if logger already exists in cache and if its configuration matches
+    if canonical_config.name and _loggers_cache[canonical_config.name] then
+        local cached_logger = _loggers_cache[canonical_config.name]
+        local cached_config = cached_logger:get_config()
+
+        -- Compare key configuration fields to see if we can reuse the cached logger
+        if cached_config.level == canonical_config.level and
+            cached_config.timezone == canonical_config.timezone and
+            cached_config.propagate == canonical_config.propagate then
+            -- For dispatchers, we'll do a simple length check for now
+            -- A more sophisticated comparison could be added later if needed
+            if #(cached_config.dispatchers or {}) == #(canonical_config.dispatchers or {}) then
+                return cached_logger
+            end
+        end
+        -- If configuration doesn't match, we'll create a new logger and update the cache
+    end
+
+    -- Handle parent logger creation if needed
+    if canonical_config.name and canonical_config.name ~= "root" then
+        local parent_name_end = string.match(canonical_config.name, "(.+)%.[^%.]+$")
+        local parent_name
+        if parent_name_end then
+            parent_name = parent_name_end
+        else
+            parent_name = "root"
+        end
+        canonical_config.parent = M.logger(parent_name)
+    end
+
+    -- Create the logger
+    local new_logger = create_logger_from_config(canonical_config)
+
+    -- Cache the logger if it has a name
+    if canonical_config.name then
+        _loggers_cache[canonical_config.name] = new_logger
+    end
+
+    return new_logger
+end
+
+-- Backward compatibility alias - get_logger points to logger
+M.get_logger = M.logger
+
+-- Export config module functions for backward compatibility and testing
+M.config = config_module
+
+-- Assign M.logger to the local get_logger variable used by ingest and for mutual recursion.
+-- This must be done after M.logger is defined.
+get_logger = M.logger
+
+function M.reset_cache()
+    _loggers_cache = {}
+end
+
+return M
diff --git a/lua/lual/core/logging/factory.lua b/lua/lual/core/logging/factory.lua
index 1337efc..9777cca 100644
--- a/lua/lual/core/logging/factory.lua
+++ b/lua/lual/core/logging/factory.lua
@@ -27,7 +27,7 @@ function M.create_logger_from_config(config)
 
     new_logger.name = canonical_config.name
     new_logger.level = canonical_config.level
-    new_logger.outputs = canonical_config.outputs
+    new_logger.dispatchers = canonical_config.dispatchers
     new_logger.propagate = canonical_config.propagate
     new_logger.parent = canonical_config.parent
     new_logger.timezone = canonical_config.timezone
@@ -68,7 +68,7 @@ function M.create_simple_logger(name, get_logger_func)
     local config = {
         name = logger_name,
         level = core_levels.definition.INFO,
-        outputs = {},
+        dispatchers = {},
         propagate = true,
         parent = parent_logger,
         timezone = "local", -- Default to local time
diff --git a/lua/lual/core/logging/init.lua b/lua/lual/core/logging/init.lua
index 0f51250..7539862 100644
--- a/lua/lual/core/logging/init.lua
+++ b/lua/lual/core/logging/init.lua
@@ -82,7 +82,7 @@ end
 --- Creates a logger from a declarative config table (supports both standard and shortcut formats)
 -- This is the primary API for creating loggers. Can be called with:
 -- 1. No arguments or string name: lual.logger() or lual.logger("name") - simple logger creation
--- 2. Config table: lual.logger({name="app", level="debug", outputs={...}}) - declarative configuration
+-- 2. Config table: lual.logger({name="app", level="debug", dispatchers={...}}) - declarative configuration
 -- @param input_config (string|table|nil) The logger name or declarative configuration
 -- @return table The logger instance
 function M.logger(input_config)
@@ -100,7 +100,7 @@ function M.logger(input_config)
     local default_config = {
         name = "root",
         level = "info",
-        outputs = {},
+        dispatchers = {},
         propagate = true,
         timezone = "local", -- Default to local time
     }
@@ -117,9 +117,9 @@ function M.logger(input_config)
         if cached_config.level == canonical_config.level and
             cached_config.timezone == canonical_config.timezone and
             cached_config.propagate == canonical_config.propagate then
-            -- For outputs, we'll do a simple length check for now
+            -- For dispatchers, we'll do a simple length check for now
             -- A more sophisticated comparison could be added later if needed
-            if #(cached_config.outputs or {}) == #(canonical_config.outputs or {}) then
+            if #(cached_config.dispatchers or {}) == #(canonical_config.dispatchers or {}) then
                 return cached_logger
             end
         end
diff --git a/lua/lual/core/logging/management.lua b/lua/lual/core/logging/management.lua
index 62d9e53..43055ec 100644
--- a/lua/lual/core/logging/management.lua
+++ b/lua/lual/core/logging/management.lua
@@ -27,20 +27,21 @@ function M.set_level(logger, level, create_logger_func, update_cache_func)
     end
 end
 
---- Adds an output to a logger
+--- Adds an dispatcher to a logger
 -- @param logger table The logger instance to update
--- @param output_func function The output function
+-- @param dispatcher_func function The dispatcher function
 -- @param formatter_func function The formatter function
--- @param output_config table The output configuration
+-- @param dispatcher_config table The dispatcher configuration
 -- @param create_logger_func function Function to create new logger instances
 -- @param update_cache_func function Function to update the logger cache
-function M.add_output(logger, output_func, formatter_func, output_config, create_logger_func, update_cache_func)
+function M.add_dispatcher(logger, dispatcher_func, formatter_func, dispatcher_config, create_logger_func,
+                          update_cache_func)
     -- Get current config, modify it, and recreate logger
     local current_config = M.get_config(logger)
-    table.insert(current_config.outputs, {
-        output_func = output_func,
+    table.insert(current_config.dispatchers, {
+        dispatcher_func = dispatcher_func,
         formatter_func = formatter_func,
-        output_config = output_config or {},
+        dispatcher_config = dispatcher_config or {},
     })
     local new_logger = create_logger_func(current_config)
 
@@ -84,7 +85,7 @@ function M.get_config(logger)
     return config_module.create_canonical_config({
         name = logger.name,
         level = logger.level,
-        outputs = logger.outputs or {},
+        dispatchers = logger.dispatchers or {},
         propagate = logger.propagate,
         parent = logger.parent,
         timezone = logger.timezone,
@@ -100,8 +101,8 @@ function M.add_management_methods(logger_prototype, create_logger_func, update_c
         M.set_level(self, level, create_logger_func, update_cache_func)
     end
 
-    function logger_prototype:add_output(output_func, formatter_func, output_config)
-        M.add_output(self, output_func, formatter_func, output_config, create_logger_func, update_cache_func)
+    function logger_prototype:add_dispatcher(dispatcher_func, formatter_func, dispatcher_config)
+        M.add_dispatcher(self, dispatcher_func, formatter_func, dispatcher_config, create_logger_func, update_cache_func)
     end
 
     function logger_prototype:set_propagate(propagate)
diff --git a/lua/lual/core/logging/prototype.lua b/lua/lual/core/logging/prototype.lua
index 96bf76a..b9183ab 100644
--- a/lua/lual/core/logging/prototype.lua
+++ b/lua/lual/core/logging/prototype.lua
@@ -113,17 +113,17 @@ function M.logger_prototype:is_enabled_for(message_level_no)
     return message_level_no >= self.level
 end
 
---- Gets all effective outputs for this logger (including parent outputs via propagation)
-function M.logger_prototype:get_effective_outputs()
-    local effective_outputs = {}
+--- Gets all effective dispatchers for this logger (including parent dispatchers via propagation)
+function M.logger_prototype:get_effective_dispatchers()
+    local effective_dispatchers = {}
     local current_logger = self
 
     while current_logger do
-        for _, output_item in ipairs(current_logger.outputs or {}) do
-            table.insert(effective_outputs, {
-                output_func = output_item.output_func,
-                formatter_func = output_item.formatter_func,
-                output_config = output_item.output_config,
+        for _, dispatcher_item in ipairs(current_logger.dispatchers or {}) do
+            table.insert(effective_dispatchers, {
+                dispatcher_func = dispatcher_item.dispatcher_func,
+                formatter_func = dispatcher_item.formatter_func,
+                dispatcher_config = dispatcher_item.dispatcher_config,
                 owner_logger_name = current_logger.name,
                 owner_logger_level = current_logger.level,
             })
@@ -134,7 +134,7 @@ function M.logger_prototype:get_effective_outputs()
         end
         current_logger = current_logger.parent
     end
-    return effective_outputs
+    return effective_dispatchers
 end
 
 --- Sets the ingest dispatch function (dependency injection)
diff --git a/lua/lual/outputs/console_output.lua b/lua/lual/dispatchers/console_dispatcher.lua
similarity index 71%
rename from lua/lual/outputs/console_output.lua
rename to lua/lual/dispatchers/console_dispatcher.lua
index 815459d..1301d9b 100644
--- a/lua/lual/outputs/console_output.lua
+++ b/lua/lual/dispatchers/console_dispatcher.lua
@@ -1,7 +1,7 @@
---- Output that writes log messages to a stream (e.g., io.stdout, io.stderr).
+--- dispatcher that writes log messages to a stream (e.g., io.stdout, io.stderr).
 -- @param record (table) A table containing log record details
--- @param config (table, optional) Output-specific configuration.
-local function console_output(record, config)
+-- @param config (table, optional) dispatcher-specific configuration.
+local function console_dispatcher(record, config)
     local stream = io.stdout
     if config and config.stream then
         stream = config.stream
@@ -19,4 +19,4 @@ local function console_output(record, config)
     end
 end
 
-return console_output
+return console_dispatcher
diff --git a/lua/lual/outputs/file_output.lua b/lua/lual/dispatchers/file_dispatcher.lua
similarity index 92%
rename from lua/lual/outputs/file_output.lua
rename to lua/lual/dispatchers/file_dispatcher.lua
index 752840b..c003a6b 100644
--- a/lua/lual/outputs/file_output.lua
+++ b/lua/lual/dispatchers/file_dispatcher.lua
@@ -1,6 +1,6 @@
---- Output that writes log messages to a file with rotation.
+--- dispatcher that writes log messages to a file with rotation.
 --
--- On initialization, this output handler will:
+-- On initialization, this dispatcher handler will:
 -- 1. Rotate existing log files, keeping up to 5 backups.
 --    - Example: app.log -> app.log.1, app.log.1 -> app.log.2, ..., app.log.4 -> app.log.5
 --    - app.log.5 will be deleted if it exists before rotation.
@@ -8,10 +8,10 @@
 --
 -- @usage
 -- local lual = require("lual")
--- local file_output_factory = require("lual.outputs.file_output")
+-- local file_dispatcher_factory = require("lual.dispatchers.file_dispatcher")
 --
 -- local logger = lual.logger("my_app")
--- logger:add_output(file_output_factory({ path = "app.log" }), lual.levels.INFO)
+-- logger:add_dispatcher(file_dispatcher_factory({ path = "app.log" }), lual.levels.INFO)
 -- logger:info("This will be written to app.log after rotation.")
 
 local MAX_BACKUPS = 5
@@ -158,13 +158,13 @@ local function rotate_logs(log_path)
     execute_rotation_commands(commands)
 end
 
---- Creates a file output handler with log rotation.
--- @param config (table) Configuration for the file output.
+--- Creates a file dispatcher handler with log rotation.
+-- @param config (table) Configuration for the file dispatcher.
 --   Must contain `path` (string) - the path to the main log file.
 -- @return function(record) The actual log writing function.
-local function file_output_factory(config)
+local function file_dispatcher_factory(config)
     if not config or not config.path or type(config.path) ~= "string" then
-        io.stderr:write("lual: file_output_factory requires config.path (string)\n")
+        io.stderr:write("lual: file_dispatcher_factory requires config.path (string)\n")
         return function() end -- Return a no-op function on error
     end
 
@@ -205,7 +205,7 @@ local module = setmetatable({
     _execute_rotation_commands = execute_rotation_commands
 }, {
     __call = function(_, config)
-        return file_output_factory(config)
+        return file_dispatcher_factory(config)
     end
 })
 
diff --git a/lua/lual/dispatchers/init.lua b/lua/lual/dispatchers/init.lua
new file mode 100644
index 0000000..e9dadb4
--- /dev/null
+++ b/lua/lual/dispatchers/init.lua
@@ -0,0 +1,7 @@
+local dispatchers = {}
+
+dispatchers.console_dispatcher = require("lual.dispatchers.console_dispatcher")
+dispatchers.file_dispatcher = require("lual.dispatchers.file_dispatcher")
+dispatchers.syslog_dispatcher = require("lual.dispatchers.syslog_dispatcher")
+
+return dispatchers
diff --git a/lua/lual/outputs/syslog_output.lua b/lua/lual/dispatchers/syslog_dispatcher.lua
similarity index 93%
rename from lua/lual/outputs/syslog_output.lua
rename to lua/lual/dispatchers/syslog_dispatcher.lua
index 7fc0dd5..009fa8c 100644
--- a/lua/lual/outputs/syslog_output.lua
+++ b/lua/lual/dispatchers/syslog_dispatcher.lua
@@ -1,4 +1,4 @@
---- Output that sends log messages to syslog servers via UDP.
+--- dispatcher that sends log messages to syslog servers via UDP.
 --
 -- This handler implements RFC 3164 syslog protocol and supports:
 -- - Local syslog (localhost:514) and remote syslog servers
@@ -9,14 +9,14 @@
 --
 -- @usage
 -- local lual = require("lual")
--- local syslog_output_factory = require("lual.outputs.syslog_output")
+-- local syslog_dispatcher_factory = require("lual.dispatchers.syslog_dispatcher")
 --
 -- -- Local syslog
 -- local logger = lual.logger("my_app")
--- logger:add_output(syslog_output_factory({ facility = "LOCAL0" }), lual.levels.INFO)
+-- logger:add_dispatcher(syslog_dispatcher_factory({ facility = "LOCAL0" }), lual.levels.INFO)
 --
 -- -- Remote syslog
--- logger:add_output(syslog_output_factory({
+-- logger:add_dispatcher(syslog_dispatcher_factory({
 --     host = "log.example.com",
 --     port = 514,
 --     facility = "USER"
@@ -117,7 +117,7 @@ end
 -- @return boolean, string True if valid, false and error message if invalid.
 local function validate_config(config)
     if not config then
-        return false, "syslog_output_factory requires a config table"
+        return false, "syslog_dispatcher_factory requires a config table"
     end
 
     -- Validate facility
@@ -167,15 +167,15 @@ local function validate_config(config)
     return true
 end
 
---- Creates a syslog output handler.
--- @param config (table) Configuration for the syslog output.
+--- Creates a syslog dispatcher handler.
+-- @param config (table) Configuration for the syslog dispatcher.
 --   - facility (string|number, optional): Syslog facility (default: "USER")
 --   - host (string, optional): Syslog server host (default: "localhost")
 --   - port (number, optional): Syslog server port (default: 514)
 --   - tag (string, optional): Application tag (default: "lual")
 --   - hostname (string, optional): Hostname to include in messages (default: auto-detected)
 -- @return function(record) The actual log sending function.
-local function syslog_output_factory(config)
+local function syslog_dispatcher_factory(config)
     local valid, err = validate_config(config)
     if not valid then
         io.stderr:write(string.format("lual: %s\n", err))
@@ -234,7 +234,7 @@ local module = setmetatable({
     _validate_config = validate_config
 }, {
     __call = function(_, config)
-        return syslog_output_factory(config)
+        return syslog_dispatcher_factory(config)
     end
 })
 
diff --git a/lua/lual/formatters/color.lua b/lua/lual/formatters/color.lua
index cddfa56..25ba31a 100644
--- a/lua/lual/formatters/color.lua
+++ b/lua/lual/formatters/color.lua
@@ -1,5 +1,5 @@
 -- Color formatter for lual.log inspired by the rich Python library
--- Provides colored terminal output using ANSI color codes
+-- Provides colored terminal dispatcher using ANSI color codes
 
 local unpack = unpack or table.unpack -- Ensure unpack is available
 local time_utils = require("lual.utils.time")
diff --git a/lua/lual/ingest.lua b/lua/lual/ingest.lua
index 87d373e..cfd6106 100644
--- a/lua/lual/ingest.lua
+++ b/lua/lual/ingest.lua
@@ -17,10 +17,14 @@ local function call_formatter(formatter_func, base_record_for_formatter)
         -- Create a detailed fallback message
         local raw_msg_fallback
         xpcall(
-            function() raw_msg_fallback = string.format(base_record_for_formatter.message_fmt,
-                    unpack(base_record_for_formatter.args or {})) end,
-            function(err) raw_msg_fallback = base_record_for_formatter.message_fmt ..
-                " (formatting args failed: " .. tostring(err) .. ")" end)
+            function()
+                raw_msg_fallback = string.format(base_record_for_formatter.message_fmt,
+                    unpack(base_record_for_formatter.args or {}))
+            end,
+            function(err)
+                raw_msg_fallback = base_record_for_formatter.message_fmt ..
+                    " (formatting args failed: " .. tostring(err) .. ")"
+            end)
 
         return string.format(
             "%s %s [%s] %s:%s - %s (FORMATTER ERROR: %s)",                                   -- Changed %d to %s for lineno
@@ -36,22 +40,22 @@ local function call_formatter(formatter_func, base_record_for_formatter)
     return result
 end
 
---- Safely calls the output function.
--- @param output_func The output function.
--- @param record_for_output The record for the output.
--- @param output_config Configuration specific to this output instance.
-local function call_output(output_func, record_for_output, output_config)
-    local ok, err = pcall(output_func, record_for_output, output_config)
+--- Safely calls the dispatcher function.
+-- @param dispatcher_func The dispatcher function.
+-- @param record_for_dispatcher The record for the dispatcher.
+-- @param dispatcher_config Configuration specific to this dispatcher instance.
+local function call_dispatcher(dispatcher_func, record_for_dispatcher, dispatcher_config)
+    local ok, err = pcall(dispatcher_func, record_for_dispatcher, dispatcher_config)
     if not ok then
         io.stderr:write(string.format(
-            "Logging system error: Output for logger '%s' failed: %s\n",
-            tostring(record_for_output.logger_name), tostring(err) -- Added tostring for safety
+            "Logging system error: dispatcher for logger '%s' failed: %s\n",
+            tostring(record_for_dispatcher.logger_name), tostring(err) -- Added tostring for safety
         ))
     end
 end
 
 --- Main dispatch function that processes a log event.
--- It retrieves all effective outputs from the source logger and processes them.
+-- It retrieves all effective dispatchers from the source logger and processes them.
 -- @param log_record (table) The log event details. Expected fields:
 --        source_logger_name (string), level_no (number), level_name (string),
 --        message_fmt (string), args (table, packed), context (table, optional),
@@ -61,7 +65,7 @@ end
 function ingest.dispatch_log_event(log_record, logger_func, _log_levels) -- Renamed log_levels to _log_levels
     if not log_record or not log_record.source_logger_name then
         io.stderr:write(
-        "Logging system error: dispatch_log_event called with invalid log_record or missing source_logger_name.\n")
+            "Logging system error: dispatch_log_event called with invalid log_record or missing source_logger_name.\n")
         if log_record and log_record.message_fmt then -- Add more context if possible
             io.stderr:write("Log record contents: message_fmt=" .. tostring(log_record.message_fmt) .. "\n")
         end
@@ -79,55 +83,55 @@ function ingest.dispatch_log_event(log_record, logger_func, _log_levels) -- Rena
         return
     end
 
-    -- The source_logger:get_effective_outputs() method is responsible for collecting
-    -- all relevant outputs according to propagation rules and individual logger levels.
-    -- It should return a list of output entries, where each entry includes
-    -- the output_func, formatter_func, output_config, owner_logger_name, and owner_logger_level.
-    local effective_outputs = source_logger:get_effective_outputs()
+    -- The source_logger:get_effective_dispatchers() method is responsible for collecting
+    -- all relevant dispatchers according to propagation rules and individual logger levels.
+    -- It should return a list of dispatcher entries, where each entry includes
+    -- the dispatcher_func, formatter_func, dispatcher_config, owner_logger_name, and owner_logger_level.
+    local effective_dispatchers = source_logger:get_effective_dispatchers()
 
-    for _, output_entry in ipairs(effective_outputs) do
-        --[[ Expected output_entry structure from get_effective_outputs:
+    for _, dispatcher_entry in ipairs(effective_dispatchers) do
+        --[[ Expected dispatcher_entry structure from get_effective_dispatchers:
         {
-          output_func = h.output_func,
+          dispatcher_func = h.dispatcher_func,
           formatter_func = h.formatter_func,
-          output_config = h.output_config,
-          owner_logger_name = logger_that_owns_this_output.name,
-          owner_logger_level = logger_that_owns_this_output.level
+          dispatcher_config = h.dispatcher_config,
+          owner_logger_name = logger_that_owns_this_dispatcher.name,
+          owner_logger_level = logger_that_owns_this_dispatcher.level
         }
         --]]
 
-        -- Process only if the log record's level is sufficient for THIS output's owning logger's level.
-        if log_record.level_no >= output_entry.owner_logger_level then
-            -- Construct base record for the formatter, specific to this output's owning logger context
+        -- Process only if the log record's level is sufficient for THIS dispatcher's owning logger's level.
+        if log_record.level_no >= dispatcher_entry.owner_logger_level then
+            -- Construct base record for the formatter, specific to this dispatcher's owning logger context
             local base_record_for_formatter = {
                 level_name         = log_record.level_name,
                 level_no           = log_record.level_no,
-                logger_name        = output_entry.owner_logger_name, -- Use the output's owner logger name
+                logger_name        = dispatcher_entry.owner_logger_name, -- Use the dispatcher's owner logger name
                 message_fmt        = log_record.message_fmt,
-                args               = log_record.args,           -- args are already packed by logger:log
-                context            = log_record.context,        -- Pass context to formatter
+                args               = log_record.args,                    -- args are already packed by logger:log
+                context            = log_record.context,                 -- Pass context to formatter
                 timestamp          = log_record.timestamp,
                 filename           = log_record.filename,
                 lineno             = log_record.lineno,
                 source_logger_name = log_record.source_logger_name -- Original emitter
             }
-            local formatted_message = call_formatter(output_entry.formatter_func, base_record_for_formatter)
+            local formatted_message = call_formatter(dispatcher_entry.formatter_func, base_record_for_formatter)
 
-            -- Construct record for the output itself
-            local record_for_output = {
+            -- Construct record for the dispatcher itself
+            local record_for_dispatcher = {
                 level_name         = log_record.level_name,
                 level_no           = log_record.level_no,
-                logger_name        = output_entry.owner_logger_name, -- Use the output's owner logger name
-                message            = formatted_message,            -- The fully formatted message string
+                logger_name        = dispatcher_entry.owner_logger_name, -- Use the dispatcher's owner logger name
+                message            = formatted_message,                  -- The fully formatted message string
                 timestamp          = log_record.timestamp,
                 filename           = log_record.filename,
                 lineno             = log_record.lineno,
                 raw_message_fmt    = log_record.message_fmt,       -- Original format string
                 raw_args           = log_record.args,              -- Original variadic arguments
-                context            = log_record.context,           -- Pass context to output
+                context            = log_record.context,           -- Pass context to dispatcher
                 source_logger_name = log_record.source_logger_name -- Original emitter
             }
-            call_output(output_entry.output_func, record_for_output, output_entry.output_config)
+            call_dispatcher(dispatcher_entry.dispatcher_func, record_for_dispatcher, dispatcher_entry.dispatcher_config)
         end
     end
 end
diff --git a/lua/lual/logger.lua b/lua/lual/logger.lua
index 8c97ea1..7fe9e3a 100644
--- a/lua/lual/logger.lua
+++ b/lua/lual/logger.lua
@@ -12,21 +12,21 @@ local log = {}
 
 local core_levels = require("lual.core.levels")
 local engine = require("lual.core.logging")
-local all_outputs = require("lual.outputs.init")       -- Require the new outputs init
-local all_formatters = require("lual.formatters.init") -- Require the new formatters init
+local all_dispatchers = require("lual.dispatchers.init") -- Require the new dispatchers init
+local all_formatters = require("lual.formatters.init")   -- Require the new formatters init
 
 log.levels = core_levels.definition
-log.logger = engine.logger      -- Primary API for creating loggers
-log.logger = engine.logger      -- Backward compatibility alias
-log.outputs = all_outputs       -- Assign the outputs table
-log.formatters = all_formatters -- Assign the formatters table
+log.logger = engine.logger        -- Primary API for creating loggers
+log.logger = engine.logger        -- Backward compatibility alias
+log.dispatchers = all_dispatchers -- Assign the dispatchers table
+log.formatters = all_formatters   -- Assign the formatters table
 
--- Add convenient shortcuts for outputs and formatters
+-- Add convenient shortcuts for dispatchers and formatters
 log.lib = {
-  -- Output shortcuts
-  console = all_outputs.console_output,
-  file = all_outputs.file_output,
-  syslog = all_outputs.syslog_output,
+  -- dispatcher shortcuts
+  console = all_dispatchers.console_dispatcher,
+  file = all_dispatchers.file_dispatcher,
+  syslog = all_dispatchers.syslog_dispatcher,
 
   -- Formatter shortcuts (call factories with default config for backward compatibility)
   text = all_formatters.text(),
@@ -69,10 +69,10 @@ function log.reset_config()
 end
 
 -- =============================================================================
--- 4. Output Definitions (Function Signatures) - REMOVED
+-- 4. dispatcher Definitions (Function Signatures) - REMOVED
 -- =============================================================================
--- log.outputs = {} -- This line is removed
--- All function log.outputs.console_output(...) etc. are removed.
+-- log.dispatchers = {} -- This line is removed
+-- All function log.dispatchers.console_dispatcher(...) etc. are removed.
 
 -- =============================================================================
 -- 5. Formatter Definitions (Function Signatures) - REMOVED
@@ -86,13 +86,13 @@ end
 function log.init_default_config()
   local root_logger = log.logger("root")
   if root_logger then
-    root_logger.outputs = {} -- Clear existing default outputs
+    root_logger.dispatchers = {} -- Clear existing default dispatchers
     if root_logger.set_level then
       root_logger:set_level(log.levels.INFO)
     end
-    if root_logger.add_output and log.outputs and log.outputs.console_output and log.formatters and log.formatters.text then
-      root_logger:add_output(
-        log.outputs.console_output,
+    if root_logger.add_dispatcher and log.dispatchers and log.dispatchers.console_dispatcher and log.formatters and log.formatters.text then
+      root_logger:add_dispatcher(
+        log.dispatchers.console_dispatcher,
         log.formatters.text,
         { stream = io.stdout }
       )
diff --git a/lua/lual/outputs/init.lua b/lua/lual/outputs/init.lua
deleted file mode 100644
index 1ce0da1..0000000
--- a/lua/lual/outputs/init.lua
+++ /dev/null
@@ -1,7 +0,0 @@
-local outputs = {}
-
-outputs.console_output = require("lual.outputs.console_output")
-outputs.file_output = require("lual.outputs.file_output")
-outputs.syslog_output = require("lual.outputs.syslog_output")
-
-return outputs
diff --git a/lua/lual/schema/README.md b/lua/lual/schema/README.md
index 5a76907..c5d8c63 100644
--- a/lua/lual/schema/README.md
+++ b/lua/lual/schema/README.md
@@ -26,7 +26,7 @@ local schema = require("lual.schema")
 local config = {
     name = "my.logger",
     level = "info",
-    outputs = {
+    dispatchers = {
         { type = "console", formatter = "text" }
     }
 }
@@ -80,7 +80,7 @@ field_name = {
 ## Available Schemas
 
 - `ConfigSchema`: Main configuration validation
-- `OutputSchema`: Output configuration validation
+- `dispatcherschema`: dispatcher configuration validation
 
 ## Files
 
diff --git a/lua/lual/schema/config_schema.lua b/lua/lual/schema/config_schema.lua
index dc38ca6..c5104c7 100644
--- a/lua/lual/schema/config_schema.lua
+++ b/lua/lual/schema/config_schema.lua
@@ -27,9 +27,9 @@ function M.generate_expected_error(schema_name, field_name, error_type, value)
 
     if error_type == "required" then
         if field_name == "type" then
-            return "Each output must have a 'type' string field"
+            return "Each dispatcher must have a 'type' string field"
         elseif field_name == "formatter" then
-            return "Each output must have a 'formatter' string field"
+            return "Each dispatcher must have a 'formatter' string field"
         else
             return string.format("%s is required", string.gsub(field_name, "^%l", string.upper))
         end
@@ -38,10 +38,10 @@ function M.generate_expected_error(schema_name, field_name, error_type, value)
             return "Config.name must be a string"
         elseif field_name == "propagate" then
             return "Config.propagate must be a boolean"
-        elseif field_name == "outputs" then
-            return "Config.outputs must be a table"
+        elseif field_name == "dispatchers" then
+            return "Config.dispatchers must be a table"
         elseif field_name == "stream" then
-            return "Console output 'stream' field must be a file handle"
+            return "Console dispatcher 'stream' field must be a file handle"
         else
             local type_str = type(field_schema.type) == "table"
                 and table.concat(field_schema.type, " or ")
@@ -58,7 +58,7 @@ function M.generate_expected_error(schema_name, field_name, error_type, value)
             table.sort(valid_values)
 
             if field_name == "type" then
-                return string.format("Invalid output type: %s. Valid values are: %s",
+                return string.format("Invalid dispatcher type: %s. Valid values are: %s",
                     tostring(value), table.concat(valid_values, ", "))
             elseif field_name == "formatter" then
                 return string.format("Invalid formatter type: %s. Valid values are: %s",
@@ -70,7 +70,7 @@ function M.generate_expected_error(schema_name, field_name, error_type, value)
         end
     elseif error_type == "conditional" then
         if field_name == "path" then
-            return "File output must have a 'path' string field"
+            return "File dispatcher must have a 'path' string field"
         end
     elseif error_type == "unknown" then
         return "Unknown config key: " .. field_name
@@ -111,23 +111,23 @@ M.ConfigSchema = {
         description = "The timezone to use for timestamps."
     },
 
-    outputs = {
+    dispatchers = {
         multiple = true,
         type = "table",
         required = false,
-        description = "Array of output configurations.",
-        schema = "OutputSchema" -- Reference to another schema
+        description = "Array of dispatcher configurations.",
+        schema = "dispatcherschema" -- Reference to another schema
     }
 }
 
--- Output schema definition
-M.OutputSchema = {
+-- dispatcher schema definition
+M.dispatcherschema = {
     type = {
         multiple = false,
         type = "string",
-        values = extract_valid_values(constants.VALID_OUTPUT_TYPES),
+        values = extract_valid_values(constants.VALID_dispatcher_TYPES),
         required = true,
-        description = "The type of output (console or file)."
+        description = "The type of dispatcher (console or file)."
     },
 
     formatter = {
@@ -135,14 +135,14 @@ M.OutputSchema = {
         type = "string",
         values = extract_valid_values(constants.VALID_FORMATTER_TYPES),
         required = true,
-        description = "The formatter type to use for this output."
+        description = "The formatter type to use for this dispatcher."
     },
 
     path = {
         multiple = false,
         type = "string",
         required = false,
-        description = "File path for file outputs.",
+        description = "File path for file dispatchers.",
         conditional = {
             field = "type",
             value = "file",
@@ -154,7 +154,7 @@ M.OutputSchema = {
         multiple = false,
         type = "userdata", -- file handle
         required = false,
-        description = "Stream for console outputs."
+        description = "Stream for console dispatchers."
     }
 }
 
@@ -190,12 +190,12 @@ M.ShortcutSchema = {
         description = "The timezone to use for timestamps."
     },
 
-    output = {
+    dispatcher = {
         multiple = false,
         type = "string",
-        values = extract_valid_values(constants.VALID_OUTPUT_TYPES),
+        values = extract_valid_values(constants.VALID_dispatcher_TYPES),
         required = true,
-        description = "The type of output (console or file)."
+        description = "The type of dispatcher (console or file)."
     },
 
     formatter = {
@@ -203,16 +203,16 @@ M.ShortcutSchema = {
         type = "string",
         values = extract_valid_values(constants.VALID_FORMATTER_TYPES),
         required = true,
-        description = "The formatter type to use for this output."
+        description = "The formatter type to use for this dispatcher."
     },
 
     path = {
         multiple = false,
         type = "string",
         required = false,
-        description = "File path for file outputs.",
+        description = "File path for file dispatchers.",
         conditional = {
-            field = "output",
+            field = "dispatcher",
             value = "file",
             required = true
         }
@@ -222,7 +222,7 @@ M.ShortcutSchema = {
         multiple = false,
         type = "userdata", -- file handle
         required = false,
-        description = "Stream for console outputs."
+        description = "Stream for console dispatchers."
     }
 }
 
diff --git a/lua/lual/schema/init.lua b/lua/lual/schema/init.lua
index d613f6a..d9faffa 100644
--- a/lua/lual/schema/init.lua
+++ b/lua/lual/schema/init.lua
@@ -9,7 +9,7 @@ local M = {}
 -- Schema registry
 local schema_registry = {
     ConfigSchema = config_schema.ConfigSchema,
-    OutputSchema = config_schema.OutputSchema,
+    dispatcherschema = config_schema.dispatcherschema,
     ShortcutSchema = config_schema.ShortcutSchema
 }
 
@@ -20,11 +20,11 @@ function M.validate_config(data)
     return validator.validate(data, schema_registry.ConfigSchema, schema_registry)
 end
 
---- Validate output data
--- @param data table The output data to validate
+--- Validate dispatcher data
+-- @param data table The dispatcher data to validate
 -- @return table Result with data and _errors keys
-function M.validate_output(data)
-    return validator.validate(data, schema_registry.OutputSchema, schema_registry)
+function M.validate_dispatcher(data)
+    return validator.validate(data, schema_registry.dispatcherschema, schema_registry)
 end
 
 --- Validate shortcut config data
diff --git a/lua/lual/schema/validator.lua b/lua/lual/schema/validator.lua
index 2ebd840..4e1c963 100644
--- a/lua/lual/schema/validator.lua
+++ b/lua/lual/schema/validator.lua
@@ -22,8 +22,8 @@ local function generate_error_message(field_name, value, field_schema)
         if type(value) ~= "string" then
             if field_name == "level" then
                 return "Level must be a string or number"
-            elseif field_name == "output" then -- For shortcut API
-                return "Output type must be a string"
+            elseif field_name == "dispatcher" then -- For shortcut API
+                return "dispatcher type must be a string"
             elseif field_name == "formatter" then
                 return "Formatter type must be a string"
             end
@@ -31,10 +31,10 @@ local function generate_error_message(field_name, value, field_schema)
 
         -- Generate more specific error messages for certain fields
         if field_name == "type" then
-            return string.format("Invalid output type: %s. Valid values are: %s",
+            return string.format("Invalid dispatcher type: %s. Valid values are: %s",
                 tostring(value), table.concat(valid_values, ", "))
-        elseif field_name == "output" then -- For shortcut API
-            return string.format("Invalid output type: %s. Valid values are: %s",
+        elseif field_name == "dispatcher" then -- For shortcut API
+            return string.format("Invalid dispatcher type: %s. Valid values are: %s",
                 tostring(value), table.concat(valid_values, ", "))
         elseif field_name == "formatter" then
             return string.format("Invalid formatter type: %s. Valid values are: %s",
@@ -53,12 +53,12 @@ local function generate_error_message(field_name, value, field_schema)
             return "Config.name must be a string"
         elseif field_name == "propagate" then
             return "Config.propagate must be a boolean"
-        elseif field_name == "outputs" then
-            return "Config.outputs must be a table"
+        elseif field_name == "dispatchers" then
+            return "Config.dispatchers must be a table"
         elseif field_name == "stream" then
-            return "Console output 'stream' field must be a file handle"
+            return "Console dispatcher 'stream' field must be a file handle"
         elseif field_name == "path" then
-            return "File output must have a 'path' string field"
+            return "File dispatcher must have a 'path' string field"
         else
             return string.format("%s must be a %s",
                 string.gsub(field_name, "^%l", string.upper), type_str)
@@ -81,14 +81,14 @@ local function validate_field(field_name, value, field_schema, data, is_shortcut
         if field_schema.required then
             -- Generate specific required field messages
             if field_name == "type" then
-                return false, "Each output must have a 'type' string field"
-            elseif field_name == "output" then -- For shortcut API
-                return false, "Shortcut config must have an 'output' field"
+                return false, "Each dispatcher must have a 'type' string field"
+            elseif field_name == "dispatcher" then -- For shortcut API
+                return false, "Shortcut config must have an 'dispatcher' field"
             elseif field_name == "formatter" then
                 if is_shortcut then
                     return false, "Shortcut config must have a 'formatter' field"
                 else
-                    return false, "Each output must have a 'formatter' string field"
+                    return false, "Each dispatcher must have a 'formatter' string field"
                 end
             else
                 return false, string.format("%s is required", string.gsub(field_name, "^%l", string.upper))
@@ -99,7 +99,7 @@ local function validate_field(field_name, value, field_schema, data, is_shortcut
             local cond = field_schema.conditional
             if data[cond.field] == cond.value and cond.required then
                 if field_name == "path" then
-                    return false, "File output must have a 'path' string field"
+                    return false, "File dispatcher must have a 'path' string field"
                 else
                     return false, string.format("%s is required when %s is %s",
                         string.gsub(field_name, "^%l", string.upper), cond.field, cond.value)
diff --git a/lual-0.7.1-1.rockspec b/lual-0.7.1-1.rockspec
index 5cad672..80eff82 100644
--- a/lual-0.7.1-1.rockspec
+++ b/lual-0.7.1-1.rockspec
@@ -7,7 +7,7 @@ source = {
 description = {
    summary = "A focused but powerful and flexible logging library for Lua.",
    detailed = [[
-      lual is a logging library inspired by Python's stdlib and loguru loggers. It provides hierarchical logging with propagation, multiple output handlers (console, file, syslog), various formatters (text, color, JSON), and both imperative and declarative APIs. Designed with Lua's strengths in mind using functions and tables.
+      lual is a logging library inspired by Python's stdlib and loguru loggers. It provides hierarchical logging with propagation, multiple dispatcher handlers (console, file, syslog), various formatters (text, color, JSON), and both imperative and declarative APIs. Designed with Lua's strengths in mind using functions and tables.
    ]],
    homepage = "https://github.com/arthur-debert/lual",
    license = "MIT"
diff --git a/spec/core/engine_spec.lua b/spec/core/engine_spec.lua
index 9c06a74..548dcce 100644
--- a/spec/core/engine_spec.lua
+++ b/spec/core/engine_spec.lua
@@ -181,95 +181,96 @@ describe("lual.core.logging", function()
 		test_log_method("error", C_LEVELS_DEF.ERROR, "ERROR", C_LEVELS_DEF)
 		test_log_method("critical", C_LEVELS_DEF.CRITICAL, "CRITICAL", C_LEVELS_DEF)
 
-		it("logger:add_output(output_func, formatter_func, output_config) should add output correctly", function()
-			local mock_output_fn = function() end
-			local mock_formatter_fn = function() end
-			local mock_cfg = { type = "test" }
-
-			test_logger:add_output(mock_output_fn, mock_formatter_fn, mock_cfg)
-			assert.are.same(1, #test_logger.outputs)
-			local entry = test_logger.outputs[1]
-			assert.are.same(mock_output_fn, entry.output_func)
-			assert.are.same(mock_formatter_fn, entry.formatter_func)
-			assert.are.same(mock_cfg, entry.output_config)
-
-			test_logger:add_output(mock_output_fn, mock_formatter_fn, nil)
-			assert.are.same(2, #test_logger.outputs)
-			local entry_nil_config = test_logger.outputs[2]
-			assert.is_table(entry_nil_config.output_config)
-			assert.are.same(0, #entry_nil_config.output_config)
-		end)
+		it("logger:add_dispatcher(dispatcher_func, formatter_func, dispatcher_config) should add dispatcher correctly",
+			function()
+				local mock_dispatcher_fn = function() end
+				local mock_formatter_fn = function() end
+				local mock_cfg = { type = "test" }
+
+				test_logger:add_dispatcher(mock_dispatcher_fn, mock_formatter_fn, mock_cfg)
+				assert.are.same(1, #test_logger.dispatchers)
+				local entry = test_logger.dispatchers[1]
+				assert.are.same(mock_dispatcher_fn, entry.dispatcher_func)
+				assert.are.same(mock_formatter_fn, entry.formatter_func)
+				assert.are.same(mock_cfg, entry.dispatcher_config)
+
+				test_logger:add_dispatcher(mock_dispatcher_fn, mock_formatter_fn, nil)
+				assert.are.same(2, #test_logger.dispatchers)
+				local entry_nil_config = test_logger.dispatchers[2]
+				assert.is_table(entry_nil_config.dispatcher_config)
+				assert.are.same(0, #entry_nil_config.dispatcher_config)
+			end)
 
-		describe("logger:get_effective_outputs()", function()
-			local test_cl_module_for_outputs
-			local test_clevels_module_for_outputs
+		describe("logger:get_effective_dispatchers()", function()
+			local test_cl_module_for_dispatchers
+			local test_clevels_module_for_dispatchers
 			local logger_root, logger_p, logger_c
 
 			before_each(function()
 				package.loaded["lual.core.logging"] = nil
 				package.loaded["lual.core.levels"] = nil
-				test_cl_module_for_outputs = require("lual.core.logging")
-				test_clevels_module_for_outputs = require("lual.core.levels")
-				test_cl_module_for_outputs.reset_cache()
+				test_cl_module_for_dispatchers = require("lual.core.logging")
+				test_clevels_module_for_dispatchers = require("lual.core.levels")
+				test_cl_module_for_dispatchers.reset_cache()
 
-				logger_root = test_cl_module_for_outputs.logger("eff_root")
-				logger_p = test_cl_module_for_outputs.logger("eff_root.p")
-				logger_c = test_cl_module_for_outputs.logger("eff_root.p.c")
+				logger_root = test_cl_module_for_dispatchers.logger("eff_root")
+				logger_p = test_cl_module_for_dispatchers.logger("eff_root.p")
+				logger_c = test_cl_module_for_dispatchers.logger("eff_root.p.c")
 
-				logger_root.outputs = {} -- Clear any default outputs on eff_root itself
-				logger_p.outputs = {}
-				logger_c.outputs = {}
+				logger_root.dispatchers = {} -- Clear any default dispatchers on eff_root itself
+				logger_p.dispatchers = {}
+				logger_c.dispatchers = {}
 
-				logger_root.level = test_clevels_module_for_outputs.definition.DEBUG
-				logger_p.level = test_clevels_module_for_outputs.definition.DEBUG
-				logger_c.level = test_clevels_module_for_outputs.definition.DEBUG
+				logger_root.level = test_clevels_module_for_dispatchers.definition.DEBUG
+				logger_p.level = test_clevels_module_for_dispatchers.definition.DEBUG
+				logger_c.level = test_clevels_module_for_dispatchers.definition.DEBUG
 				logger_root.propagate = true
 				logger_p.propagate = true
 				logger_c.propagate = true
 
-				-- Crucially, ensure the canonical "root" logger (parent of eff_root) also has clean outputs for this test
-				local canonical_root = test_cl_module_for_outputs.logger("root")
+				-- Crucially, ensure the canonical "root" logger (parent of eff_root) also has clean dispatchers for this test
+				local canonical_root = test_cl_module_for_dispatchers.logger("root")
 				if canonical_root then
-					canonical_root.outputs = {}
+					canonical_root.dispatchers = {}
 				end
 			end)
 
 			local mock_h_fn = function() end
 			local mock_f_fn = function() end
 
-			it("should collect outputs from self and propagating parents (clean root)", function()
-				logger_c:add_output(mock_h_fn, mock_f_fn, { id = "hc" })
-				logger_p:add_output(mock_h_fn, mock_f_fn, { id = "hp" })
-				logger_root:add_output(mock_h_fn, mock_f_fn, { id = "h_eff_root" })
+			it("should collect dispatchers from self and propagating parents (clean root)", function()
+				logger_c:add_dispatcher(mock_h_fn, mock_f_fn, { id = "hc" })
+				logger_p:add_dispatcher(mock_h_fn, mock_f_fn, { id = "hp" })
+				logger_root:add_dispatcher(mock_h_fn, mock_f_fn, { id = "h_eff_root" })
 
-				local c_outputs = logger_c:get_effective_outputs()
-				assert.are.same(3, #c_outputs)
-				assert.are.same("eff_root.p.c", c_outputs[1].owner_logger_name)
-				assert.are.same("eff_root.p", c_outputs[2].owner_logger_name)
-				assert.are.same("eff_root", c_outputs[3].owner_logger_name)
+				local c_dispatchers = logger_c:get_effective_dispatchers()
+				assert.are.same(3, #c_dispatchers)
+				assert.are.same("eff_root.p.c", c_dispatchers[1].owner_logger_name)
+				assert.are.same("eff_root.p", c_dispatchers[2].owner_logger_name)
+				assert.are.same("eff_root", c_dispatchers[3].owner_logger_name)
 			end)
 
 			it("should stop collecting if propagate is false on child", function()
-				logger_c:add_output(mock_h_fn, mock_f_fn, { id = "hc" })
-				logger_p:add_output(mock_h_fn, mock_f_fn, { id = "hp" })
-				logger_root:add_output(mock_h_fn, mock_f_fn, { id = "h_eff_root" })
+				logger_c:add_dispatcher(mock_h_fn, mock_f_fn, { id = "hc" })
+				logger_p:add_dispatcher(mock_h_fn, mock_f_fn, { id = "hp" })
+				logger_root:add_dispatcher(mock_h_fn, mock_f_fn, { id = "h_eff_root" })
 
 				logger_c.propagate = false
-				local c_outputs = logger_c:get_effective_outputs()
-				assert.are.same(1, #c_outputs)
-				assert.are.same("eff_root.p.c", c_outputs[1].owner_logger_name)
+				local c_dispatchers = logger_c:get_effective_dispatchers()
+				assert.are.same(1, #c_dispatchers)
+				assert.are.same("eff_root.p.c", c_dispatchers[1].owner_logger_name)
 			end)
 
 			it("should stop collecting if propagate is false on parent", function()
-				logger_c:add_output(mock_h_fn, mock_f_fn, { id = "hc" })
-				logger_p:add_output(mock_h_fn, mock_f_fn, { id = "hp" })
-				logger_root:add_output(mock_h_fn, mock_f_fn, { id = "h_eff_root" })
+				logger_c:add_dispatcher(mock_h_fn, mock_f_fn, { id = "hc" })
+				logger_p:add_dispatcher(mock_h_fn, mock_f_fn, { id = "hp" })
+				logger_root:add_dispatcher(mock_h_fn, mock_f_fn, { id = "h_eff_root" })
 
 				logger_p.propagate = false
-				local c_outputs = logger_c:get_effective_outputs()
-				assert.are.same(2, #c_outputs)
-				assert.are.same("eff_root.p.c", c_outputs[1].owner_logger_name)
-				assert.are.same("eff_root.p", c_outputs[2].owner_logger_name)
+				local c_dispatchers = logger_c:get_effective_dispatchers()
+				assert.are.same(2, #c_dispatchers)
+				assert.are.same("eff_root.p.c", c_dispatchers[1].owner_logger_name)
+				assert.are.same("eff_root.p", c_dispatchers[2].owner_logger_name)
 			end)
 		end)
 	end)
diff --git a/spec/declarative_api_spec.lua b/spec/declarative_api_spec.lua
index e4443c7..8d23143 100644
--- a/spec/declarative_api_spec.lua
+++ b/spec/declarative_api_spec.lua
@@ -39,7 +39,7 @@ describe("Declarative API", function()
             assert.are.same("test.minimal", logger.name)
             assert.are.same(lualog.levels.INFO, logger.level) -- Default level
             assert.is_true(logger.propagate)                  -- Default propagate
-            assert.are.same(0, #logger.outputs)               -- No outputs by default
+            assert.are.same(0, #logger.dispatchers)           -- No dispatchers by default
         end)
 
         it("should create a logger with full config", function()
@@ -47,7 +47,7 @@ describe("Declarative API", function()
                 name = "test.full",
                 level = "debug",
                 propagate = false,
-                outputs = {
+                dispatchers = {
                     { type = "console", formatter = "text" },
                     { type = "file",    path = "test.log", formatter = "color" }
                 }
@@ -57,33 +57,33 @@ describe("Declarative API", function()
             assert.are.same("test.full", logger.name)
             assert.are.same(lualog.levels.DEBUG, logger.level)
             assert.is_false(logger.propagate)
-            assert.are.same(2, #logger.outputs)
+            assert.are.same(2, #logger.dispatchers)
 
-            -- Check first output (console)
-            local console_output = logger.outputs[1]
-            assert.is_function(console_output.output_func)
-            assert.is_true(is_callable(console_output.formatter_func))
-            assert.is_table(console_output.output_config)
+            -- Check first dispatcher (console)
+            local console_dispatcher = logger.dispatchers[1]
+            assert.is_function(console_dispatcher.dispatcher_func)
+            assert.is_true(is_callable(console_dispatcher.formatter_func))
+            assert.is_table(console_dispatcher.dispatcher_config)
 
-            -- Check second output (file)
-            local file_output = logger.outputs[2]
-            assert.is_function(file_output.output_func)
-            assert.is_true(is_callable(file_output.formatter_func))
-            assert.is_table(file_output.output_config)
-            assert.are.same("test.log", file_output.output_config.path)
+            -- Check second dispatcher (file)
+            local file_dispatcher = logger.dispatchers[2]
+            assert.is_function(file_dispatcher.dispatcher_func)
+            assert.is_true(is_callable(file_dispatcher.formatter_func))
+            assert.is_table(file_dispatcher.dispatcher_config)
+            assert.are.same("test.log", file_dispatcher.dispatcher_config.path)
         end)
 
         it("should merge user config with defaults", function()
             local logger = lualog.logger({
                 name = "test.merge",
                 level = "error"
-                -- propagate and outputs should use defaults
+                -- propagate and dispatchers should use defaults
             })
 
             assert.are.same("test.merge", logger.name)
             assert.are.same(lualog.levels.ERROR, logger.level)
-            assert.is_true(logger.propagate)    -- Default
-            assert.are.same(0, #logger.outputs) -- Default empty
+            assert.is_true(logger.propagate)        -- Default
+            assert.are.same(0, #logger.dispatchers) -- Default empty
         end)
 
         it("should create parent loggers automatically", function()
@@ -143,97 +143,98 @@ describe("Declarative API", function()
         end)
     end)
 
-    describe("Output configuration", function()
-        it("should configure console output correctly", function()
+    describe("dispatcher configuration", function()
+        it("should configure console dispatcher correctly", function()
             local logger = lualog.logger({
                 name = "test.console",
-                outputs = {
+                dispatchers = {
                     { type = "console", formatter = "text" }
                 }
             })
 
-            assert.are.same(1, #logger.outputs)
-            local output = logger.outputs[1]
-            assert.is_function(output.output_func)
-            assert.is_true(is_callable(output.formatter_func))
+            assert.are.same(1, #logger.dispatchers)
+            local dispatcher = logger.dispatchers[1]
+            assert.is_function(dispatcher.dispatcher_func)
+            assert.is_true(is_callable(dispatcher.formatter_func))
             -- Default console config should be empty (uses io.stdout by default)
-            assert.is_table(output.output_config)
+            assert.is_table(dispatcher.dispatcher_config)
         end)
 
-        it("should configure console output with custom stream", function()
+        it("should configure console dispatcher with custom stream", function()
             local logger = lualog.logger({
                 name = "test.console.stderr",
-                outputs = {
+                dispatchers = {
                     { type = "console", formatter = "text", stream = io.stderr }
                 }
             })
 
-            assert.are.same(1, #logger.outputs)
-            local output = logger.outputs[1]
-            assert.are.same(io.stderr, output.output_config.stream)
+            assert.are.same(1, #logger.dispatchers)
+            local dispatcher = logger.dispatchers[1]
+            assert.are.same(io.stderr, dispatcher.dispatcher_config.stream)
         end)
 
-        it("should configure file output correctly", function()
+        it("should configure file dispatcher correctly", function()
             local logger = lualog.logger({
                 name = "test.file",
-                outputs = {
+                dispatchers = {
                     { type = "file", path = "app.log", formatter = "color" }
                 }
             })
 
-            assert.are.same(1, #logger.outputs)
-            local output = logger.outputs[1]
-            assert.is_function(output.output_func)
-            assert.is_true(is_callable(output.formatter_func))
-            assert.are.same("app.log", output.output_config.path)
+            assert.are.same(1, #logger.dispatchers)
+            local dispatcher = logger.dispatchers[1]
+            assert.is_function(dispatcher.dispatcher_func)
+            assert.is_true(is_callable(dispatcher.formatter_func))
+            assert.are.same("app.log", dispatcher.dispatcher_config.path)
         end)
 
-        it("should support multiple outputs", function()
+        it("should support multiple dispatchers", function()
             local logger = lualog.logger({
                 name = "test.multiple",
-                outputs = {
+                dispatchers = {
                     { type = "console", formatter = "color" },
                     { type = "file",    path = "debug.log", formatter = "text" },
                     { type = "console", formatter = "text", stream = io.stderr }
                 }
             })
 
-            assert.are.same(3, #logger.outputs)
+            assert.are.same(3, #logger.dispatchers)
 
-            -- Check that each output is properly configured
-            for i, output in ipairs(logger.outputs) do
-                assert.is_function(output.output_func, "Output " .. i .. " missing output_func")
-                assert.is_true(is_callable(output.formatter_func), "Output " .. i .. " missing formatter_func")
-                assert.is_table(output.output_config, "Output " .. i .. " missing output_config")
+            -- Check that each dispatcher is properly configured
+            for i, dispatcher in ipairs(logger.dispatchers) do
+                assert.is_function(dispatcher.dispatcher_func, "dispatcher " .. i .. " missing dispatcher_func")
+                assert.is_true(is_callable(dispatcher.formatter_func), "dispatcher " .. i .. " missing formatter_func")
+                assert.is_table(dispatcher.dispatcher_config, "dispatcher " .. i .. " missing dispatcher_config")
             end
 
-            -- Check file output has path
-            assert.are.same("debug.log", logger.outputs[2].output_config.path)
+            -- Check file dispatcher has path
+            assert.are.same("debug.log", logger.dispatchers[2].dispatcher_config.path)
             -- Check stderr console has stream
-            assert.are.same(io.stderr, logger.outputs[3].output_config.stream)
+            assert.are.same(io.stderr, logger.dispatchers[3].dispatcher_config.stream)
         end)
 
         it("should configure JSON formatter correctly", function()
             local logger = lualog.logger({
                 name = "test.json",
-                outputs = {
+                dispatchers = {
                     { type = "console", formatter = "json" },
                     { type = "file",    path = "app.json", formatter = "json" }
                 }
             })
 
-            assert.are.same(2, #logger.outputs)
+            assert.are.same(2, #logger.dispatchers)
 
-            -- Check that both outputs are properly configured with JSON formatter
-            for i, output in ipairs(logger.outputs) do
-                assert.is_function(output.output_func, "Output " .. i .. " missing output_func")
-                assert.is_true(is_callable(output.formatter_func), "Output " .. i .. " missing formatter_func")
-                assert.are.same(lualog.lib.json, output.formatter_func, "Output " .. i .. " should use JSON formatter")
-                assert.is_table(output.output_config, "Output " .. i .. " missing output_config")
+            -- Check that both dispatchers are properly configured with JSON formatter
+            for i, dispatcher in ipairs(logger.dispatchers) do
+                assert.is_function(dispatcher.dispatcher_func, "dispatcher " .. i .. " missing dispatcher_func")
+                assert.is_true(is_callable(dispatcher.formatter_func), "dispatcher " .. i .. " missing formatter_func")
+                assert.are.same(lualog.lib.json, dispatcher.formatter_func,
+                    "dispatcher " .. i .. " should use JSON formatter")
+                assert.is_table(dispatcher.dispatcher_config, "dispatcher " .. i .. " missing dispatcher_config")
             end
 
-            -- Check file output has path
-            assert.are.same("app.json", logger.outputs[2].output_config.path)
+            -- Check file dispatcher has path
+            assert.are.same("app.json", logger.dispatchers[2].dispatcher_config.path)
         end)
     end)
 
@@ -299,44 +300,44 @@ describe("Declarative API", function()
             end, "Invalid declarative config: Config.propagate must be a boolean")
         end)
 
-        it("should reject invalid outputs type", function()
+        it("should reject invalid dispatchers type", function()
             assert.has_error(function()
                 lualog.logger({
                     name = "test",
-                    outputs = "not an array"
+                    dispatchers = "not an array"
                 })
-            end, "Invalid declarative config: Config.outputs must be a table")
+            end, "Invalid declarative config: Config.dispatchers must be a table")
         end)
 
-        it("should reject outputs without type field", function()
+        it("should reject dispatchers without type field", function()
             assert.has_error(function()
                 lualog.logger({
                     name = "test",
-                    outputs = {
+                    dispatchers = {
                         { formatter = "text" }
                     }
                 })
-            end, "Invalid declarative config: Each output must have a 'type' string field")
+            end, "Invalid declarative config: Each dispatcher must have a 'type' string field")
         end)
 
-        it("should reject outputs without formatter field", function()
+        it("should reject dispatchers without formatter field", function()
             assert.has_error(function()
                 lualog.logger({
                     name = "test",
-                    outputs = {
+                    dispatchers = {
                         { type = "console" }
                     }
                 })
-            end, "Invalid declarative config: Each output must have a 'formatter' string field")
+            end, "Invalid declarative config: Each dispatcher must have a 'formatter' string field")
         end)
 
-        it("should reject unknown output types", function()
+        it("should reject unknown dispatcher types", function()
             local expected_error = "Invalid declarative config: " ..
-                constants.generate_expected_error_message("unknown", constants.VALID_OUTPUT_TYPES)
+                constants.generate_expected_error_message("unknown", constants.VALID_dispatcher_TYPES)
             assert.has_error(function()
                 lualog.logger({
                     name = "test",
-                    outputs = {
+                    dispatchers = {
                         { type = "unknown", formatter = "text" }
                     }
                 })
@@ -349,44 +350,44 @@ describe("Declarative API", function()
             assert.has_error(function()
                 lualog.logger({
                     name = "test",
-                    outputs = {
+                    dispatchers = {
                         { type = "console", formatter = "unknown" }
                     }
                 })
             end, expected_error)
         end)
 
-        it("should reject file output without path", function()
+        it("should reject file dispatcher without path", function()
             assert.has_error(function()
                 lualog.logger({
                     name = "test",
-                    outputs = {
+                    dispatchers = {
                         { type = "file", formatter = "text" }
                     }
                 })
-            end, "Invalid declarative config: File output must have a 'path' string field")
+            end, "Invalid declarative config: File dispatcher must have a 'path' string field")
         end)
 
-        it("should reject file output with non-string path", function()
+        it("should reject file dispatcher with non-string path", function()
             assert.has_error(function()
                 lualog.logger({
                     name = "test",
-                    outputs = {
+                    dispatchers = {
                         { type = "file", formatter = "text", path = 123 }
                     }
                 })
-            end, "Invalid declarative config: File output must have a 'path' string field")
+            end, "Invalid declarative config: File dispatcher must have a 'path' string field")
         end)
 
-        it("should reject console output with invalid stream type", function()
+        it("should reject console dispatcher with invalid stream type", function()
             assert.has_error(function()
                 lualog.logger({
                     name = "test",
-                    outputs = {
+                    dispatchers = {
                         { type = "console", formatter = "text", stream = "stdout" }
                     }
                 })
-            end, "Invalid declarative config: Console output 'stream' field must be a file handle")
+            end, "Invalid declarative config: Console dispatcher 'stream' field must be a file handle")
         end)
     end)
 
@@ -395,7 +396,7 @@ describe("Declarative API", function()
             local logger = lualog.logger({
                 name = "test.integration",
                 level = "debug",
-                outputs = {
+                dispatchers = {
                     { type = "console", formatter = "text" }
                 }
             })
@@ -433,8 +434,8 @@ describe("Declarative API", function()
             logger:set_level(lualog.levels.DEBUG)
             assert.are.same(lualog.levels.DEBUG, logger.level)
 
-            logger:add_output(lualog.lib.console, lualog.lib.text, {})
-            assert.are.same(1, #logger.outputs)
+            logger:add_dispatcher(lualog.lib.console, lualog.lib.text, {})
+            assert.are.same(1, #logger.dispatchers)
 
             logger:set_propagate(false)
             assert.is_false(logger.propagate)
@@ -443,7 +444,7 @@ describe("Declarative API", function()
         it("should work with propagation", function()
             local parent_logger = lualog.logger({
                 name = "test.parent",
-                outputs = {
+                dispatchers = {
                     { type = "console", formatter = "text" }
                 }
             })
@@ -453,31 +454,31 @@ describe("Declarative API", function()
                 propagate = true
             })
 
-            local effective_outputs = child_logger:get_effective_outputs()
-            -- Should include parent's output plus root's default output
-            assert.is_true(#effective_outputs >= 1)
+            local effective_dispatchers = child_logger:get_effective_dispatchers()
+            -- Should include parent's dispatcher plus root's default dispatcher
+            assert.is_true(#effective_dispatchers >= 1)
 
-            -- Check that at least one output comes from parent
-            local found_parent_output = false
-            for _, output in ipairs(effective_outputs) do
-                if output.owner_logger_name == "test.parent" then
-                    found_parent_output = true
+            -- Check that at least one dispatcher comes from parent
+            local found_parent_dispatcher = false
+            for _, dispatcher in ipairs(effective_dispatchers) do
+                if dispatcher.owner_logger_name == "test.parent" then
+                    found_parent_dispatcher = true
                     break
                 end
             end
-            assert.is_true(found_parent_output)
+            assert.is_true(found_parent_dispatcher)
         end)
     end)
 
 
     describe("Edge cases", function()
-        it("should handle empty outputs array", function()
+        it("should handle empty dispatchers array", function()
             local logger = lualog.logger({
-                name = "test.empty.outputs",
-                outputs = {}
+                name = "test.empty.dispatchers",
+                dispatchers = {}
             })
 
-            assert.are.same(0, #logger.outputs)
+            assert.are.same(0, #logger.dispatchers)
         end)
 
         it("should handle root logger creation", function()
diff --git a/spec/outputs/file_output_spec.lua b/spec/dispatchers/file_dispatcher_spec.lua
similarity index 92%
rename from spec/outputs/file_output_spec.lua
rename to spec/dispatchers/file_dispatcher_spec.lua
index 0ca7a1a..1f1bd6a 100644
--- a/spec/outputs/file_output_spec.lua
+++ b/spec/dispatchers/file_dispatcher_spec.lua
@@ -4,8 +4,8 @@ local assert = require("luassert")
 
 -- luacheck: globals describe it setup teardown os io
 
-describe("lual.outputs.file_output", function()
-	local file_output_factory
+describe("lual.dispatchers.file_dispatcher", function()
+	local file_dispatcher_factory
 
 	-- Mock storage, localized to this describe block
 	local mock_os_rename_calls
@@ -74,8 +74,8 @@ describe("lual.outputs.file_output", function()
 		}
 
 		-- Clear lual's cache if it's already loaded to get fresh mocks
-		package.loaded["lual.outputs.file_output"] = nil
-		file_output_factory = require("lual.outputs.file_output")
+		package.loaded["lual.dispatchers.file_dispatcher"] = nil
+		file_dispatcher_factory = require("lua.lual.dispatchers.file_dispatcher")
 	end)
 
 	before_each(function()
@@ -139,13 +139,13 @@ describe("lual.outputs.file_output", function()
 	end)
 
 	it("should require config.path", function()
-		file_output_factory({})
+		file_dispatcher_factory({})
 		local msg1 = mock_io_stderr_write_messages[1]
 		assert.truthy(msg1 and string.find(msg1, "requires config.path"))
 
 		-- Reset for next check within same test
 		mock_io_stderr_write_messages = {}
-		file_output_factory({ path = 123 }) -- Invalid type
+		file_dispatcher_factory({ path = 123 }) -- Invalid type
 		local msg2 = mock_io_stderr_write_messages[1]
 		assert.truthy(msg2 and string.find(msg2, "requires config.path"))
 	end)
@@ -165,7 +165,7 @@ describe("lual.outputs.file_output", function()
 				return mock_file_object -- for append mode
 			end
 
-			file_output_factory({ path = log_path })
+			file_dispatcher_factory({ path = log_path })
 
 			-- Check that .5 was checked for existence
 			assert.are.same({ path = log_path .. ".5", mode = "r" }, mock_io_open_calls[1])
@@ -187,7 +187,7 @@ describe("lual.outputs.file_output", function()
 				return mock_file_object -- for append mode
 			end
 
-			file_output_factory({ path = log_path })
+			file_dispatcher_factory({ path = log_path })
 
 			-- Expected rename operations for shifting
 			-- .4 -> .5, .3 -> .4, .2 -> .3, .1 -> .2
@@ -217,7 +217,7 @@ describe("lual.outputs.file_output", function()
 				return mock_file_object -- for append mode
 			end
 
-			file_output_factory({ path = log_path })
+			file_dispatcher_factory({ path = log_path })
 
 			-- Find the rename of current log to .1
 			local found_rename_current_log = false
@@ -232,7 +232,7 @@ describe("lual.outputs.file_output", function()
 
 		it("should handle rotation when no previous log files exist", function()
 			-- Default mock behavior: no files exist (already set in setup)
-			file_output_factory({ path = log_path })
+			file_dispatcher_factory({ path = log_path })
 
 			-- Check that existence checks were made for all files during rotation
 			local expected_checks = {
@@ -259,7 +259,7 @@ describe("lual.outputs.file_output", function()
 		local log_path = "write_test.log"
 
 		it("should open the new log file in append mode for writing", function()
-			local handler = file_output_factory({ path = log_path })
+			local handler = file_dispatcher_factory({ path = log_path })
 			mock_io_open_calls = {} -- Clear calls from rotation phase
 
 			handler({ message = "dummy write to trigger open" })
@@ -269,7 +269,7 @@ describe("lual.outputs.file_output", function()
 		end)
 
 		it("should write record message, newline, and flush", function()
-			local handler = file_output_factory({ path = log_path })
+			local handler = file_dispatcher_factory({ path = log_path })
 			local record = { message = "Test log message" }
 			handler(record)
 
@@ -291,7 +291,7 @@ describe("lual.outputs.file_output", function()
 				return mock_file_object -- Should not be reached for the 'a' mode in this test
 			end
 
-			local handler = file_output_factory({ path = log_path })
+			local handler = file_dispatcher_factory({ path = log_path })
 			handler({ message = "test" })
 			local err_msg_open = mock_io_stderr_write_messages[1]
 			assert.truthy(err_msg_open and string.find(err_msg_open, "Error opening log"))
@@ -302,7 +302,7 @@ describe("lual.outputs.file_output", function()
 			mock_file_object.write = function()
 				error("Disk full")
 			end
-			local handler = file_output_factory({ path = log_path })
+			local handler = file_dispatcher_factory({ path = log_path })
 			handler({ message = "test" })
 			local err_msg_write = mock_io_stderr_write_messages[1]
 			assert.truthy(err_msg_write and string.find(err_msg_write, "Error writing to log file"))
diff --git a/spec/outputs/syslog_output_spec.lua b/spec/dispatchers/syslog_dispatcher_spec.lua
similarity index 81%
rename from spec/outputs/syslog_output_spec.lua
rename to spec/dispatchers/syslog_dispatcher_spec.lua
index 7ce49f9..4d8eb7d 100644
--- a/spec/outputs/syslog_output_spec.lua
+++ b/spec/dispatchers/syslog_dispatcher_spec.lua
@@ -4,8 +4,8 @@ local assert = require("luassert")
 
 -- luacheck: globals describe it setup teardown before_each after_each
 
-describe("lual.outputs.syslog_output", function()
-    local syslog_output_factory
+describe("lual.dispatchers.syslog_dispatcher", function()
+    local syslog_dispatcher_factory
     local original_socket
     local mock_socket
     local mock_udp_socket
@@ -80,8 +80,8 @@ describe("lual.outputs.syslog_output", function()
         package.loaded["socket"] = mock_socket
 
         -- Clear lual's cache if it's already loaded to get fresh mocks
-        package.loaded["lual.outputs.syslog_output"] = nil
-        syslog_output_factory = require("lual.outputs.syslog_output")
+        package.loaded["lual.dispatchers.syslog_dispatcher"] = nil
+        syslog_dispatcher_factory = require("lua.lual.dispatchers.syslog_dispatcher")
     end)
 
     before_each(function()
@@ -128,58 +128,58 @@ describe("lual.outputs.syslog_output", function()
 
     describe("Configuration Validation", function()
         it("should require a config table", function()
-            local handler = syslog_output_factory()
+            local handler = syslog_dispatcher_factory()
             assert.are.equal(1, #mock_stderr_messages)
             assert.truthy(string.find(mock_stderr_messages[1], "requires a config table"))
         end)
 
         it("should accept valid string facilities", function()
-            local handler = syslog_output_factory({ facility = "LOCAL0" })
+            local handler = syslog_dispatcher_factory({ facility = "LOCAL0" })
             assert.are.equal(0, #mock_stderr_messages)
         end)
 
         it("should accept valid numeric facilities", function()
-            local handler = syslog_output_factory({ facility = 16 }) -- LOCAL0
+            local handler = syslog_dispatcher_factory({ facility = 16 }) -- LOCAL0
             assert.are.equal(0, #mock_stderr_messages)
         end)
 
         it("should reject invalid string facilities", function()
-            local handler = syslog_output_factory({ facility = "INVALID" })
+            local handler = syslog_dispatcher_factory({ facility = "INVALID" })
             assert.are.equal(1, #mock_stderr_messages)
             assert.truthy(string.find(mock_stderr_messages[1], "Unknown syslog facility"))
         end)
 
         it("should reject invalid numeric facilities", function()
-            local handler = syslog_output_factory({ facility = 999 })
+            local handler = syslog_dispatcher_factory({ facility = 999 })
             assert.are.equal(1, #mock_stderr_messages)
             assert.truthy(string.find(mock_stderr_messages[1], "Invalid syslog facility number"))
         end)
 
         it("should reject non-string hosts", function()
-            local handler = syslog_output_factory({ host = 123 })
+            local handler = syslog_dispatcher_factory({ host = 123 })
             assert.are.equal(1, #mock_stderr_messages)
             assert.truthy(string.find(mock_stderr_messages[1], "host must be a string"))
         end)
 
         it("should reject invalid ports", function()
-            local handler = syslog_output_factory({ port = 0 })
+            local handler = syslog_dispatcher_factory({ port = 0 })
             assert.are.equal(1, #mock_stderr_messages)
             assert.truthy(string.find(mock_stderr_messages[1], "port must be a number between 1 and 65535"))
 
             mock_stderr_messages = {}
-            local handler2 = syslog_output_factory({ port = 70000 })
+            local handler2 = syslog_dispatcher_factory({ port = 70000 })
             assert.are.equal(1, #mock_stderr_messages)
             assert.truthy(string.find(mock_stderr_messages[1], "port must be a number between 1 and 65535"))
         end)
 
         it("should reject non-string tags", function()
-            local handler = syslog_output_factory({ tag = 123 })
+            local handler = syslog_dispatcher_factory({ tag = 123 })
             assert.are.equal(1, #mock_stderr_messages)
             assert.truthy(string.find(mock_stderr_messages[1], "tag must be a string"))
         end)
 
         it("should reject non-string hostnames", function()
-            local handler = syslog_output_factory({ hostname = 123 })
+            local handler = syslog_dispatcher_factory({ hostname = 123 })
             assert.are.equal(1, #mock_stderr_messages)
             assert.truthy(string.find(mock_stderr_messages[1], "hostname must be a string"))
         end)
@@ -187,8 +187,8 @@ describe("lual.outputs.syslog_output", function()
 
     describe("Level Mapping", function()
         it("should map lual levels to correct syslog severities", function()
-            local map_func = syslog_output_factory._map_level_to_severity
-            local severities = syslog_output_factory._SEVERITIES
+            local map_func = syslog_dispatcher_factory._map_level_to_severity
+            local severities = syslog_dispatcher_factory._SEVERITIES
 
             assert.are.equal(severities.DEBUG, map_func(10))    -- DEBUG
             assert.are.equal(severities.INFO, map_func(20))     -- INFO
@@ -201,7 +201,7 @@ describe("lual.outputs.syslog_output", function()
 
     describe("Hostname Detection", function()
         it("should get hostname from socket.dns.gethostname", function()
-            local hostname = syslog_output_factory._get_hostname()
+            local hostname = syslog_dispatcher_factory._get_hostname()
             assert.are.equal("test-hostname", hostname)
             assert.are.equal(1, #mock_dns_calls)
         end)
@@ -212,7 +212,7 @@ describe("lual.outputs.syslog_output", function()
                 return nil -- Simulate failure
             end
 
-            local hostname = syslog_output_factory._get_hostname()
+            local hostname = syslog_dispatcher_factory._get_hostname()
             assert.are.equal("localhost", hostname)
             assert.are.equal(1, #mock_dns_calls)
         end)
@@ -223,7 +223,7 @@ describe("lual.outputs.syslog_output", function()
                 return "" -- Simulate empty hostname
             end
 
-            local hostname = syslog_output_factory._get_hostname()
+            local hostname = syslog_dispatcher_factory._get_hostname()
             assert.are.equal("localhost", hostname)
             assert.are.equal(1, #mock_dns_calls)
         end)
@@ -231,9 +231,9 @@ describe("lual.outputs.syslog_output", function()
 
     describe("Message Formatting", function()
         it("should format RFC 3164 compliant messages", function()
-            local format_func = syslog_output_factory._format_syslog_message
-            local facilities = syslog_output_factory._FACILITIES
-            local severities = syslog_output_factory._SEVERITIES
+            local format_func = syslog_dispatcher_factory._format_syslog_message
+            local facilities = syslog_dispatcher_factory._FACILITIES
+            local severities = syslog_dispatcher_factory._SEVERITIES
 
             local record = {
                 message = "Test log message",
@@ -248,8 +248,8 @@ describe("lual.outputs.syslog_output", function()
         end)
 
         it("should clean tag names", function()
-            local format_func = syslog_output_factory._format_syslog_message
-            local facilities = syslog_output_factory._FACILITIES
+            local format_func = syslog_dispatcher_factory._format_syslog_message
+            local facilities = syslog_dispatcher_factory._FACILITIES
 
             local record = {
                 message = "Test message",
@@ -261,8 +261,8 @@ describe("lual.outputs.syslog_output", function()
         end)
 
         it("should truncate long tags", function()
-            local format_func = syslog_output_factory._format_syslog_message
-            local facilities = syslog_output_factory._FACILITIES
+            local format_func = syslog_dispatcher_factory._format_syslog_message
+            local facilities = syslog_dispatcher_factory._FACILITIES
 
             local record = {
                 message = "Test message",
@@ -276,8 +276,8 @@ describe("lual.outputs.syslog_output", function()
         end)
 
         it("should handle missing level in record", function()
-            local format_func = syslog_output_factory._format_syslog_message
-            local facilities = syslog_output_factory._FACILITIES
+            local format_func = syslog_dispatcher_factory._format_syslog_message
+            local facilities = syslog_dispatcher_factory._FACILITIES
 
             local record = {
                 message = "Test message"
@@ -292,7 +292,7 @@ describe("lual.outputs.syslog_output", function()
 
     describe("Socket Operations", function()
         it("should create UDP socket with timeout", function()
-            local handler = syslog_output_factory({})
+            local handler = syslog_dispatcher_factory({})
             assert.are.equal(0.1, mock_udp_socket._timeout)
         end)
 
@@ -301,13 +301,13 @@ describe("lual.outputs.syslog_output", function()
                 return nil -- Simulate socket creation failure
             end
 
-            local handler = syslog_output_factory({})
+            local handler = syslog_dispatcher_factory({})
             assert.are.equal(1, #mock_stderr_messages)
             assert.truthy(string.find(mock_stderr_messages[1], "Failed to create UDP socket"))
         end)
 
         it("should send messages to correct host and port", function()
-            local handler = syslog_output_factory({
+            local handler = syslog_dispatcher_factory({
                 host = "log.example.com",
                 port = 1514,
                 facility = "LOCAL0",
@@ -333,7 +333,7 @@ describe("lual.outputs.syslog_output", function()
         end)
 
         it("should use default host and port", function()
-            local handler = syslog_output_factory({})
+            local handler = syslog_dispatcher_factory({})
 
             local record = {
                 message = "Default test",
@@ -358,7 +358,7 @@ describe("lual.outputs.syslog_output", function()
                 return nil, "Network unreachable" -- Simulate failure
             end
 
-            local handler = syslog_output_factory({})
+            local handler = syslog_dispatcher_factory({})
             local record = { message = "Test", level = 20 }
 
             handler(record)
@@ -371,7 +371,7 @@ describe("lual.outputs.syslog_output", function()
 
     describe("Integration", function()
         it("should work with all configuration options", function()
-            local handler = syslog_output_factory({
+            local handler = syslog_dispatcher_factory({
                 facility = "LOCAL7",
                 host = "syslog.company.com",
                 port = 5514,
@@ -400,7 +400,7 @@ describe("lual.outputs.syslog_output", function()
         end)
 
         it("should handle case-insensitive facility names", function()
-            local handler = syslog_output_factory({ facility = "local0" })
+            local handler = syslog_dispatcher_factory({ facility = "local0" })
 
             local record = { message = "Test", level = 20 }
             handler(record)
@@ -411,7 +411,7 @@ describe("lual.outputs.syslog_output", function()
         end)
 
         it("should return no-op function on configuration errors", function()
-            local handler = syslog_output_factory({ facility = "INVALID" })
+            local handler = syslog_dispatcher_factory({ facility = "INVALID" })
 
             -- Should have logged error
             assert.are.equal(1, #mock_stderr_messages)
@@ -427,16 +427,16 @@ describe("lual.outputs.syslog_output", function()
 
     describe("Module Interface", function()
         it("should expose internal functions for testing", function()
-            assert.is_function(syslog_output_factory._map_level_to_severity)
-            assert.is_function(syslog_output_factory._get_hostname)
-            assert.is_function(syslog_output_factory._format_syslog_message)
-            assert.is_function(syslog_output_factory._validate_config)
-            assert.is_table(syslog_output_factory._FACILITIES)
-            assert.is_table(syslog_output_factory._SEVERITIES)
+            assert.is_function(syslog_dispatcher_factory._map_level_to_severity)
+            assert.is_function(syslog_dispatcher_factory._get_hostname)
+            assert.is_function(syslog_dispatcher_factory._format_syslog_message)
+            assert.is_function(syslog_dispatcher_factory._validate_config)
+            assert.is_table(syslog_dispatcher_factory._FACILITIES)
+            assert.is_table(syslog_dispatcher_factory._SEVERITIES)
         end)
 
         it("should be callable as a function", function()
-            local handler = syslog_output_factory({ facility = "USER" })
+            local handler = syslog_dispatcher_factory({ facility = "USER" })
             assert.is_function(handler)
         end)
     end)
diff --git a/spec/outputs_formatters_spec.lua b/spec/dispatchers_formatters_spec.lua
similarity index 83%
rename from spec/outputs_formatters_spec.lua
rename to spec/dispatchers_formatters_spec.lua
index 9c13939..1764195 100644
--- a/spec/outputs_formatters_spec.lua
+++ b/spec/dispatchers_formatters_spec.lua
@@ -15,8 +15,8 @@ describe("lualog.lib.text", function()
 			args = { "jane.doe", "10.0.0.1" },
 		}
 		local expected_timestamp = os.date("!%Y-%m-%d %H:%M:%S", record.timestamp)
-		local expected_output = expected_timestamp .. " INFO [test.logger] User jane.doe logged in from 10.0.0.1"
-		assert.are.same(expected_output, lualog.lib.text(record))
+		local expected_dispatcher = expected_timestamp .. " INFO [test.logger] User jane.doe logged in from 10.0.0.1"
+		assert.are.same(expected_dispatcher, lualog.lib.text(record))
 	end)
 
 	it("should handle nil arguments gracefully", function()
@@ -29,8 +29,8 @@ describe("lualog.lib.text", function()
 			args = nil,
 		}
 		local expected_timestamp = os.date("!%Y-%m-%d %H:%M:%S", record.timestamp)
-		local expected_output = expected_timestamp .. " DEBUG [nil.args.test] Test message with no args"
-		assert.are.same(expected_output, lualog.lib.text(record))
+		local expected_dispatcher = expected_timestamp .. " DEBUG [nil.args.test] Test message with no args"
+		assert.are.same(expected_dispatcher, lualog.lib.text(record))
 	end)
 
 	it("should handle empty arguments table", function()
@@ -43,8 +43,8 @@ describe("lualog.lib.text", function()
 			args = {},
 		}
 		local expected_timestamp = os.date("!%Y-%m-%d %H:%M:%S", record.timestamp)
-		local expected_output = expected_timestamp .. " WARNING [empty.args.test] Test message with empty args"
-		assert.are.same(expected_output, lualog.lib.text(record))
+		local expected_dispatcher = expected_timestamp .. " WARNING [empty.args.test] Test message with empty args"
+		assert.are.same(expected_dispatcher, lualog.lib.text(record))
 	end)
 
 	it("should use fallbacks for missing optional record fields", function()
@@ -59,8 +59,8 @@ describe("lualog.lib.text", function()
 			message_fmt = "Message with nil level",
 			args = {},
 		}
-		local expected_output1 = expected_timestamp .. " UNKNOWN_LEVEL [test.missing.level] Message with nil level"
-		assert.are.same(expected_output1, lualog.lib.text(record1))
+		local expected_dispatcher1 = expected_timestamp .. " UNKNOWN_LEVEL [test.missing.level] Message with nil level"
+		assert.are.same(expected_dispatcher1, lualog.lib.text(record1))
 
 		local record2 = {
 			timestamp = ts,
@@ -70,8 +70,8 @@ describe("lualog.lib.text", function()
 			message_fmt = "Message with nil logger name",
 			args = {},
 		}
-		local expected_output2 = expected_timestamp .. " ERROR [UNKNOWN_LOGGER] Message with nil logger name"
-		assert.are.same(expected_output2, lualog.lib.text(record2))
+		local expected_dispatcher2 = expected_timestamp .. " ERROR [UNKNOWN_LOGGER] Message with nil logger name"
+		assert.are.same(expected_dispatcher2, lualog.lib.text(record2))
 
 		local record3 = {
 			timestamp = ts,
@@ -81,8 +81,8 @@ describe("lualog.lib.text", function()
 			message_fmt = "Message with missing args",
 			args = nil, -- Missing args
 		}
-		local expected_output3 = expected_timestamp .. " CRITICAL [test.missing.args] Message with missing args"
-		assert.are.same(expected_output3, lualog.lib.text(record3))
+		local expected_dispatcher3 = expected_timestamp .. " CRITICAL [test.missing.args] Message with missing args"
+		assert.are.same(expected_dispatcher3, lualog.lib.text(record3))
 	end)
 end)
 
@@ -169,7 +169,7 @@ describe("lualog.lib.console", function()
 		}
 		local record = { message = "Message that will fail to write" }
 
-		-- Call the output with the erroring stream
+		-- Call the dispatcher with the erroring stream
 		lualog.lib.console(record, { stream = erroring_mock_stream })
 
 		-- Check that an error message was written to our mock_stderr_stream
diff --git a/spec/formatters/color_formatter_spec.lua b/spec/formatters/color_formatter_spec.lua
index 232e3d6..25cd2fe 100644
--- a/spec/formatters/color_formatter_spec.lua
+++ b/spec/formatters/color_formatter_spec.lua
@@ -31,7 +31,7 @@ describe("lual.formatters.color", function()
 
 		-- Print debug info
 		print("Expected message:", expected_message)
-		print("Formatted output:", formatted)
+		print("Formatted dispatcher:", formatted)
 
 		assert.truthy(
 			formatted:find(colors.dim .. timestamp_str .. colors.reset, 1, true),
diff --git a/spec/ingest_dispatch_spec.lua b/spec/ingest_dispatch_spec.lua
index 69476bf..08704fd 100644
--- a/spec/ingest_dispatch_spec.lua
+++ b/spec/ingest_dispatch_spec.lua
@@ -13,32 +13,32 @@ describe("ingest.dispatch_log_event", function()
 
 	local registered_mock_loggers = {}
 	local formatter_calls = {}
-	local output_calls = {}
-	local output_calls_ok = {} -- For tests with mixed erroring/non-erroring outputs
+	local dispatcher_calls = {}
+	local dispatcher_calls_ok = {} -- For tests with mixed erroring/non-erroring dispatchers
 	local stderr_messages = {}
 
-	local function create_mock_logger(name, level, outputs, propagate, parent)
+	local function create_mock_logger(name, level, dispatchers, propagate, parent)
 		local logger = {
 			name = name,
 			level = level,
-			outputs = outputs or {},
+			dispatchers = dispatchers or {},
 			propagate = propagate,
 			parent = parent,
 			is_enabled_for = function(self, message_level)
 				return message_level >= (self.level or mock_log_levels.INFO)
 			end,
-			-- This mock get_effective_outputs needs to match the structure expected by the new ingest.dispatch_log_event
-			get_effective_outputs = function(self)
-				local collected_outputs = {}
+			-- This mock get_effective_dispatchers needs to match the structure expected by the new ingest.dispatch_log_event
+			get_effective_dispatchers = function(self)
+				local collected_dispatchers = {}
 				local current = self
 				while current do
-					if current.outputs then
-						for _, h_entry in ipairs(current.outputs) do
-							-- Ensure h_entry has output_func, formatter_func, etc.
-							table.insert(collected_outputs, {
-								output_func = h_entry.output_func,
+					if current.dispatchers then
+						for _, h_entry in ipairs(current.dispatchers) do
+							-- Ensure h_entry has dispatcher_func, formatter_func, etc.
+							table.insert(collected_dispatchers, {
+								dispatcher_func = h_entry.dispatcher_func,
 								formatter_func = h_entry.formatter_func,
-								output_config = h_entry.output_config,
+								dispatcher_config = h_entry.dispatcher_config,
 								owner_logger_name = current.name, -- Add owner context
 								owner_logger_level = current.level, -- Add owner context
 							})
@@ -49,7 +49,7 @@ describe("ingest.dispatch_log_event", function()
 					end
 					current = current.parent
 				end
-				return collected_outputs
+				return collected_dispatchers
 			end,
 		}
 		return logger
@@ -82,32 +82,32 @@ describe("ingest.dispatch_log_event", function()
 		formatter_calls = {}
 	end
 
-	local function mock_output_func(record, config)
-		table.insert(output_calls, { params = record, config = config })
+	local function mock_dispatcher_func(record, config)
+		table.insert(dispatcher_calls, { params = record, config = config })
 	end
 
-	local function mock_erroring_output_func(record, config)
-		error("Output error")
+	local function mock_erroring_dispatcher_func(record, config)
+		error("dispatcher error")
 	end
 
-	local function get_output_calls()
-		return output_calls
+	local function get_dispatcher_calls()
+		return dispatcher_calls
 	end
 
-	local function clear_output_calls()
-		output_calls = {}
+	local function clear_dispatcher_calls()
+		dispatcher_calls = {}
 	end
 
-	local function mock_output_func_ok(record, config)
-		table.insert(output_calls_ok, { params = record, config = config }) -- Adjusted for consistency, though not strictly required by subtask
+	local function mock_dispatcher_func_ok(record, config)
+		table.insert(dispatcher_calls_ok, { params = record, config = config }) -- Adjusted for consistency, though not strictly required by subtask
 	end
 
-	local function get_output_calls_ok()
-		return output_calls_ok
+	local function get_dispatcher_calls_ok()
+		return dispatcher_calls_ok
 	end
 
-	local function clear_output_calls_ok()
-		output_calls_ok = {}
+	local function clear_dispatcher_calls_ok()
+		dispatcher_calls_ok = {}
 	end
 
 	local function mock_stderr_write(_, message)
@@ -125,8 +125,8 @@ describe("ingest.dispatch_log_event", function()
 
 	local function clear_all_mocks()
 		clear_formatter_calls()
-		clear_output_calls()
-		clear_output_calls_ok()
+		clear_dispatcher_calls()
+		clear_dispatcher_calls_ok()
 		clear_stderr_messages()
 		registered_mock_loggers = {}
 	end
@@ -135,7 +135,7 @@ describe("ingest.dispatch_log_event", function()
 	_G.log = {}
 	_G.log.levels = mock_log_levels
 	_G.log.logger_internal =
-	mock_logger_internal                       -- Retain for other potential internal uses or direct logger method tests.
+		mock_logger_internal -- Retain for other potential internal uses or direct logger method tests.
 
 	-- Require the ingest module
 	local ingest_module_status, ingest = pcall(require, "lual.ingest")
@@ -163,13 +163,13 @@ describe("ingest.dispatch_log_event", function()
 		assert.is_function(mock_logger_internal)
 	end)
 
-	it("should call output and formatter for a single logger", function()
+	it("should call dispatcher and formatter for a single logger", function()
 		set_mock_loggers({
 			main_logger = create_mock_logger("main_logger", _G.log.levels.INFO, {
 				{
 					formatter_func = mock_formatter_func,
-					output_func = mock_output_func,
-					output_config = { dest = "mock_output" },
+					dispatcher_func = mock_dispatcher_func,
+					dispatcher_config = { dest = "mock_dispatcher" },
 				},
 			}),
 		})
@@ -191,21 +191,22 @@ describe("ingest.dispatch_log_event", function()
 		local logger = _G.log.logger_internal("main_logger")
 		print("Logger Name: " .. tostring(logger.name))
 		print("Logger Level: " .. tostring(logger.level))
-		print("Logger Outputs Count: " .. tostring(#logger.outputs))
-		if #logger.outputs > 0 then
+		print("Logger dispatchers Count: " .. tostring(#logger.dispatchers))
+		if #logger.dispatchers > 0 then
 			print(
 				"Formatter func is mock_formatter_func: "
-				.. tostring(logger.outputs[1].formatter_func == mock_formatter_func)
+				.. tostring(logger.dispatchers[1].formatter_func == mock_formatter_func)
 			)
 		end
-		if #logger.outputs > 0 then
-			print("Output func is mock_output_func: " .. tostring(logger.outputs[1].output_func == mock_output_func))
+		if #logger.dispatchers > 0 then
+			print("dispatcher func is mock_dispatcher_func: " ..
+			tostring(logger.dispatchers[1].dispatcher_func == mock_dispatcher_func))
 		end
 
 		ingest.dispatch_log_event(event_details, mock_logger_internal, mock_log_levels)
 
 		print("#formatter_calls after dispatch: " .. tostring(#get_formatter_calls()))
-		print("#output_calls after dispatch: " .. tostring(#get_output_calls()))
+		print("#dispatcher_calls after dispatch: " .. tostring(#get_dispatcher_calls()))
 
 		local formatter_calls_list = get_formatter_calls()
 		assert.are.same(1, #formatter_calls_list)
@@ -221,11 +222,11 @@ describe("ingest.dispatch_log_event", function()
 			assert.is_nil(fc.params.context) -- Check for context
 		end
 
-		local output_calls_list = get_output_calls()
-		assert.are.same(1, #output_calls_list)
-		if #output_calls_list > 0 then
-			local hc_params = output_calls_list[1].params
-			local hc_config = output_calls_list[1].config
+		local dispatcher_calls_list = get_dispatcher_calls()
+		assert.are.same(1, #dispatcher_calls_list)
+		if #dispatcher_calls_list > 0 then
+			local hc_params = dispatcher_calls_list[1].params
+			local hc_config = dispatcher_calls_list[1].config
 			assert.are.same("INFO", hc_params.level_name)
 			assert.are.same("main_logger", hc_params.logger_name)
 			-- Expected message is based on mock_formatter_func's behavior
@@ -239,9 +240,9 @@ describe("ingest.dispatch_log_event", function()
 			assert.are.same(42, hc_params.lineno)
 			assert.are.same("Event: %s occurred", hc_params.raw_message_fmt)
 			assert.are.same("login", hc_params.raw_args[1])
-			assert.is_nil(hc_params.context) -- Check for context in output record
+			assert.is_nil(hc_params.context) -- Check for context in dispatcher record
 			assert.are.same("main_logger", hc_params.source_logger_name)
-			assert.are.same("mock_output", hc_config.dest)
+			assert.are.same("mock_dispatcher", hc_config.dest)
 		end
 
 		assert.are.same(0, #get_stderr_messages())
@@ -250,7 +251,7 @@ describe("ingest.dispatch_log_event", function()
 	it("should ignore message if its level is below logger's level", function()
 		set_mock_loggers({
 			filter_logger = create_mock_logger("filter_logger", _G.log.levels.WARNING, {
-				{ formatter_func = mock_formatter_func, output_func = mock_output_func, output_config = {} },
+				{ formatter_func = mock_formatter_func, dispatcher_func = mock_dispatcher_func, dispatcher_config = {} },
 			}),
 		})
 
@@ -269,14 +270,14 @@ describe("ingest.dispatch_log_event", function()
 		ingest.dispatch_log_event(event_details, mock_logger_internal, mock_log_levels)
 
 		assert.are.same(0, #get_formatter_calls())
-		assert.are.same(0, #get_output_calls())
+		assert.are.same(0, #get_dispatcher_calls())
 		assert.are.same(0, #get_stderr_messages())
 	end)
 
 	it("should process message if its level is equal to logger's level", function()
 		set_mock_loggers({
 			filter_logger = create_mock_logger("filter_logger", _G.log.levels.INFO, {
-				{ formatter_func = mock_formatter_func, output_func = mock_output_func, output_config = {} },
+				{ formatter_func = mock_formatter_func, dispatcher_func = mock_dispatcher_func, dispatcher_config = {} },
 			}),
 		})
 
@@ -297,7 +298,7 @@ describe("ingest.dispatch_log_event", function()
 		local fc_list_eq = get_formatter_calls()
 		assert.are.same(1, #fc_list_eq)
 		if #fc_list_eq > 0 then assert.is_nil(fc_list_eq[1].params.context) end
-		local hc_list_eq = get_output_calls()
+		local hc_list_eq = get_dispatcher_calls()
 		assert.are.same(1, #hc_list_eq)
 		if #hc_list_eq > 0 then assert.is_nil(hc_list_eq[1].params.context) end
 		assert.are.same(0, #get_stderr_messages())
@@ -306,7 +307,7 @@ describe("ingest.dispatch_log_event", function()
 	it("should process message if its level is above logger's level", function()
 		set_mock_loggers({
 			filter_logger = create_mock_logger("filter_logger", _G.log.levels.INFO, {
-				{ formatter_func = mock_formatter_func, output_func = mock_output_func, output_config = {} },
+				{ formatter_func = mock_formatter_func, dispatcher_func = mock_dispatcher_func, dispatcher_config = {} },
 			}),
 		})
 
@@ -331,11 +332,11 @@ describe("ingest.dispatch_log_event", function()
 			assert.is_nil(formatter_calls_list[1].params.context)
 		end
 
-		local output_calls_list = get_output_calls()
-		assert.are.same(1, #output_calls_list)
-		if #output_calls_list > 0 then
-			assert.are.same("ERROR", output_calls_list[1].params.level_name)
-			assert.is_nil(output_calls_list[1].params.context)
+		local dispatcher_calls_list = get_dispatcher_calls()
+		assert.are.same(1, #dispatcher_calls_list)
+		if #dispatcher_calls_list > 0 then
+			assert.are.same("ERROR", dispatcher_calls_list[1].params.level_name)
+			assert.is_nil(dispatcher_calls_list[1].params.context)
 		end
 		assert.are.same(0, #get_stderr_messages())
 	end)
@@ -344,15 +345,15 @@ describe("ingest.dispatch_log_event", function()
 		local parent_logger = create_mock_logger("parent_logger", _G.log.levels.DEBUG, {
 			{
 				formatter_func = mock_formatter_func,
-				output_func = mock_output_func,
-				output_config = { id = "parent_h" },
+				dispatcher_func = mock_dispatcher_func,
+				dispatcher_config = { id = "parent_h" },
 			},
 		})
 		local child_logger = create_mock_logger("child_logger", _G.log.levels.DEBUG, {
 			{
 				formatter_func = mock_formatter_func,
-				output_func = mock_output_func,
-				output_config = { id = "child_h" },
+				dispatcher_func = mock_dispatcher_func,
+				dispatcher_config = { id = "child_h" },
 			},
 		}, true, parent_logger)
 		set_mock_loggers({ parent_logger = parent_logger, child_logger = child_logger })
@@ -371,7 +372,7 @@ describe("ingest.dispatch_log_event", function()
 		ingest.dispatch_log_event(event_details, mock_logger_internal, mock_log_levels)
 
 		local fc_list = get_formatter_calls()
-		local hc_list = get_output_calls()
+		local hc_list = get_dispatcher_calls()
 		assert.are.same(2, #fc_list)
 		assert.are.same(2, #hc_list)
 
@@ -388,7 +389,7 @@ describe("ingest.dispatch_log_event", function()
 			assert.are.same("parent_logger", hc_list[2].params.logger_name)
 			assert.is_nil(hc_list[2].params.context)
 			assert.are.same("parent_h", hc_list[2].config.id)
-			-- Check that the message for the parent's output was formatted by the parent's formatter.
+			-- Check that the message for the parent's dispatcher was formatted by the parent's formatter.
 			-- Our mock_formatter_func prepends "Formatted: " to the original message.
 			-- The original message for the parent logger's formatter is the *already formatted* message from the child.
 			-- However, the dispatch_log_event re-formats for each logger based on the *original* event_details.
@@ -401,10 +402,10 @@ describe("ingest.dispatch_log_event", function()
 
 	it("should not propagate if child's propagate is false", function()
 		local parent_logger_no_prop = create_mock_logger("parent_logger_no_prop", _G.log.levels.DEBUG, {
-			{ formatter_func = mock_formatter_func, output_func = mock_output_func },
+			{ formatter_func = mock_formatter_func, dispatcher_func = mock_dispatcher_func },
 		})
 		local child_logger_no_prop = create_mock_logger("child_logger_no_prop", _G.log.levels.DEBUG, {
-			{ formatter_func = mock_formatter_func, output_func = mock_output_func },
+			{ formatter_func = mock_formatter_func, dispatcher_func = mock_dispatcher_func },
 		}, false, parent_logger_no_prop) -- propagate = false
 		set_mock_loggers({ parent_logger_no_prop = parent_logger_no_prop, child_logger_no_prop = child_logger_no_prop })
 
@@ -422,26 +423,26 @@ describe("ingest.dispatch_log_event", function()
 		ingest.dispatch_log_event(event_details, mock_logger_internal, mock_log_levels)
 
 		assert.are.same(1, #get_formatter_calls())
-		assert.are.same(1, #get_output_calls())
+		assert.are.same(1, #get_dispatcher_calls())
 		if #get_formatter_calls() == 1 then
 			assert.are.same("child_logger_no_prop", get_formatter_calls()[1].params.logger_name)
 			assert.is_nil(get_formatter_calls()[1].params.context)
 		end
-		if #get_output_calls() == 1 then
-			assert.is_nil(get_output_calls()[1].params.context)
+		if #get_dispatcher_calls() == 1 then
+			assert.is_nil(get_dispatcher_calls()[1].params.context)
 		end
 		assert.are.same(0, #get_stderr_messages())
 	end)
 
 	it("should propagate up a three-level hierarchy", function()
 		local root_logger = create_mock_logger("root_logger", _G.log.levels.DEBUG, {
-			{ formatter_func = mock_formatter_func, output_func = mock_output_func, output_config = { id = "root_h" } },
+			{ formatter_func = mock_formatter_func, dispatcher_func = mock_dispatcher_func, dispatcher_config = { id = "root_h" } },
 		})
 		local mid_logger = create_mock_logger("mid_logger", _G.log.levels.DEBUG, {
-			{ formatter_func = mock_formatter_func, output_func = mock_output_func, output_config = { id = "mid_h" } },
+			{ formatter_func = mock_formatter_func, dispatcher_func = mock_dispatcher_func, dispatcher_config = { id = "mid_h" } },
 		}, true, root_logger)
 		local leaf_logger = create_mock_logger("leaf_logger", _G.log.levels.DEBUG, {
-			{ formatter_func = mock_formatter_func, output_func = mock_output_func, output_config = { id = "leaf_h" } },
+			{ formatter_func = mock_formatter_func, dispatcher_func = mock_dispatcher_func, dispatcher_config = { id = "leaf_h" } },
 		}, true, mid_logger)
 		set_mock_loggers({ root_logger = root_logger, mid_logger = mid_logger, leaf_logger = leaf_logger })
 
@@ -459,7 +460,7 @@ describe("ingest.dispatch_log_event", function()
 		ingest.dispatch_log_event(event_details, mock_logger_internal, mock_log_levels)
 
 		local fc_list = get_formatter_calls()
-		local hc_list = get_output_calls()
+		local hc_list = get_dispatcher_calls()
 		assert.are.same(3, #fc_list)
 		assert.are.same(3, #hc_list)
 
@@ -487,10 +488,10 @@ describe("ingest.dispatch_log_event", function()
 
 	it("parent should filter propagated message based on its own level", function()
 		local parent_filter_logger = create_mock_logger("parent_filter_logger", _G.log.levels.WARNING, {
-			{ formatter_func = mock_formatter_func, output_func = mock_output_func },
+			{ formatter_func = mock_formatter_func, dispatcher_func = mock_dispatcher_func },
 		})
 		local child_source_logger = create_mock_logger("child_source_logger", _G.log.levels.INFO, {
-			{ formatter_func = mock_formatter_func, output_func = mock_output_func },
+			{ formatter_func = mock_formatter_func, dispatcher_func = mock_dispatcher_func },
 		}, true, parent_filter_logger)
 		set_mock_loggers({ parent_filter_logger = parent_filter_logger, child_source_logger = child_source_logger })
 
@@ -508,7 +509,7 @@ describe("ingest.dispatch_log_event", function()
 		ingest.dispatch_log_event(event_details, mock_logger_internal, mock_log_levels)
 
 		local fc_list = get_formatter_calls()
-		local hc_list = get_output_calls()
+		local hc_list = get_dispatcher_calls()
 		assert.are.same(1, #fc_list)
 		assert.are.same(1, #hc_list)
 
@@ -528,8 +529,8 @@ describe("ingest.dispatch_log_event", function()
 			error_logger = create_mock_logger("error_logger", _G.log.levels.INFO, {
 				{
 					formatter_func = mock_erroring_formatter_func,
-					output_func = mock_output_func,
-					output_config = { id = "h_after_fmt_err" },
+					dispatcher_func = mock_dispatcher_func,
+					dispatcher_config = { id = "h_after_fmt_err" },
 				},
 			}),
 		})
@@ -548,7 +549,7 @@ describe("ingest.dispatch_log_event", function()
 
 		assert.are.same(0, #get_formatter_calls()) -- Formatter errored, so no call recorded by mock_formatter_func
 
-		local hc_list = get_output_calls()
+		local hc_list = get_dispatcher_calls()
 		assert.are.same(1, #hc_list)
 
 		if #hc_list > 0 then
@@ -582,17 +583,17 @@ describe("ingest.dispatch_log_event", function()
 		end
 	end)
 
-	it("should handle output error gracefully", function()
+	it("should handle dispatcher error gracefully", function()
 		set_mock_loggers({
 			error_logger = create_mock_logger("error_logger", _G.log.levels.INFO, {
-				{ formatter_func = mock_formatter_func, output_func = mock_erroring_output_func },
+				{ formatter_func = mock_formatter_func, dispatcher_func = mock_erroring_dispatcher_func },
 			}),
 		})
 
 		local event_details = {
 			level_no = _G.log.levels.INFO,
 			level_name = "INFO",
-			message_fmt = "Message for erroring output",
+			message_fmt = "Message for erroring dispatcher",
 			args = {},
 			timestamp = 1678886409,
 			filename = "error_app.lua",
@@ -602,29 +603,29 @@ describe("ingest.dispatch_log_event", function()
 		ingest.dispatch_log_event(event_details, mock_logger_internal, mock_log_levels)
 
 		assert.are.same(1, #get_formatter_calls()) -- Formatter should have been called
-		assert.are.same(0, #get_output_calls()) -- Erroring output does not record its call
+		assert.are.same(0, #get_dispatcher_calls()) -- Erroring dispatcher does not record its call
 
 		local stderr_list = get_stderr_messages()
 		assert.are.same(1, #stderr_list)
 		if #stderr_list > 0 then
-			assert.is_true(string.find(stderr_list[1], "Logging system error: Output", 1, true) ~= nil)
+			assert.is_true(string.find(stderr_list[1], "Logging system error: dispatcher", 1, true) ~= nil)
 			assert.is_true(string.find(stderr_list[1], "error_logger", 1, true) ~= nil)
-			assert.is_true(string.find(stderr_list[1], "Output error", 1, true) ~= nil) -- The error from mock_erroring_output_func
+			assert.is_true(string.find(stderr_list[1], "dispatcher error", 1, true) ~= nil) -- The error from mock_erroring_dispatcher_func
 		end
 	end)
 
-	it("error in one output should not affect subsequent outputs for the same logger", function()
+	it("error in one dispatcher should not affect subsequent dispatchers for the same logger", function()
 		set_mock_loggers({
-			multi_output_logger = create_mock_logger("multi_output_logger", _G.log.levels.INFO, {
+			multi_dispatcher_logger = create_mock_logger("multi_dispatcher_logger", _G.log.levels.INFO, {
 				{
 					formatter_func = mock_formatter_func,
-					output_func = mock_erroring_output_func,
-					output_config = { id = "error_output" },
+					dispatcher_func = mock_erroring_dispatcher_func,
+					dispatcher_config = { id = "error_dispatcher" },
 				},
 				{
 					formatter_func = mock_formatter_func,
-					output_func = mock_output_func_ok,
-					output_config = { id = "ok_output" },
+					dispatcher_func = mock_dispatcher_func_ok,
+					dispatcher_config = { id = "ok_dispatcher" },
 				},
 			}),
 		})
@@ -632,51 +633,51 @@ describe("ingest.dispatch_log_event", function()
 		local event_details = {
 			level_no = _G.log.levels.INFO,
 			level_name = "INFO",
-			message_fmt = "Test for multi-output with error",
+			message_fmt = "Test for multi-dispatcher with error",
 			args = {},
 			timestamp = 1678886410,
 			filename = "error_app.lua",
 			lineno = 70,
-			source_logger_name = "multi_output_logger",
+			source_logger_name = "multi_dispatcher_logger",
 		}
 		ingest.dispatch_log_event(event_details, mock_logger_internal, mock_log_levels)
 
 		assert.are.same(2, #get_formatter_calls()) -- Both formatters should be called
-		assert.are.same(0, #get_output_calls()) -- Erroring output does not record
+		assert.are.same(0, #get_dispatcher_calls()) -- Erroring dispatcher does not record
 
-		local hc_ok_list = get_output_calls_ok()
+		local hc_ok_list = get_dispatcher_calls_ok()
 		assert.are.same(1, #hc_ok_list)
 		if #hc_ok_list > 0 then
-			assert.are.same("ok_output", hc_ok_list[1].config.id)
+			assert.are.same("ok_dispatcher", hc_ok_list[1].config.id)
 			local expected_message =
 				string.format("Formatted: %s", string.format(event_details.message_fmt, unpack(event_details.args)))
 			assert.are.same(expected_message, hc_ok_list[1].params.message)
 		end
 
 		local stderr_list = get_stderr_messages()
-		assert.are.same(1, #stderr_list) -- Only one error message from the first output
+		assert.are.same(1, #stderr_list) -- Only one error message from the first dispatcher
 		if #stderr_list > 0 then
-			-- First error message should mention both "Output" and failed
-			assert.is_true(string.find(stderr_list[1], "Output", 1, true) ~= nil)
-			assert.is_true(string.find(stderr_list[1], "multi_output_logger", 1, true) ~= nil)
+			-- First error message should mention both "dispatcher" and failed
+			assert.is_true(string.find(stderr_list[1], "dispatcher", 1, true) ~= nil)
+			assert.is_true(string.find(stderr_list[1], "multi_dispatcher_logger", 1, true) ~= nil)
 			assert.is_true(string.find(stderr_list[1], "failed", 1, true) ~= nil)
-			assert.is_true(string.find(stderr_list[1], "Output error", 1, true) ~= nil)
+			assert.is_true(string.find(stderr_list[1], "dispatcher error", 1, true) ~= nil)
 		end
 	end)
 
-	it("error in child's output should not affect propagation to parent", function()
+	it("error in child's dispatcher should not affect propagation to parent", function()
 		local parent_logger_prop = create_mock_logger("parent_logger_prop", _G.log.levels.INFO, {
 			{
 				formatter_func = mock_formatter_func,
-				output_func = mock_output_func_ok,
-				output_config = { id = "parent_ok_h" },
+				dispatcher_func = mock_dispatcher_func_ok,
+				dispatcher_config = { id = "parent_ok_h" },
 			},
 		})
 		local child_logger_prop_error = create_mock_logger("child_logger_prop_error", _G.log.levels.INFO, {
 			{
 				formatter_func = mock_formatter_func,
-				output_func = mock_erroring_output_func,
-				output_config = { id = "child_err_h" },
+				dispatcher_func = mock_erroring_dispatcher_func,
+				dispatcher_config = { id = "child_err_h" },
 			},
 		}, true, parent_logger_prop)
 		set_mock_loggers({ parent_logger_prop = parent_logger_prop, child_logger_prop_error = child_logger_prop_error })
@@ -702,9 +703,9 @@ describe("ingest.dispatch_log_event", function()
 			assert.are.same(event_details.context, fc_list[2].params.context)
 		end
 
-		assert.are.same(0, #get_output_calls()) -- Child's erroring output does not record
-		local hc_ok_list = get_output_calls_ok()
-		assert.are.same(1, #hc_ok_list)   -- Parent's OK output should be called
+		assert.are.same(0, #get_dispatcher_calls()) -- Child's erroring dispatcher does not record
+		local hc_ok_list = get_dispatcher_calls_ok()
+		assert.are.same(1, #hc_ok_list)       -- Parent's OK dispatcher should be called
 		if #hc_ok_list == 1 then
 			assert.are.same("parent_logger_prop", hc_ok_list[1].params.logger_name)
 			assert.are.same(event_details.context, hc_ok_list[1].params.context)
@@ -717,23 +718,23 @@ describe("ingest.dispatch_log_event", function()
 		end
 
 		local stderr_list = get_stderr_messages()
-		assert.are.same(1, #stderr_list) -- Error from child's output
+		assert.are.same(1, #stderr_list) -- Error from child's dispatcher
 		if #stderr_list > 0 then
-			-- First error message should mention both "Output" and failed
-			assert.is_true(string.find(stderr_list[1], "Output", 1, true) ~= nil)
+			-- First error message should mention both "dispatcher" and failed
+			assert.is_true(string.find(stderr_list[1], "dispatcher", 1, true) ~= nil)
 			assert.is_true(string.find(stderr_list[1], "child_logger_prop_error", 1, true) ~= nil)
 			assert.is_true(string.find(stderr_list[1], "failed", 1, true) ~= nil)
-			assert.is_true(string.find(stderr_list[1], "Output error", 1, true) ~= nil)
+			assert.is_true(string.find(stderr_list[1], "dispatcher error", 1, true) ~= nil)
 		end
 	end)
 
-	it("should pass all event_details fields correctly to formatter and output", function()
+	it("should pass all event_details fields correctly to formatter and dispatcher", function()
 		-- We need both the emitter and the passthrough logger
 		local passthrough_logger = create_mock_logger("passthrough_logger", _G.log.levels.INFO, {
 			{
 				formatter_func = mock_formatter_func,
-				output_func = mock_output_func,
-				output_config = { id = "passthrough_h" },
+				dispatcher_func = mock_dispatcher_func,
+				dispatcher_config = { id = "passthrough_h" },
 			},
 		})
 
@@ -768,28 +769,28 @@ describe("ingest.dispatch_log_event", function()
 			assert.are.equal(event_details.filename, formatter_params.filename)
 			assert.are.equal(event_details.lineno, formatter_params.lineno)
 			-- source_logger_name is part of the base_record which is now formatter_calls_list[1].params
-			assert.are.equal(event_details.source_logger_name, formatter_params.source_logger_name) -- This line was already correct in the read_files output for turn 13.
+			assert.are.equal(event_details.source_logger_name, formatter_params.source_logger_name) -- This line was already correct in the read_files dispatcher for turn 13.
 		end
 
-		local output_calls_list = get_output_calls()
-		assert.are.same(1, #output_calls_list)
-		if #output_calls_list > 0 then
-			local output_input_params = output_calls_list[1].params
-			assert.are.equal(event_details.level_name, output_input_params.level_name)
-			assert.are.equal(event_details.level_no, output_input_params.level_no)
-			assert.are.equal("passthrough_logger", output_input_params.logger_name)
-			assert.is_string(output_input_params.message) -- Actual content checked by mock_formatter_func behavior
+		local dispatcher_calls_list = get_dispatcher_calls()
+		assert.are.same(1, #dispatcher_calls_list)
+		if #dispatcher_calls_list > 0 then
+			local dispatcher_input_params = dispatcher_calls_list[1].params
+			assert.are.equal(event_details.level_name, dispatcher_input_params.level_name)
+			assert.are.equal(event_details.level_no, dispatcher_input_params.level_no)
+			assert.are.equal("passthrough_logger", dispatcher_input_params.logger_name)
+			assert.is_string(dispatcher_input_params.message) -- Actual content checked by mock_formatter_func behavior
 			local expected_formatted_message =
 				string.format("Formatted: %s", string.format(event_details.message_fmt, unpack(event_details.args)))
-			assert.are.equal(expected_formatted_message, output_input_params.message)
-			assert.are.equal(event_details.timestamp, output_input_params.timestamp)
-			assert.are.equal(event_details.filename, output_input_params.filename)
-			assert.are.equal(event_details.lineno, output_input_params.lineno)
-			assert.are.equal(event_details.message_fmt, output_input_params.raw_message_fmt)
-			assert.are.same(event_details.args, output_input_params.raw_args)
-			assert.are.same(event_details.context, output_input_params.context) -- Check context
-			assert.are.equal(event_details.source_logger_name, output_input_params.source_logger_name)
-			assert.are.same("passthrough_h", output_calls_list[1].config.id)
+			assert.are.equal(expected_formatted_message, dispatcher_input_params.message)
+			assert.are.equal(event_details.timestamp, dispatcher_input_params.timestamp)
+			assert.are.equal(event_details.filename, dispatcher_input_params.filename)
+			assert.are.equal(event_details.lineno, dispatcher_input_params.lineno)
+			assert.are.equal(event_details.message_fmt, dispatcher_input_params.raw_message_fmt)
+			assert.are.same(event_details.args, dispatcher_input_params.raw_args)
+			assert.are.same(event_details.context, dispatcher_input_params.context) -- Check context
+			assert.are.equal(event_details.source_logger_name, dispatcher_input_params.source_logger_name)
+			assert.are.same("passthrough_h", dispatcher_calls_list[1].config.id)
 		end
 
 		assert.are.same(0, #get_stderr_messages())
diff --git a/spec/logger_spec.lua b/spec/logger_spec.lua
index 8a2b5b8..89e5e92 100644
--- a/spec/logger_spec.lua
+++ b/spec/logger_spec.lua
@@ -360,46 +360,47 @@ describe("lualog Logger Object", function()
 			end)
 		end)
 
-		it("logger:add_output(output_func, formatter_func, output_config) should add output correctly", function()
-			local mock_output_fn = function() end
-			local mock_formatter_fn = function() end
-			local mock_cfg = { type = "test" }
-
-			test_logger:add_output(mock_output_fn, mock_formatter_fn, mock_cfg)
-			assert.are.same(1, #test_logger.outputs)
-			local entry = test_logger.outputs[1]
-			assert.are.same(mock_output_fn, entry.output_func)
-			assert.are.same(mock_formatter_fn, entry.formatter_func)
-			assert.are.same(mock_cfg, entry.output_config)
-
-			-- Test with nil config
-			test_logger:add_output(mock_output_fn, mock_formatter_fn, nil)
-			assert.are.same(2, #test_logger.outputs)
-			local entry_nil_config = test_logger.outputs[2]
-			assert.is_table(entry_nil_config.output_config) -- Should default to {}
-			assert.are.same(0, #entry_nil_config.output_config)
-		end)
+		it("logger:add_dispatcher(dispatcher_func, formatter_func, dispatcher_config) should add dispatcher correctly",
+			function()
+				local mock_dispatcher_fn = function() end
+				local mock_formatter_fn = function() end
+				local mock_cfg = { type = "test" }
+
+				test_logger:add_dispatcher(mock_dispatcher_fn, mock_formatter_fn, mock_cfg)
+				assert.are.same(1, #test_logger.dispatchers)
+				local entry = test_logger.dispatchers[1]
+				assert.are.same(mock_dispatcher_fn, entry.dispatcher_func)
+				assert.are.same(mock_formatter_fn, entry.formatter_func)
+				assert.are.same(mock_cfg, entry.dispatcher_config)
+
+				-- Test with nil config
+				test_logger:add_dispatcher(mock_dispatcher_fn, mock_formatter_fn, nil)
+				assert.are.same(2, #test_logger.dispatchers)
+				local entry_nil_config = test_logger.dispatchers[2]
+				assert.is_table(entry_nil_config.dispatcher_config) -- Should default to {}
+				assert.are.same(0, #entry_nil_config.dispatcher_config)
+			end)
 
-		describe("logger:get_effective_outputs()", function()
-			local fresh_lualog_for_outputs
+		describe("logger:get_effective_dispatchers()", function()
+			local fresh_lualog_for_dispatchers
 			local logger_root, logger_p, logger_c
 
 			before_each(function()
 				package.loaded["lual.logger"] = nil
-				fresh_lualog_for_outputs = require("lual.logger")
+				fresh_lualog_for_dispatchers = require("lual.logger")
 				-- Use unique names for this test block to ensure clean hierarchy
-				logger_root = fresh_lualog_for_outputs.logger("eff_root")
-				logger_p = fresh_lualog_for_outputs.logger("eff_root.p")
-				logger_c = fresh_lualog_for_outputs.logger("eff_root.p.c")
-
-				-- Reset levels and outputs for these specific loggers
-				logger_root:set_level(fresh_lualog_for_outputs.levels.DEBUG)
-				logger_p:set_level(fresh_lualog_for_outputs.levels.DEBUG)
-				logger_c:set_level(fresh_lualog_for_outputs.levels.DEBUG)
-				-- Clear outputs directly for test setup (this is acceptable for tests)
-				logger_root.outputs = {}
-				logger_p.outputs = {}
-				logger_c.outputs = {}
+				logger_root = fresh_lualog_for_dispatchers.logger("eff_root")
+				logger_p = fresh_lualog_for_dispatchers.logger("eff_root.p")
+				logger_c = fresh_lualog_for_dispatchers.logger("eff_root.p.c")
+
+				-- Reset levels and dispatchers for these specific loggers
+				logger_root:set_level(fresh_lualog_for_dispatchers.levels.DEBUG)
+				logger_p:set_level(fresh_lualog_for_dispatchers.levels.DEBUG)
+				logger_c:set_level(fresh_lualog_for_dispatchers.levels.DEBUG)
+				-- Clear dispatchers directly for test setup (this is acceptable for tests)
+				logger_root.dispatchers = {}
+				logger_p.dispatchers = {}
+				logger_c.dispatchers = {}
 				logger_root:set_propagate(true)
 				logger_p:set_propagate(true)
 				logger_c:set_propagate(true)
@@ -408,78 +409,78 @@ describe("lualog Logger Object", function()
 			local mock_h_fn = function() end
 			local mock_f_fn = function() end
 
-			it("should collect outputs from self and propagating parents", function()
-				logger_c:add_output(mock_h_fn, mock_f_fn, { id = "hc" })
-				logger_p:add_output(mock_h_fn, mock_f_fn, { id = "hp" })
-				logger_root:add_output(mock_h_fn, mock_f_fn, { id = "h_root" })
-
-				local c_outputs = logger_c:get_effective_outputs()
-				assert.are.same(4, #c_outputs) -- Expect 3 local + 1 from actual root
-				assert.are.same("eff_root.p.c", c_outputs[1].owner_logger_name)
-				assert.are.same("eff_root.p", c_outputs[2].owner_logger_name)
-				assert.are.same("eff_root", c_outputs[3].owner_logger_name)
-				assert.are.same("root", c_outputs[4].owner_logger_name) -- Check the propagated root output
+			it("should collect dispatchers from self and propagating parents", function()
+				logger_c:add_dispatcher(mock_h_fn, mock_f_fn, { id = "hc" })
+				logger_p:add_dispatcher(mock_h_fn, mock_f_fn, { id = "hp" })
+				logger_root:add_dispatcher(mock_h_fn, mock_f_fn, { id = "h_root" })
+
+				local c_dispatchers = logger_c:get_effective_dispatchers()
+				assert.are.same(4, #c_dispatchers) -- Expect 3 local + 1 from actual root
+				assert.are.same("eff_root.p.c", c_dispatchers[1].owner_logger_name)
+				assert.are.same("eff_root.p", c_dispatchers[2].owner_logger_name)
+				assert.are.same("eff_root", c_dispatchers[3].owner_logger_name)
+				assert.are.same("root", c_dispatchers[4].owner_logger_name) -- Check the propagated root dispatcher
 			end)
 
 			it("should stop collecting if propagate is false on child", function()
 				-- Reset the logger system to get a clean root logger
-				fresh_lualog_for_outputs.reset_config()
+				fresh_lualog_for_dispatchers.reset_config()
 
 				-- Re-get the loggers after reset
-				logger_root = fresh_lualog_for_outputs.logger("eff_root")
-				logger_p = fresh_lualog_for_outputs.logger("eff_root.p")
-				logger_c = fresh_lualog_for_outputs.logger("eff_root.p.c")
-
-				-- Reset levels and outputs for these specific loggers
-				logger_root:set_level(fresh_lualog_for_outputs.levels.DEBUG)
-				logger_p:set_level(fresh_lualog_for_outputs.levels.DEBUG)
-				logger_c:set_level(fresh_lualog_for_outputs.levels.DEBUG)
-				logger_root.outputs = {}
-				logger_p.outputs = {}
-				logger_c.outputs = {}
+				logger_root = fresh_lualog_for_dispatchers.logger("eff_root")
+				logger_p = fresh_lualog_for_dispatchers.logger("eff_root.p")
+				logger_c = fresh_lualog_for_dispatchers.logger("eff_root.p.c")
+
+				-- Reset levels and dispatchers for these specific loggers
+				logger_root:set_level(fresh_lualog_for_dispatchers.levels.DEBUG)
+				logger_p:set_level(fresh_lualog_for_dispatchers.levels.DEBUG)
+				logger_c:set_level(fresh_lualog_for_dispatchers.levels.DEBUG)
+				logger_root.dispatchers = {}
+				logger_p.dispatchers = {}
+				logger_c.dispatchers = {}
 				logger_root:set_propagate(true)
 				logger_p:set_propagate(true)
 				logger_c:set_propagate(true)
 
-				logger_c:add_output(mock_h_fn, mock_f_fn, { id = "hc" })
-				logger_p:add_output(mock_h_fn, mock_f_fn, { id = "hp" })
-				logger_root:add_output(mock_h_fn, mock_f_fn, { id = "h_root" })
+				logger_c:add_dispatcher(mock_h_fn, mock_f_fn, { id = "hc" })
+				logger_p:add_dispatcher(mock_h_fn, mock_f_fn, { id = "hp" })
+				logger_root:add_dispatcher(mock_h_fn, mock_f_fn, { id = "h_root" })
 
 				logger_c:set_propagate(false)
-				local c_outputs = logger_c:get_effective_outputs()
-				assert.are.same(1, #c_outputs)
-				assert.are.same("eff_root.p.c", c_outputs[1].owner_logger_name)
+				local c_dispatchers = logger_c:get_effective_dispatchers()
+				assert.are.same(1, #c_dispatchers)
+				assert.are.same("eff_root.p.c", c_dispatchers[1].owner_logger_name)
 			end)
 
 			it("should stop collecting if propagate is false on parent", function()
 				-- Reset the logger system to get a clean root logger
-				fresh_lualog_for_outputs.reset_config()
+				fresh_lualog_for_dispatchers.reset_config()
 
 				-- Re-get the loggers after reset
-				logger_root = fresh_lualog_for_outputs.logger("eff_root")
-				logger_p = fresh_lualog_for_outputs.logger("eff_root.p")
-				logger_c = fresh_lualog_for_outputs.logger("eff_root.p.c")
-
-				-- Reset levels and outputs for these specific loggers
-				logger_root:set_level(fresh_lualog_for_outputs.levels.DEBUG)
-				logger_p:set_level(fresh_lualog_for_outputs.levels.DEBUG)
-				logger_c:set_level(fresh_lualog_for_outputs.levels.DEBUG)
-				logger_root.outputs = {}
-				logger_p.outputs = {}
-				logger_c.outputs = {}
+				logger_root = fresh_lualog_for_dispatchers.logger("eff_root")
+				logger_p = fresh_lualog_for_dispatchers.logger("eff_root.p")
+				logger_c = fresh_lualog_for_dispatchers.logger("eff_root.p.c")
+
+				-- Reset levels and dispatchers for these specific loggers
+				logger_root:set_level(fresh_lualog_for_dispatchers.levels.DEBUG)
+				logger_p:set_level(fresh_lualog_for_dispatchers.levels.DEBUG)
+				logger_c:set_level(fresh_lualog_for_dispatchers.levels.DEBUG)
+				logger_root.dispatchers = {}
+				logger_p.dispatchers = {}
+				logger_c.dispatchers = {}
 				logger_root:set_propagate(true)
 				logger_p:set_propagate(true)
 				logger_c:set_propagate(true)
 
-				logger_c:add_output(mock_h_fn, mock_f_fn, { id = "hc" })
-				logger_p:add_output(mock_h_fn, mock_f_fn, { id = "hp" })
-				logger_root:add_output(mock_h_fn, mock_f_fn, { id = "h_root" })
+				logger_c:add_dispatcher(mock_h_fn, mock_f_fn, { id = "hc" })
+				logger_p:add_dispatcher(mock_h_fn, mock_f_fn, { id = "hp" })
+				logger_root:add_dispatcher(mock_h_fn, mock_f_fn, { id = "h_root" })
 
 				logger_p:set_propagate(false) -- c propagates to p, but p doesn't propagate to root
-				local c_outputs = logger_c:get_effective_outputs()
-				assert.are.same(2, #c_outputs)
-				assert.are.same("eff_root.p.c", c_outputs[1].owner_logger_name)
-				assert.are.same("eff_root.p", c_outputs[2].owner_logger_name)
+				local c_dispatchers = logger_c:get_effective_dispatchers()
+				assert.are.same(2, #c_dispatchers)
+				assert.are.same("eff_root.p.c", c_dispatchers[1].owner_logger_name)
+				assert.are.same("eff_root.p", c_dispatchers[2].owner_logger_name)
 			end)
 		end)
 	end)
@@ -491,7 +492,7 @@ describe("lual.logger (Facade)", function()
 		package.loaded["lual.logger"] = nil
 		package.loaded["lual.core.logging"] = nil
 		package.loaded["lual.core.levels"] = nil
-		package.loaded["lual.outputs.init"] = nil
+		package.loaded["lual.dispatchers.init"] = nil
 		package.loaded["lual.formatters.init"] = nil
 		package.loaded["lual.ingest"] = nil
 
@@ -500,23 +501,24 @@ describe("lual.logger (Facade)", function()
 	end)
 
 	describe("log.init_default_config()", function()
-		it("should add one default output to the root logger", function()
+		it("should add one default dispatcher to the root logger", function()
 			local root_logger = lualog.logger("root")
 			assert.is_not_nil(root_logger)
-			assert.are.same(1, #root_logger.outputs, "Root logger should have 1 output after init.")
-			if #root_logger.outputs == 1 then
-				local output_entry = root_logger.outputs[1]
-				assert.is_function(output_entry.output_func)
-				assert.is_function(output_entry.formatter_func)
+			assert.are.same(1, #root_logger.dispatchers, "Root logger should have 1 dispatcher after init.")
+			if #root_logger.dispatchers == 1 then
+				local dispatcher_entry = root_logger.dispatchers[1]
+				assert.is_function(dispatcher_entry.dispatcher_func)
+				assert.is_function(dispatcher_entry.formatter_func)
 			end
 		end)
 
-		it("calling init_default_config multiple times should still result in one default output", function()
+		it("calling init_default_config multiple times should still result in one default dispatcher", function()
 			lualog.init_default_config() -- Call again
 			lualog.init_default_config() -- Call yet again
 
 			local root_logger = lualog.logger("root")
-			assert.are.same(1, #root_logger.outputs, "Root logger should still have 1 output after multiple inits.")
+			assert.are.same(1, #root_logger.dispatchers,
+				"Root logger should still have 1 dispatcher after multiple inits.")
 		end)
 	end)
 
@@ -532,7 +534,7 @@ describe("lual.logger (Facade)", function()
 			assert.are.same(lualog.levels.INFO, logger2.level, "Logger level should be default INFO after reset.")
 
 			local root_logger = lualog.logger("root")
-			assert.are.same(1, #root_logger.outputs, "Root logger should have 1 default output after reset.")
+			assert.are.same(1, #root_logger.dispatchers, "Root logger should have 1 default dispatcher after reset.")
 		end)
 	end)
 
@@ -546,13 +548,13 @@ describe("lual.logger (Facade)", function()
 			test_logger:set_level(lualog.levels.DEBUG)
 			assert.are.same(lualog.levels.DEBUG, test_logger.level)
 
-			-- Test adding output directly on logger instance
+			-- Test adding dispatcher directly on logger instance
 			local mock_h = function() end
 			local mock_f = function() end
-			test_logger:add_output(mock_h, mock_f, { id = "test1" })
-			assert.are.same(1, #test_logger.outputs)
-			if #test_logger.outputs == 1 then
-				assert.are.same(mock_h, test_logger.outputs[1].output_func)
+			test_logger:add_dispatcher(mock_h, mock_f, { id = "test1" })
+			assert.are.same(1, #test_logger.dispatchers)
+			if #test_logger.dispatchers == 1 then
+				assert.are.same(mock_h, test_logger.dispatchers[1].dispatcher_func)
 			end
 		end)
 
@@ -576,7 +578,7 @@ describe("lual.logger (Facade)", function()
 			local utc_logger = fresh_lualog.logger({
 				name = "config_test",
 				timezone = "UTC", -- Test case insensitive
-				output = "console",
+				dispatcher = "console",
 				formatter = "text"
 			})
 
@@ -591,7 +593,7 @@ describe("lual.logger (Facade)", function()
 			local utc_logger = fresh_lualog.logger({
 				name = "utc_test",
 				timezone = "utc",
-				output = "console",
+				dispatcher = "console",
 				formatter = "text"
 			})
 			assert.are.equal("utc", utc_logger.timezone)
@@ -600,7 +602,7 @@ describe("lual.logger (Facade)", function()
 			local local_logger = fresh_lualog.logger({
 				name = "local_test",
 				timezone = "local",
-				output = "console",
+				dispatcher = "console",
 				formatter = "text"
 			})
 			assert.are.equal("local", local_logger.timezone)
@@ -609,7 +611,7 @@ describe("lual.logger (Facade)", function()
 		it("should handle timezone in shortcut API", function()
 			local fresh_lualog = require("lual.logger")
 			local shortcut_logger = fresh_lualog.logger({
-				output = "console",
+				dispatcher = "console",
 				formatter = "text",
 				timezone = "utc"
 			})
diff --git a/spec/propagation_spec.lua b/spec/propagation_spec.lua
index c353aac..8f1054a 100644
--- a/spec/propagation_spec.lua
+++ b/spec/propagation_spec.lua
@@ -6,7 +6,7 @@ local spy = require("luassert.spy")
 local assert = require("luassert")
 
 describe("Logger Propagation", function()
-    local mock_output_calls
+    local mock_dispatcher_calls
     local mock_formatter_calls
 
     before_each(function()
@@ -16,21 +16,21 @@ describe("Logger Propagation", function()
         package.loaded["lual.ingest"] = nil
         lual = require("lual.logger")
 
-        -- Track output and formatter calls
-        mock_output_calls = {}
+        -- Track dispatcher and formatter calls
+        mock_dispatcher_calls = {}
         mock_formatter_calls = {}
 
-        -- Clear any default outputs that might be set up
+        -- Clear any default dispatchers that might be set up
         local root_logger = lual.logger("root")
-        -- Clear outputs directly for test setup (this is acceptable for tests)
-        root_logger.outputs = {}
+        -- Clear dispatchers directly for test setup (this is acceptable for tests)
+        root_logger.dispatchers = {}
     end)
 
-    local function create_mock_output(name)
+    local function create_mock_dispatcher(name)
         return function(record)
-            table.insert(mock_output_calls, {
-                output_name = name,
-                logger_name = record.logger_name,               -- Owner of the output
+            table.insert(mock_dispatcher_calls, {
+                dispatcher_name = name,
+                logger_name = record.logger_name,               -- Owner of the dispatcher
                 source_logger_name = record.source_logger_name, -- Originator of the message
                 message = record.message,
                 level_name = record.level_name
@@ -42,7 +42,7 @@ describe("Logger Propagation", function()
         return function(record)
             table.insert(mock_formatter_calls, {
                 formatter_name = name,
-                logger_name = record.logger_name,               -- Owner of the output
+                logger_name = record.logger_name,               -- Owner of the dispatcher
                 source_logger_name = record.source_logger_name, -- Originator of the message
                 message_fmt = record.message_fmt,
                 level_name = record.level_name
@@ -57,34 +57,34 @@ describe("Logger Propagation", function()
             local app_logger = lual.logger("app")
             local db_logger = lual.logger("app.database")
 
-            -- Add outputs to different levels
-            root_logger:add_output(create_mock_output("root_output"), create_mock_formatter("root_formatter"))
-            app_logger:add_output(create_mock_output("app_output"), create_mock_formatter("app_formatter"))
+            -- Add dispatchers to different levels
+            root_logger:add_dispatcher(create_mock_dispatcher("root_dispatcher"), create_mock_formatter("root_formatter"))
+            app_logger:add_dispatcher(create_mock_dispatcher("app_dispatcher"), create_mock_formatter("app_formatter"))
 
             -- Log from the deepest logger
             db_logger:info("Database connection established")
 
-            -- Should have called outputs from both app and root loggers
-            assert.are.equal(2, #mock_output_calls)
+            -- Should have called dispatchers from both app and root loggers
+            assert.are.equal(2, #mock_dispatcher_calls)
 
-            -- Check that app logger output was called
+            -- Check that app logger dispatcher was called
             local app_call = nil
             local root_call = nil
-            for _, call in ipairs(mock_output_calls) do
-                if call.output_name == "app_output" then
+            for _, call in ipairs(mock_dispatcher_calls) do
+                if call.dispatcher_name == "app_dispatcher" then
                     app_call = call
-                elseif call.output_name == "root_output" then
+                elseif call.dispatcher_name == "root_dispatcher" then
                     root_call = call
                 end
             end
 
             assert.is_not_nil(app_call)
-            assert.are.equal("app", app_call.logger_name)                 -- Owner of the output
+            assert.are.equal("app", app_call.logger_name)                 -- Owner of the dispatcher
             assert.are.equal("app.database", app_call.source_logger_name) -- Originator of the message
             assert.are.equal("INFO", app_call.level_name)
 
             assert.is_not_nil(root_call)
-            assert.are.equal("root", root_call.logger_name)                -- Owner of the output
+            assert.are.equal("root", root_call.logger_name)                -- Owner of the dispatcher
             assert.are.equal("app.database", root_call.source_logger_name) -- Originator of the message
             assert.are.equal("INFO", root_call.level_name)
 
@@ -92,33 +92,33 @@ describe("Logger Propagation", function()
             assert.are.equal(2, #mock_formatter_calls)
         end)
 
-        it("should include logger's own outputs when propagating", function()
+        it("should include logger's own dispatchers when propagating", function()
             local app_logger = lual.logger("app")
             local db_logger = lual.logger("app.database")
 
-            app_logger:add_output(create_mock_output("app_output"), create_mock_formatter("app_formatter"))
-            db_logger:add_output(create_mock_output("db_output"), create_mock_formatter("db_formatter"))
+            app_logger:add_dispatcher(create_mock_dispatcher("app_dispatcher"), create_mock_formatter("app_formatter"))
+            db_logger:add_dispatcher(create_mock_dispatcher("db_dispatcher"), create_mock_formatter("db_formatter"))
 
             db_logger:warn("Connection timeout")
 
-            -- Should call both db_logger's own output and app_logger's output
-            assert.are.equal(2, #mock_output_calls)
+            -- Should call both db_logger's own dispatcher and app_logger's dispatcher
+            assert.are.equal(2, #mock_dispatcher_calls)
 
             local db_call = nil
             local app_call = nil
-            for _, call in ipairs(mock_output_calls) do
-                if call.output_name == "db_output" then
+            for _, call in ipairs(mock_dispatcher_calls) do
+                if call.dispatcher_name == "db_dispatcher" then
                     db_call = call
-                elseif call.output_name == "app_output" then
+                elseif call.dispatcher_name == "app_dispatcher" then
                     app_call = call
                 end
             end
 
             assert.is_not_nil(db_call)
             assert.is_not_nil(app_call)
-            assert.are.equal("app.database", db_call.logger_name)         -- db_logger owns its output
+            assert.are.equal("app.database", db_call.logger_name)         -- db_logger owns its dispatcher
             assert.are.equal("app.database", db_call.source_logger_name)  -- db_logger originated the message
-            assert.are.equal("app", app_call.logger_name)                 -- app_logger owns its output
+            assert.are.equal("app", app_call.logger_name)                 -- app_logger owns its dispatcher
             assert.are.equal("app.database", app_call.source_logger_name) -- db_logger originated the message
         end)
     end)
@@ -129,20 +129,21 @@ describe("Logger Propagation", function()
             local app_logger = lual.logger("app")
             local security_logger = lual.logger("app.security")
 
-            root_logger:add_output(create_mock_output("root_output"), create_mock_formatter("root_formatter"))
-            app_logger:add_output(create_mock_output("app_output"), create_mock_formatter("app_formatter"))
-            security_logger:add_output(create_mock_output("security_output"), create_mock_formatter("security_formatter"))
+            root_logger:add_dispatcher(create_mock_dispatcher("root_dispatcher"), create_mock_formatter("root_formatter"))
+            app_logger:add_dispatcher(create_mock_dispatcher("app_dispatcher"), create_mock_formatter("app_formatter"))
+            security_logger:add_dispatcher(create_mock_dispatcher("security_dispatcher"),
+                create_mock_formatter("security_formatter"))
 
             -- Disable propagation on security logger
             security_logger:set_propagate(false)
 
             security_logger:error("Security violation detected")
 
-            -- Should only call security logger's output, not parent outputs
-            assert.are.equal(1, #mock_output_calls)
-            assert.are.equal("security_output", mock_output_calls[1].output_name)
-            assert.are.equal("app.security", mock_output_calls[1].logger_name)
-            assert.are.equal("app.security", mock_output_calls[1].source_logger_name)
+            -- Should only call security logger's dispatcher, not parent dispatchers
+            assert.are.equal(1, #mock_dispatcher_calls)
+            assert.are.equal("security_dispatcher", mock_dispatcher_calls[1].dispatcher_name)
+            assert.are.equal("app.security", mock_dispatcher_calls[1].logger_name)
+            assert.are.equal("app.security", mock_dispatcher_calls[1].source_logger_name)
         end)
 
         it("should stop propagation at the logger where propagate is false", function()
@@ -151,30 +152,30 @@ describe("Logger Propagation", function()
             local db_logger = lual.logger("app.database")
             local conn_logger = lual.logger("app.database.connection")
 
-            root_logger:add_output(create_mock_output("root_output"), create_mock_formatter("root_formatter"))
-            app_logger:add_output(create_mock_output("app_output"), create_mock_formatter("app_formatter"))
-            db_logger:add_output(create_mock_output("db_output"), create_mock_formatter("db_formatter"))
-            conn_logger:add_output(create_mock_output("conn_output"), create_mock_formatter("conn_formatter"))
+            root_logger:add_dispatcher(create_mock_dispatcher("root_dispatcher"), create_mock_formatter("root_formatter"))
+            app_logger:add_dispatcher(create_mock_dispatcher("app_dispatcher"), create_mock_formatter("app_formatter"))
+            db_logger:add_dispatcher(create_mock_dispatcher("db_dispatcher"), create_mock_formatter("db_formatter"))
+            conn_logger:add_dispatcher(create_mock_dispatcher("conn_dispatcher"), create_mock_formatter("conn_formatter"))
 
             -- Disable propagation at database level
             db_logger:set_propagate(false)
 
             conn_logger:info("Connection pool status") -- Use INFO instead of DEBUG to ensure it passes level filters
 
-            -- Should call conn and db outputs, but not app or root
-            assert.are.equal(2, #mock_output_calls)
+            -- Should call conn and db dispatchers, but not app or root
+            assert.are.equal(2, #mock_dispatcher_calls)
 
-            local output_names = {}
-            for _, call in ipairs(mock_output_calls) do
-                table.insert(output_names, call.output_name)
+            local dispatcher_names = {}
+            for _, call in ipairs(mock_dispatcher_calls) do
+                table.insert(dispatcher_names, call.dispatcher_name)
                 -- All should have the same source
                 assert.are.equal("app.database.connection", call.source_logger_name)
             end
 
-            assert.truthy(table.concat(output_names, ","):find("conn_output"))
-            assert.truthy(table.concat(output_names, ","):find("db_output"))
-            assert.is_nil(table.concat(output_names, ","):find("app_output"))
-            assert.is_nil(table.concat(output_names, ","):find("root_output"))
+            assert.truthy(table.concat(dispatcher_names, ","):find("conn_dispatcher"))
+            assert.truthy(table.concat(dispatcher_names, ","):find("db_dispatcher"))
+            assert.is_nil(table.concat(dispatcher_names, ","):find("app_dispatcher"))
+            assert.is_nil(table.concat(dispatcher_names, ","):find("root_dispatcher"))
         end)
     end)
 
@@ -189,34 +190,35 @@ describe("Logger Propagation", function()
             app_logger:set_level(lual.levels.INFO)     -- Info and above
             debug_logger:set_level(lual.levels.DEBUG)  -- Everything
 
-            root_logger:add_output(create_mock_output("root_output"), create_mock_formatter("root_formatter"))
-            app_logger:add_output(create_mock_output("app_output"), create_mock_formatter("app_formatter"))
-            debug_logger:add_output(create_mock_output("debug_output"), create_mock_formatter("debug_formatter"))
+            root_logger:add_dispatcher(create_mock_dispatcher("root_dispatcher"), create_mock_formatter("root_formatter"))
+            app_logger:add_dispatcher(create_mock_dispatcher("app_dispatcher"), create_mock_formatter("app_formatter"))
+            debug_logger:add_dispatcher(create_mock_dispatcher("debug_dispatcher"),
+                create_mock_formatter("debug_formatter"))
 
             -- Log an INFO message from debug logger
             debug_logger:info("Debug session started")
 
             -- Should be processed by debug_logger and app_logger, but filtered by root_logger
-            assert.are.equal(2, #mock_output_calls)
+            assert.are.equal(2, #mock_dispatcher_calls)
 
-            local output_names = {}
-            for _, call in ipairs(mock_output_calls) do
-                table.insert(output_names, call.output_name)
+            local dispatcher_names = {}
+            for _, call in ipairs(mock_dispatcher_calls) do
+                table.insert(dispatcher_names, call.dispatcher_name)
                 -- All should have the same source
                 assert.are.equal("app.debug", call.source_logger_name)
             end
 
-            assert.truthy(table.concat(output_names, ","):find("debug_output"))
-            assert.truthy(table.concat(output_names, ","):find("app_output"))
-            assert.is_nil(table.concat(output_names, ","):find("root_output"))
+            assert.truthy(table.concat(dispatcher_names, ","):find("debug_dispatcher"))
+            assert.truthy(table.concat(dispatcher_names, ","):find("app_dispatcher"))
+            assert.is_nil(table.concat(dispatcher_names, ","):find("root_dispatcher"))
         end)
 
         it("should not propagate if the originating logger filters the message", function()
             local app_logger = lual.logger("app")
             local db_logger = lual.logger("app.database")
 
-            app_logger:add_output(create_mock_output("app_output"), create_mock_formatter("app_formatter"))
-            db_logger:add_output(create_mock_output("db_output"), create_mock_formatter("db_formatter"))
+            app_logger:add_dispatcher(create_mock_dispatcher("app_dispatcher"), create_mock_formatter("app_formatter"))
+            db_logger:add_dispatcher(create_mock_dispatcher("db_dispatcher"), create_mock_formatter("db_formatter"))
 
             -- Set db_logger to only accept ERROR and above
             db_logger:set_level(lual.levels.ERROR)
@@ -224,8 +226,8 @@ describe("Logger Propagation", function()
             -- Try to log an INFO message
             db_logger:info("This should be filtered out")
 
-            -- No outputs should be called since the message is filtered at the source
-            assert.are.equal(0, #mock_output_calls)
+            -- No dispatchers should be called since the message is filtered at the source
+            assert.are.equal(0, #mock_dispatcher_calls)
             assert.are.equal(0, #mock_formatter_calls)
         end)
     end)
@@ -241,10 +243,10 @@ describe("Logger Propagation", function()
                 lual.logger("webapp.api.v1.users.auth")
             }
 
-            -- Add outputs to each logger
+            -- Add dispatchers to each logger
             for i, logger in ipairs(loggers) do
-                logger:add_output(
-                    create_mock_output("output_" .. i),
+                logger:add_dispatcher(
+                    create_mock_dispatcher("dispatcher_" .. i),
                     create_mock_formatter("formatter_" .. i)
                 )
             end
@@ -253,12 +255,12 @@ describe("Logger Propagation", function()
             loggers[6]:critical("Authentication failed")
 
             -- Should propagate through all 6 loggers
-            assert.are.equal(6, #mock_output_calls)
+            assert.are.equal(6, #mock_dispatcher_calls)
 
-            -- Check that each output has the correct owner and source
+            -- Check that each dispatcher has the correct owner and source
             local expected_owners = { "webapp.api.v1.users.auth", "webapp.api.v1.users", "webapp.api.v1", "webapp.api",
                 "webapp", "root" }
-            for i, call in ipairs(mock_output_calls) do
+            for i, call in ipairs(mock_dispatcher_calls) do
                 assert.are.equal("webapp.api.v1.users.auth", call.source_logger_name) -- Same source for all
                 assert.are.equal("CRITICAL", call.level_name)
                 -- The owner should be one of the expected owners
@@ -266,71 +268,71 @@ describe("Logger Propagation", function()
             end
         end)
 
-        it("should handle multiple outputs per logger", function()
+        it("should handle multiple dispatchers per logger", function()
             local app_logger = lual.logger("app")
             local db_logger = lual.logger("app.database")
 
-            -- Add multiple outputs to app logger
-            app_logger:add_output(create_mock_output("app_console"), create_mock_formatter("app_console_fmt"))
-            app_logger:add_output(create_mock_output("app_file"), create_mock_formatter("app_file_fmt"))
+            -- Add multiple dispatchers to app logger
+            app_logger:add_dispatcher(create_mock_dispatcher("app_console"), create_mock_formatter("app_console_fmt"))
+            app_logger:add_dispatcher(create_mock_dispatcher("app_file"), create_mock_formatter("app_file_fmt"))
 
-            -- Add one output to db logger
-            db_logger:add_output(create_mock_output("db_debug"), create_mock_formatter("db_debug_fmt"))
+            -- Add one dispatcher to db logger
+            db_logger:add_dispatcher(create_mock_dispatcher("db_debug"), create_mock_formatter("db_debug_fmt"))
 
             db_logger:error("Database error occurred")
 
-            -- Should call all 3 outputs (1 from db, 2 from app)
-            assert.are.equal(3, #mock_output_calls)
+            -- Should call all 3 dispatchers (1 from db, 2 from app)
+            assert.are.equal(3, #mock_dispatcher_calls)
 
-            local output_names = {}
-            for _, call in ipairs(mock_output_calls) do
-                table.insert(output_names, call.output_name)
+            local dispatcher_names = {}
+            for _, call in ipairs(mock_dispatcher_calls) do
+                table.insert(dispatcher_names, call.dispatcher_name)
                 -- All should have the same source
                 assert.are.equal("app.database", call.source_logger_name)
             end
 
-            assert.truthy(table.concat(output_names, ","):find("db_debug"))
-            assert.truthy(table.concat(output_names, ","):find("app_console"))
-            assert.truthy(table.concat(output_names, ","):find("app_file"))
+            assert.truthy(table.concat(dispatcher_names, ","):find("db_debug"))
+            assert.truthy(table.concat(dispatcher_names, ","):find("app_console"))
+            assert.truthy(table.concat(dispatcher_names, ","):find("app_file"))
         end)
     end)
 
     describe("Edge Cases", function()
-        it("should handle logger with no outputs but propagating parents", function()
+        it("should handle logger with no dispatchers but propagating parents", function()
             local root_logger = lual.logger("root")
             local app_logger = lual.logger("app")
             local db_logger = lual.logger("app.database")
 
-            -- Only root has outputs
-            root_logger:add_output(create_mock_output("root_output"), create_mock_formatter("root_formatter"))
+            -- Only root has dispatchers
+            root_logger:add_dispatcher(create_mock_dispatcher("root_dispatcher"), create_mock_formatter("root_formatter"))
 
-            -- app_logger and db_logger have no outputs
+            -- app_logger and db_logger have no dispatchers
 
             db_logger:info("Database query completed")
 
             -- Should still propagate to root
-            assert.are.equal(1, #mock_output_calls)
-            assert.are.equal("root_output", mock_output_calls[1].output_name)
-            assert.are.equal("root", mock_output_calls[1].logger_name)                -- Root owns the output
-            assert.are.equal("app.database", mock_output_calls[1].source_logger_name) -- db_logger originated the message
+            assert.are.equal(1, #mock_dispatcher_calls)
+            assert.are.equal("root_dispatcher", mock_dispatcher_calls[1].dispatcher_name)
+            assert.are.equal("root", mock_dispatcher_calls[1].logger_name)                -- Root owns the dispatcher
+            assert.are.equal("app.database", mock_dispatcher_calls[1].source_logger_name) -- db_logger originated the message
         end)
 
         it("should handle root logger with propagate=false", function()
             local root_logger = lual.logger("root")
             local app_logger = lual.logger("app")
 
-            root_logger:add_output(create_mock_output("root_output"), create_mock_formatter("root_formatter"))
-            app_logger:add_output(create_mock_output("app_output"), create_mock_formatter("app_formatter"))
+            root_logger:add_dispatcher(create_mock_dispatcher("root_dispatcher"), create_mock_formatter("root_formatter"))
+            app_logger:add_dispatcher(create_mock_dispatcher("app_dispatcher"), create_mock_formatter("app_formatter"))
 
             -- Disable propagation on root (shouldn't matter since it has no parent)
             root_logger:set_propagate(false)
 
             app_logger:warn("Application warning")
 
-            -- Should still call both outputs since root is the top of the hierarchy
-            assert.are.equal(2, #mock_output_calls)
+            -- Should still call both dispatchers since root is the top of the hierarchy
+            assert.are.equal(2, #mock_dispatcher_calls)
 
-            for _, call in ipairs(mock_output_calls) do
+            for _, call in ipairs(mock_dispatcher_calls) do
                 assert.are.equal("app", call.source_logger_name) -- app_logger originated the message
             end
         end)
@@ -340,15 +342,16 @@ describe("Logger Propagation", function()
             local app_logger = lual.logger("app")
             local app_sub_logger = lual.logger("app.app") -- Confusing but valid
 
-            app_logger:add_output(create_mock_output("app_output"), create_mock_formatter("app_formatter"))
-            app_sub_logger:add_output(create_mock_output("app_sub_output"), create_mock_formatter("app_sub_formatter"))
+            app_logger:add_dispatcher(create_mock_dispatcher("app_dispatcher"), create_mock_formatter("app_formatter"))
+            app_sub_logger:add_dispatcher(create_mock_dispatcher("app_sub_dispatcher"),
+                create_mock_formatter("app_sub_formatter"))
 
             app_sub_logger:info("Confusing hierarchy test")
 
-            assert.are.equal(2, #mock_output_calls)
+            assert.are.equal(2, #mock_dispatcher_calls)
 
-            -- Check that each output has the correct owner and source
-            for _, call in ipairs(mock_output_calls) do
+            -- Check that each dispatcher has the correct owner and source
+            for _, call in ipairs(mock_dispatcher_calls) do
                 assert.are.equal("app.app", call.source_logger_name) -- app_sub_logger originated the message
                 -- The owner should be either "app.app" or "app"
                 assert.truthy(call.logger_name == "app.app" or call.logger_name == "app")
diff --git a/spec/schema/validation_spec.lua b/spec/schema/validation_spec.lua
index 00be6f5..85f91fd 100644
--- a/spec/schema/validation_spec.lua
+++ b/spec/schema/validation_spec.lua
@@ -10,7 +10,7 @@ describe("Schema Validation", function()
                 level = "info",
                 propagate = true,
                 timezone = "utc",
-                outputs = {
+                dispatchers = {
                     { type = "console", formatter = "text" },
                     { type = "file",    formatter = "json", path = "test.log" }
                 }
@@ -82,103 +82,103 @@ describe("Schema Validation", function()
         end)
     end)
 
-    describe("Output validation", function()
-        it("should validate a valid console output", function()
-            local output = {
+    describe("dispatcher validation", function()
+        it("should validate a valid console dispatcher", function()
+            local dispatcher = {
                 type = "console",
                 formatter = "text"
             }
 
-            local result = schema.validate_output(output)
+            local result = schema.validate_dispatcher(dispatcher)
 
             assert.is_true(next(result._errors) == nil, "Should have no errors")
-            assert.are.same(output.type, result.data.type)
-            assert.are.same(output.formatter, result.data.formatter)
+            assert.are.same(dispatcher.type, result.data.type)
+            assert.are.same(dispatcher.formatter, result.data.formatter)
         end)
 
-        it("should validate a valid file output", function()
-            local output = {
+        it("should validate a valid file dispatcher", function()
+            local dispatcher = {
                 type = "file",
                 formatter = "json",
                 path = "test.log"
             }
 
-            local result = schema.validate_output(output)
+            local result = schema.validate_dispatcher(dispatcher)
 
             assert.is_true(next(result._errors) == nil, "Should have no errors")
-            assert.are.same(output.path, result.data.path)
+            assert.are.same(dispatcher.path, result.data.path)
         end)
 
         it("should require type field", function()
-            local output = {
+            local dispatcher = {
                 formatter = "text"
             }
 
-            local result = schema.validate_output(output)
+            local result = schema.validate_dispatcher(dispatcher)
 
             assert.is_not_nil(result._errors.type)
-            local expected_error = config_schema.generate_expected_error("OutputSchema", "type", "required")
+            local expected_error = config_schema.generate_expected_error("dispatcherschema", "type", "required")
             assert.are.equal(expected_error, result._errors.type)
         end)
 
         it("should require formatter field", function()
-            local output = {
+            local dispatcher = {
                 type = "console"
             }
 
-            local result = schema.validate_output(output)
+            local result = schema.validate_dispatcher(dispatcher)
 
             assert.is_not_nil(result._errors.formatter)
-            local expected_error = config_schema.generate_expected_error("OutputSchema", "formatter", "required")
+            local expected_error = config_schema.generate_expected_error("dispatcherschema", "formatter", "required")
             assert.are.equal(expected_error, result._errors.formatter)
         end)
 
-        it("should require path for file outputs", function()
-            local output = {
+        it("should require path for file dispatchers", function()
+            local dispatcher = {
                 type = "file",
                 formatter = "text"
             }
 
-            local result = schema.validate_output(output)
+            local result = schema.validate_dispatcher(dispatcher)
 
             assert.is_not_nil(result._errors.path)
-            local expected_error = config_schema.generate_expected_error("OutputSchema", "path", "conditional")
+            local expected_error = config_schema.generate_expected_error("dispatcherschema", "path", "conditional")
             assert.are.equal(expected_error, result._errors.path)
         end)
 
-        it("should reject invalid output type", function()
-            local output = {
+        it("should reject invalid dispatcher type", function()
+            local dispatcher = {
                 type = "invalid",
                 formatter = "text"
             }
 
-            local result = schema.validate_output(output)
+            local result = schema.validate_dispatcher(dispatcher)
 
             assert.is_not_nil(result._errors.type)
-            local expected_error = config_schema.generate_expected_error("OutputSchema", "type", "invalid_value",
+            local expected_error = config_schema.generate_expected_error("dispatcherschema", "type", "invalid_value",
                 "invalid")
             assert.are.equal(expected_error, result._errors.type)
         end)
 
         it("should reject invalid formatter type", function()
-            local output = {
+            local dispatcher = {
                 type = "console",
                 formatter = "invalid"
             }
 
-            local result = schema.validate_output(output)
+            local result = schema.validate_dispatcher(dispatcher)
 
             assert.is_not_nil(result._errors.formatter)
-            local expected_error = config_schema.generate_expected_error("OutputSchema", "formatter", "invalid_value",
+            local expected_error = config_schema.generate_expected_error("dispatcherschema", "formatter", "invalid_value",
                 "invalid")
             assert.are.equal(expected_error, result._errors.formatter)
         end)
     end)
 
     describe("Nested validation", function()
-        it("should validate nested outputs array", function()
+        it("should validate nested dispatchers array", function()
             local config = {
-                outputs = {
+                dispatchers = {
                     { type = "console", formatter = "text" },
                     { type = "file",    formatter = "json", path = "test.log" }
                 }
@@ -187,12 +187,12 @@ describe("Schema Validation", function()
             local result = schema.validate_config(config)
 
             assert.is_true(next(result._errors) == nil, "Should have no errors")
-            assert.are.same(2, #result.data.outputs)
+            assert.are.same(2, #result.data.dispatchers)
         end)
 
-        it("should report errors in nested outputs", function()
+        it("should report errors in nested dispatchers", function()
             local config = {
-                outputs = {
+                dispatchers = {
                     { type = "console", formatter = "text" },
                     { type = "invalid", formatter = "text" }
                 }
@@ -200,9 +200,9 @@ describe("Schema Validation", function()
 
             local result = schema.validate_config(config)
 
-            assert.is_not_nil(result._errors["outputs[2]"])
-            assert.is_not_nil(result._errors["outputs[2]"].type)
-            assert.matches("Invalid output type", result._errors["outputs[2]"].type)
+            assert.is_not_nil(result._errors["dispatchers[2]"])
+            assert.is_not_nil(result._errors["dispatchers[2]"].type)
+            assert.matches("Invalid dispatcher type", result._errors["dispatchers[2]"].type)
         end)
     end)
 
diff --git a/spec/shortcut_api_spec.lua b/spec/shortcut_api_spec.lua
index a3521fc..057e23e 100644
--- a/spec/shortcut_api_spec.lua
+++ b/spec/shortcut_api_spec.lua
@@ -31,15 +31,15 @@ describe("Shortcut Declarative API", function()
 
     describe("Detection and validation", function()
         it("should detect shortcut config format", function()
-            local shortcut_config = { output = "console", formatter = "text" }
-            local standard_config = { outputs = { { type = "console", formatter = "text" } } }
+            local shortcut_config = { dispatcher = "console", formatter = "text" }
+            local standard_config = { dispatchers = { { type = "console", formatter = "text" } } }
 
             assert.is_true(config.is_shortcut_config(shortcut_config))
             assert.is_false(config.is_shortcut_config(standard_config))
         end)
 
-        it("should detect shortcut config with only output field", function()
-            local config_table = { output = "console" }
+        it("should detect shortcut config with only dispatcher field", function()
+            local config_table = { dispatcher = "console" }
             assert.is_true(config.is_shortcut_config(config_table))
         end)
 
@@ -50,10 +50,10 @@ describe("Shortcut Declarative API", function()
     end)
 
     describe("Basic shortcut functionality", function()
-        it("should create a logger with console output using shortcut syntax", function()
+        it("should create a logger with console dispatcher using shortcut syntax", function()
             local logger = lualog.logger({
                 name = "test.shortcut.console",
-                output = "console",
+                dispatcher = "console",
                 formatter = "text",
                 level = "debug"
             })
@@ -61,18 +61,18 @@ describe("Shortcut Declarative API", function()
             assert.is_not_nil(logger)
             assert.are.same("test.shortcut.console", logger.name)
             assert.are.same(lualog.levels.DEBUG, logger.level)
-            assert.are.same(1, #logger.outputs)
+            assert.are.same(1, #logger.dispatchers)
 
-            local output = logger.outputs[1]
-            assert.is_function(output.output_func)
-            assert.is_true(is_callable(output.formatter_func))
-            assert.is_table(output.output_config)
+            local dispatcher = logger.dispatchers[1]
+            assert.is_function(dispatcher.dispatcher_func)
+            assert.is_true(is_callable(dispatcher.formatter_func))
+            assert.is_table(dispatcher.dispatcher_config)
         end)
 
-        it("should create a logger with file output using shortcut syntax", function()
+        it("should create a logger with file dispatcher using shortcut syntax", function()
             local logger = lualog.logger({
                 name = "test.shortcut.file",
-                output = "file",
+                dispatcher = "file",
                 path = "test.log",
                 formatter = "color",
                 level = "info"
@@ -81,17 +81,17 @@ describe("Shortcut Declarative API", function()
             assert.is_not_nil(logger)
             assert.are.same("test.shortcut.file", logger.name)
             assert.are.same(lualog.levels.INFO, logger.level)
-            assert.are.same(1, #logger.outputs)
+            assert.are.same(1, #logger.dispatchers)
 
-            local output = logger.outputs[1]
-            assert.is_function(output.output_func)
-            assert.is_true(is_callable(output.formatter_func))
-            assert.are.same("test.log", output.output_config.path)
+            local dispatcher = logger.dispatchers[1]
+            assert.is_function(dispatcher.dispatcher_func)
+            assert.is_true(is_callable(dispatcher.formatter_func))
+            assert.are.same("test.log", dispatcher.dispatcher_config.path)
         end)
 
         it("should create a logger with minimal shortcut config", function()
             local logger = lualog.logger({
-                output = "console",
+                dispatcher = "console",
                 formatter = "text"
             })
 
@@ -99,64 +99,64 @@ describe("Shortcut Declarative API", function()
             assert.are.same("root", logger.name)              -- Default name
             assert.are.same(lualog.levels.INFO, logger.level) -- Default level
             assert.is_true(logger.propagate)                  -- Default propagate
-            assert.are.same(1, #logger.outputs)
+            assert.are.same(1, #logger.dispatchers)
         end)
 
-        it("should support console output with custom stream", function()
+        it("should support console dispatcher with custom stream", function()
             local logger = lualog.logger({
                 name = "test.shortcut.stderr",
-                output = "console",
+                dispatcher = "console",
                 formatter = "color",
                 stream = io.stderr
             })
 
-            assert.are.same(1, #logger.outputs)
-            local output = logger.outputs[1]
-            assert.are.same(io.stderr, output.output_config.stream)
+            assert.are.same(1, #logger.dispatchers)
+            local dispatcher = logger.dispatchers[1]
+            assert.are.same(io.stderr, dispatcher.dispatcher_config.stream)
         end)
     end)
 
     describe("Shortcut config validation", function()
-        it("should reject shortcut config without output field", function()
+        it("should reject shortcut config without dispatcher field", function()
             assert.has_error(function()
                 lualog.logger({
                     formatter = "text"
                 })
-            end, "Invalid shortcut config: Shortcut config must have an 'output' field")
+            end, "Invalid shortcut config: Shortcut config must have an 'dispatcher' field")
         end)
 
         it("should reject shortcut config without formatter field", function()
             assert.has_error(function()
                 lualog.logger({
-                    output = "console"
+                    dispatcher = "console"
                 })
             end, "Invalid shortcut config: Shortcut config must have a 'formatter' field")
         end)
 
-        it("should reject non-string output field", function()
+        it("should reject non-string dispatcher field", function()
             assert.has_error(function()
                 lualog.logger({
-                    output = 123,
+                    dispatcher = 123,
                     formatter = "text"
                 })
-            end, "Invalid shortcut config: Output type must be a string")
+            end, "Invalid shortcut config: dispatcher type must be a string")
         end)
 
         it("should reject non-string formatter field", function()
             assert.has_error(function()
                 lualog.logger({
-                    output = "console",
+                    dispatcher = "console",
                     formatter = 456
                 })
             end, "Invalid shortcut config: Formatter type must be a string")
         end)
 
-        it("should reject unknown output types", function()
+        it("should reject unknown dispatcher types", function()
             local expected_error = "Invalid shortcut config: " ..
-                constants.generate_expected_error_message("unknown", constants.VALID_OUTPUT_TYPES)
+                constants.generate_expected_error_message("unknown", constants.VALID_dispatcher_TYPES)
             assert.has_error(function()
                 lualog.logger({
-                    output = "unknown",
+                    dispatcher = "unknown",
                     formatter = "text"
                 })
             end, expected_error)
@@ -167,45 +167,45 @@ describe("Shortcut Declarative API", function()
                 constants.generate_expected_error_message("unknown", constants.VALID_FORMATTER_TYPES)
             assert.has_error(function()
                 lualog.logger({
-                    output = "console",
+                    dispatcher = "console",
                     formatter = "unknown"
                 })
             end, expected_error)
         end)
 
-        it("should reject file output without path", function()
+        it("should reject file dispatcher without path", function()
             assert.has_error(function()
                 lualog.logger({
-                    output = "file",
+                    dispatcher = "file",
                     formatter = "text"
                 })
-            end, "Invalid shortcut config: File output must have a 'path' string field")
+            end, "Invalid shortcut config: File dispatcher must have a 'path' string field")
         end)
 
-        it("should reject file output with non-string path", function()
+        it("should reject file dispatcher with non-string path", function()
             assert.has_error(function()
                 lualog.logger({
-                    output = "file",
+                    dispatcher = "file",
                     formatter = "text",
                     path = 123
                 })
-            end, "Invalid shortcut config: File output must have a 'path' string field")
+            end, "Invalid shortcut config: File dispatcher must have a 'path' string field")
         end)
 
-        it("should reject console output with invalid stream type", function()
+        it("should reject console dispatcher with invalid stream type", function()
             assert.has_error(function()
                 lualog.logger({
-                    output = "console",
+                    dispatcher = "console",
                     formatter = "text",
                     stream = "stdout"
                 })
-            end, "Invalid shortcut config: Console output 'stream' field must be a file handle")
+            end, "Invalid shortcut config: Console dispatcher 'stream' field must be a file handle")
         end)
 
         it("should reject unknown shortcut config keys", function()
             assert.has_error(function()
                 lualog.logger({
-                    output = "console",
+                    dispatcher = "console",
                     formatter = "text",
                     unknown_key = "value"
                 })
@@ -217,7 +217,7 @@ describe("Shortcut Declarative API", function()
                 constants.generate_expected_error_message("invalid_level", constants.VALID_LEVEL_STRINGS)
             assert.has_error(function()
                     lualog.logger({
-                        output = "console",
+                        dispatcher = "console",
                         formatter = "text",
                         level = "invalid_level"
                     })
@@ -228,7 +228,7 @@ describe("Shortcut Declarative API", function()
         it("should reject invalid name type in shortcut config", function()
             assert.has_error(function()
                 lualog.logger({
-                    output = "console",
+                    dispatcher = "console",
                     formatter = "text",
                     name = 123
                 })
@@ -238,7 +238,7 @@ describe("Shortcut Declarative API", function()
         it("should reject invalid propagate type in shortcut config", function()
             assert.has_error(function()
                 lualog.logger({
-                    output = "console",
+                    dispatcher = "console",
                     formatter = "text",
                     propagate = "yes"
                 })
@@ -250,7 +250,7 @@ describe("Shortcut Declarative API", function()
         it("should transform console shortcut to standard declarative format", function()
             local shortcut = {
                 name = "test",
-                output = "console",
+                dispatcher = "console",
                 formatter = "text",
                 level = "debug",
                 propagate = false
@@ -261,15 +261,15 @@ describe("Shortcut Declarative API", function()
             assert.are.same("test", standard.name)
             assert.are.same("debug", standard.level)
             assert.is_false(standard.propagate)
-            assert.are.same(1, #standard.outputs)
-            assert.are.same("console", standard.outputs[1].type)
-            assert.are.same("text", standard.outputs[1].formatter)
+            assert.are.same(1, #standard.dispatchers)
+            assert.are.same("console", standard.dispatchers[1].type)
+            assert.are.same("text", standard.dispatchers[1].formatter)
         end)
 
         it("should transform file shortcut to standard declarative format", function()
             local shortcut = {
                 name = "test",
-                output = "file",
+                dispatcher = "file",
                 path = "app.log",
                 formatter = "color"
             }
@@ -277,25 +277,25 @@ describe("Shortcut Declarative API", function()
             local standard = config.shortcut_to_declarative_config(shortcut)
 
             assert.are.same("test", standard.name)
-            assert.are.same(1, #standard.outputs)
-            assert.are.same("file", standard.outputs[1].type)
-            assert.are.same("color", standard.outputs[1].formatter)
-            assert.are.same("app.log", standard.outputs[1].path)
+            assert.are.same(1, #standard.dispatchers)
+            assert.are.same("file", standard.dispatchers[1].type)
+            assert.are.same("color", standard.dispatchers[1].formatter)
+            assert.are.same("app.log", standard.dispatchers[1].path)
         end)
 
         it("should transform console shortcut with stream to standard format", function()
             local shortcut = {
-                output = "console",
+                dispatcher = "console",
                 formatter = "color",
                 stream = io.stderr
             }
 
             local standard = config.shortcut_to_declarative_config(shortcut)
 
-            assert.are.same(1, #standard.outputs)
-            assert.are.same("console", standard.outputs[1].type)
-            assert.are.same("color", standard.outputs[1].formatter)
-            assert.are.same(io.stderr, standard.outputs[1].stream)
+            assert.are.same(1, #standard.dispatchers)
+            assert.are.same("console", standard.dispatchers[1].type)
+            assert.are.same("color", standard.dispatchers[1].formatter)
+            assert.are.same(io.stderr, standard.dispatchers[1].stream)
         end)
     end)
 
@@ -303,7 +303,7 @@ describe("Shortcut Declarative API", function()
         it("should work with logging methods", function()
             local logger = lualog.logger({
                 name = "test.shortcut.integration",
-                output = "console",
+                dispatcher = "console",
                 formatter = "text",
                 level = "debug"
             })
@@ -320,7 +320,7 @@ describe("Shortcut Declarative API", function()
 
         it("should work with level checking", function()
             local logger = lualog.logger({
-                output = "console",
+                dispatcher = "console",
                 formatter = "text",
                 level = "warning"
             })
@@ -334,7 +334,7 @@ describe("Shortcut Declarative API", function()
 
         it("should work with imperative API methods", function()
             local logger = lualog.logger({
-                output = "console",
+                dispatcher = "console",
                 formatter = "text",
                 level = "info"
             })
@@ -343,8 +343,8 @@ describe("Shortcut Declarative API", function()
             logger:set_level(lualog.levels.DEBUG)
             assert.are.same(lualog.levels.DEBUG, logger.level)
 
-            logger:add_output(lualog.lib.console, lualog.lib.text, {})
-            assert.are.same(2, #logger.outputs)
+            logger:add_dispatcher(lualog.lib.console, lualog.lib.text, {})
+            assert.are.same(2, #logger.dispatchers)
 
             logger:set_propagate(false)
             assert.is_false(logger.propagate)
@@ -353,7 +353,7 @@ describe("Shortcut Declarative API", function()
         it("should create parent loggers automatically", function()
             local logger = lualog.logger({
                 name = "app.database.connection",
-                output = "console",
+                dispatcher = "console",
                 formatter = "text"
             })
 
@@ -368,12 +368,12 @@ describe("Shortcut Declarative API", function()
         it("should cache created loggers", function()
             local logger1 = lualog.logger({
                 name = "test.shortcut.cache",
-                output = "console",
+                dispatcher = "console",
                 formatter = "text"
             })
             local logger2 = lualog.logger({
                 name = "test.shortcut.cache",
-                output = "file",
+                dispatcher = "file",
                 path = "different.log",
                 formatter = "color"
             })
@@ -381,7 +381,7 @@ describe("Shortcut Declarative API", function()
             -- Should return the same cached instance (first one wins)
             assert.are.same(logger1, logger2)
             -- The second config should be ignored since the logger is already cached
-            assert.are.same(1, #logger2.outputs) -- Should still have console output, not file
+            assert.are.same(1, #logger2.dispatchers) -- Should still have console dispatcher, not file
         end)
     end)
 
@@ -405,7 +405,7 @@ describe("Shortcut Declarative API", function()
             for _, case in ipairs(test_cases) do
                 local logger = lualog.logger({
                     name = "test.shortcut.level." .. case.input,
-                    output = "console",
+                    dispatcher = "console",
                     formatter = "text",
                     level = case.input
                 })
@@ -416,7 +416,7 @@ describe("Shortcut Declarative API", function()
         it("should accept numeric levels", function()
             local logger = lualog.logger({
                 name = "test.shortcut.numeric.level",
-                output = "console",
+                dispatcher = "console",
                 formatter = "text",
                 level = lualog.levels.WARNING
             })
@@ -426,9 +426,9 @@ describe("Shortcut Declarative API", function()
 
     describe("Examples from API proposal", function()
         it("should support the exact example from the API proposal", function()
-            -- Example from api.txt: {output = "console", level = "debug", formatter = "color"}
+            -- Example from api.txt: {dispatcher = "console", level = "debug", formatter = "color"}
             local logger = lualog.logger({
-                output = "console",
+                dispatcher = "console",
                 level = "debug",
                 formatter = "color"
             })
@@ -436,24 +436,24 @@ describe("Shortcut Declarative API", function()
             assert.is_not_nil(logger)
             assert.are.same("root", logger.name) -- Default name
             assert.are.same(lualog.levels.DEBUG, logger.level)
-            assert.are.same(1, #logger.outputs)
+            assert.are.same(1, #logger.dispatchers)
 
-            local output = logger.outputs[1]
-            assert.is_function(output.output_func)
-            assert.is_true(is_callable(output.formatter_func))
+            local dispatcher = logger.dispatchers[1]
+            assert.is_function(dispatcher.dispatcher_func)
+            assert.is_true(is_callable(dispatcher.formatter_func))
         end)
 
         it("should work with named logger using shortcut syntax", function()
             local logger = lualog.logger({
                 name = "app.database",
-                output = "console",
+                dispatcher = "console",
                 level = "debug",
                 formatter = "color"
             })
 
             assert.are.same("app.database", logger.name)
             assert.are.same(lualog.levels.DEBUG, logger.level)
-            assert.are.same(1, #logger.outputs)
+            assert.are.same(1, #logger.dispatchers)
         end)
     end)
 end)
diff --git a/spec/validation_functions_spec.lua b/spec/validation_functions_spec.lua
index 897aa37..2616518 100644
--- a/spec/validation_functions_spec.lua
+++ b/spec/validation_functions_spec.lua
@@ -15,14 +15,14 @@ describe("Validation Functions", function()
     describe("validate_level", function()
         it("should accept nil level", function()
             -- Note: validate_level is not directly exposed, but we can test it through process_config
-            local result = config.process_config({ outputs = {} }, { level = nil })
+            local result = config.process_config({ dispatchers = {} }, { level = nil })
             assert.is_not_nil(result)
         end)
 
         it("should accept valid string levels", function()
             local levels = { "debug", "info", "warning", "error", "critical", "none" }
             for _, level in ipairs(levels) do
-                local result = config.process_config({ level = level, outputs = {} })
+                local result = config.process_config({ level = level, dispatchers = {} })
                 assert.is_not_nil(result, "Failed for level: " .. level)
             end
         end)
@@ -30,91 +30,91 @@ describe("Validation Functions", function()
         it("should accept valid string levels (case insensitive)", function()
             local levels = { "DEBUG", "Info", "WARNING", "Error", "CRITICAL", "None" }
             for _, level in ipairs(levels) do
-                local result = config.process_config({ level = level, outputs = {} })
+                local result = config.process_config({ level = level, dispatchers = {} })
                 assert.is_not_nil(result, "Failed for level: " .. level)
             end
         end)
 
         it("should accept numeric levels", function()
-            local result = config.process_config({ level = 20, outputs = {} })
+            local result = config.process_config({ level = 20, dispatchers = {} })
             assert.is_not_nil(result)
         end)
 
         it("should reject invalid string levels", function()
             assert.has_error(function()
-                config.process_config({ level = "invalid", outputs = {} })
+                config.process_config({ level = "invalid", dispatchers = {} })
             end)
         end)
 
         it("should reject invalid level types", function()
             assert.has_error(function()
-                config.process_config({ level = true, outputs = {} })
+                config.process_config({ level = true, dispatchers = {} })
             end)
         end)
     end)
 
-    describe("validate_single_output", function()
-        it("should accept valid console output", function()
+    describe("validate_single_dispatcher", function()
+        it("should accept valid console dispatcher", function()
             local result = config.process_config({
-                outputs = {
+                dispatchers = {
                     { type = "console", formatter = "text" }
                 }
             })
             assert.is_not_nil(result)
         end)
 
-        it("should accept valid file output", function()
+        it("should accept valid file dispatcher", function()
             local result = config.process_config({
-                outputs = {
+                dispatchers = {
                     { type = "file", formatter = "color", path = "test.log" }
                 }
             })
             assert.is_not_nil(result)
         end)
 
-        it("should accept console output with valid stream", function()
+        it("should accept console dispatcher with valid stream", function()
             local result = config.process_config({
-                outputs = {
+                dispatchers = {
                     { type = "console", formatter = "text", stream = io.stderr }
                 }
             })
             assert.is_not_nil(result)
         end)
 
-        it("should reject output without type", function()
+        it("should reject dispatcher without type", function()
             assert.has_error(function()
                 config.process_config({
-                    outputs = {
+                    dispatchers = {
                         { formatter = "text" }
                     }
                 })
             end)
         end)
 
-        it("should reject output without formatter", function()
+        it("should reject dispatcher without formatter", function()
             assert.has_error(function()
                 config.process_config({
-                    outputs = {
+                    dispatchers = {
                         { type = "console" }
                     }
                 })
             end)
         end)
 
-        it("should reject file output without path", function()
+        it("should reject file dispatcher without path", function()
             assert.has_error(function()
                 config.process_config({
-                    outputs = {
+                    dispatchers = {
                         { type = "file", formatter = "text" }
                     }
                 })
             end)
         end)
 
-        it("should reject console output with invalid stream", function()
+        it("should reject console dispatcher with invalid stream", function()
             assert.has_error(function()
                 config.process_config({
-                    outputs = {
+                    dispatchers = {
                         { type = "console", formatter = "text", stream = "invalid" }
                     }
                 })
@@ -122,20 +122,20 @@ describe("Validation Functions", function()
         end)
     end)
 
-    describe("validate_outputs", function()
-        it("should accept nil outputs", function()
+    describe("validate_dispatchers", function()
+        it("should accept nil dispatchers", function()
             local result = config.process_config({})
             assert.is_not_nil(result)
         end)
 
-        it("should accept empty outputs array", function()
-            local result = config.process_config({ outputs = {} })
+        it("should accept empty dispatchers array", function()
+            local result = config.process_config({ dispatchers = {} })
             assert.is_not_nil(result)
         end)
 
-        it("should accept valid outputs array", function()
+        it("should accept valid dispatchers array", function()
             local result = config.process_config({
-                outputs = {
+                dispatchers = {
                     { type = "console", formatter = "text" },
                     { type = "file",    formatter = "color", path = "test.log" }
                 }
@@ -143,16 +143,16 @@ describe("Validation Functions", function()
             assert.is_not_nil(result)
         end)
 
-        it("should reject non-table outputs", function()
+        it("should reject non-table dispatchers", function()
             assert.has_error(function()
-                config.process_config({ outputs = "not a table" })
+                config.process_config({ dispatchers = "not a table" })
             end)
         end)
 
-        it("should reject outputs with invalid output", function()
+        it("should reject dispatchers with invalid dispatcher", function()
             assert.has_error(function()
                 config.process_config({
-                    outputs = {
+                    dispatchers = {
                         { type = "console", formatter = "text" },
                         { type = "invalid", formatter = "text" }
                     }
@@ -166,70 +166,70 @@ describe("Validation Functions", function()
             local result = config.process_config({
                 name = "test.logger",
                 propagate = true,
-                outputs = {}
+                dispatchers = {}
             })
             assert.is_not_nil(result)
         end)
 
         it("should accept config with nil fields", function()
-            local result = config.process_config({ outputs = {} })
+            local result = config.process_config({ dispatchers = {} })
             assert.is_not_nil(result)
         end)
 
         it("should reject invalid name type", function()
             assert.has_error(function()
-                config.process_config({ name = 123, outputs = {} })
+                config.process_config({ name = 123, dispatchers = {} })
             end)
         end)
 
         it("should reject invalid propagate type", function()
             assert.has_error(function()
-                config.process_config({ propagate = "yes", outputs = {} })
+                config.process_config({ propagate = "yes", dispatchers = {} })
             end)
         end)
     end)
 
     describe("validate_timezone", function()
         it("should accept nil timezone", function()
-            local result = config.process_config({ outputs = {} })
+            local result = config.process_config({ dispatchers = {} })
             assert.is_not_nil(result)
         end)
 
         it("should accept valid timezone 'local'", function()
-            local result = config.process_config({ timezone = "local", outputs = {} })
+            local result = config.process_config({ timezone = "local", dispatchers = {} })
             assert.is_not_nil(result)
         end)
 
         it("should accept valid timezone 'utc'", function()
-            local result = config.process_config({ timezone = "utc", outputs = {} })
+            local result = config.process_config({ timezone = "utc", dispatchers = {} })
             assert.is_not_nil(result)
         end)
 
         it("should accept valid timezone 'UTC' (case insensitive)", function()
-            local result = config.process_config({ timezone = "UTC", outputs = {} })
+            local result = config.process_config({ timezone = "UTC", dispatchers = {} })
             assert.is_not_nil(result)
         end)
 
         it("should accept valid timezone 'LOCAL' (case insensitive)", function()
-            local result = config.process_config({ timezone = "LOCAL", outputs = {} })
+            local result = config.process_config({ timezone = "LOCAL", dispatchers = {} })
             assert.is_not_nil(result)
         end)
 
         it("should reject invalid timezone string", function()
             assert.has_error(function()
-                config.process_config({ timezone = "invalid", outputs = {} })
+                config.process_config({ timezone = "invalid", dispatchers = {} })
             end)
         end)
 
         it("should reject invalid timezone type", function()
             assert.has_error(function()
-                config.process_config({ timezone = 123, outputs = {} })
+                config.process_config({ timezone = 123, dispatchers = {} })
             end)
         end)
 
         it("should reject boolean timezone", function()
             assert.has_error(function()
-                config.process_config({ timezone = true, outputs = {} })
+                config.process_config({ timezone = true, dispatchers = {} })
             end)
         end)
     end)
@@ -239,7 +239,7 @@ describe("Validation Functions", function()
             local result = config.process_config({
                 name = "test",
                 level = "info",
-                outputs = {},
+                dispatchers = {},
                 propagate = true,
                 timezone = "utc"
             })
@@ -250,7 +250,7 @@ describe("Validation Functions", function()
             local result = config.process_config({
                 name = "test",
                 level = "info",
-                outputs = {}
+                dispatchers = {}
             })
             assert.is_not_nil(result)
         end)
@@ -260,7 +260,7 @@ describe("Validation Functions", function()
                 config.process_config({
                     name = "test",
                     unknown_key = "value",
-                    outputs = {}
+                    dispatchers = {}
                 })
             end)
         end)
@@ -268,13 +268,13 @@ describe("Validation Functions", function()
 
     describe("Shortcut API validation", function()
         it("should detect shortcut config", function()
-            assert.is_true(config.is_shortcut_config({ output = "console", formatter = "text" }))
-            assert.is_false(config.is_shortcut_config({ outputs = {} }))
+            assert.is_true(config.is_shortcut_config({ dispatcher = "console", formatter = "text" }))
+            assert.is_false(config.is_shortcut_config({ dispatchers = {} }))
         end)
 
         it("should validate shortcut config", function()
             local result = config.process_config({
-                output = "console",
+                dispatcher = "console",
                 formatter = "text"
             })
             assert.is_not_nil(result)
@@ -283,7 +283,7 @@ describe("Validation Functions", function()
         it("should reject invalid shortcut config", function()
             assert.has_error(function()
                 config.process_config({
-                    output = "console"
+                    dispatcher = "console"
                     -- missing formatter
                 })
             end)
@@ -292,34 +292,34 @@ describe("Validation Functions", function()
         it("should transform shortcut to declarative", function()
             local shortcut = {
                 name = "test",
-                output = "console",
+                dispatcher = "console",
                 formatter = "text"
             }
             local declarative = config.shortcut_to_declarative_config(shortcut)
             assert.are.same("test", declarative.name)
-            assert.are.same(1, #declarative.outputs)
-            assert.are.same("console", declarative.outputs[1].type)
-            assert.are.same("text", declarative.outputs[1].formatter)
+            assert.are.same(1, #declarative.dispatchers)
+            assert.are.same("console", declarative.dispatchers[1].type)
+            assert.are.same("text", declarative.dispatchers[1].formatter)
         end)
 
         it("should transform shortcut to declarative with timezone", function()
             local shortcut = {
                 name = "test",
-                output = "console",
+                dispatcher = "console",
                 formatter = "text",
                 timezone = "utc"
             }
             local declarative = config.shortcut_to_declarative_config(shortcut)
             assert.are.same("test", declarative.name)
             assert.are.same("utc", declarative.timezone)
-            assert.are.same(1, #declarative.outputs)
-            assert.are.same("console", declarative.outputs[1].type)
-            assert.are.same("text", declarative.outputs[1].formatter)
+            assert.are.same(1, #declarative.dispatchers)
+            assert.are.same("console", declarative.dispatchers[1].type)
+            assert.are.same("text", declarative.dispatchers[1].formatter)
         end)
 
         it("should validate shortcut config with timezone", function()
             local result = config.process_config({
-                output = "console",
+                dispatcher = "console",
                 formatter = "text",
                 timezone = "utc"
             })
@@ -340,7 +340,7 @@ describe("Validation Functions", function()
 
             -- Test that validation works with these levels
             for level_name, _ in pairs(lualog.LEVELS) do
-                local result = config.process_config({ level = level_name, outputs = {} })
+                local result = config.process_config({ level = level_name, dispatchers = {} })
                 assert.is_not_nil(result, "Failed for level: " .. level_name)
             end
         end)
diff --git a/test_rotation_tmpdir.lua b/test_rotation_tmpdir.lua
index 908feb6..b7f265f 100644
--- a/test_rotation_tmpdir.lua
+++ b/test_rotation_tmpdir.lua
@@ -5,7 +5,7 @@
 
 package.path = "./lua/?.lua;" .. package.path
 
-local file_output_factory = require("lual.outputs.file_output")
+local file_dispatcher_factory = require("lua.lual.dispatchers.file_dispatcher")
 local os = require("os")
 
 -- Get TMPDIR or use /tmp
@@ -61,7 +61,7 @@ end
 
 -- Test command generation
 print("\n=== Generated commands ===")
-local commands = file_output_factory._generate_rotation_commands(test_log_path)
+local commands = file_dispatcher_factory._generate_rotation_commands(test_log_path)
 for i, cmd in ipairs(commands) do
     if cmd.type == "remove" then
         print(string.format("%d: remove %s", i, cmd.target))
@@ -72,7 +72,7 @@ end
 
 -- Test validation
 print("\n=== Validation ===")
-local valid, err = file_output_factory._validate_rotation_commands(commands, test_log_path)
+local valid, err = file_dispatcher_factory._validate_rotation_commands(commands, test_log_path)
 print("Valid:", valid)
 if not valid then
     print("Error:", err)
@@ -80,7 +80,7 @@ end
 
 -- Execute rotation
 print("\n=== Executing rotation ===")
-local handler = file_output_factory({path = test_log_path})
+local handler = file_dispatcher_factory({ path = test_log_path })
 
 print("\n=== After rotation ===")
 for i = 5, 1, -1 do
@@ -98,7 +98,7 @@ end
 
 -- Test writing to the new log
 print("\n=== Testing log writing ===")
-handler({message = "New log entry after rotation"})
+handler({ message = "New log entry after rotation" })
 
 local exists, content = check_file_exists(test_log_path)
 if exists then
@@ -112,4 +112,4 @@ for i = 1, 5 do
 end
 os.remove(test_log_path)
 
-print("Test completed!")
\ No newline at end of file
+print("Test completed!")
